(self["webpackChunkhotel_page"] = self["webpackChunkhotel_page"] || []).push([["index"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! icon.svg */ "./src/icon.svg"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Lobster&display=swap);"]);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "*{\n    caret-color: transparent;\n}\n\nbody{\n    margin: 0;\n}\n\n#title{\n    \n    height: 10vh;\n    background-color: rgba(255, 255, 255, 0.8);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    font-size: 40px;\n    font-family: 'Lobster', sans-serif;\n    color: rgb(0, 0, 0);\n}\n\n\n#header{\n    display: flex;\n    height: 10vh;\n    justify-content: center;\n    align-items: center;\n    gap:30px;\n    background-color: rgba(17, 120, 216, 0.692);\n    font-family: 'Josefin Sans', sans-serif;\n    font-size: 25px;\n    font-weight: 500;\n}\n\n#middle{\n    display:flex;\n    background-color: rgb(88, 83, 33);\n    height: 90vh;\n    justify-content: center;\n    align-items: center;\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n    font-family: 'Josefin Sans', sans-serif;\n}\n\n#middle-window{\n    background-color: rgba(0, 0, 0, 0.7);\n    color:white;\n    height: 70%;\n    width: 50%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: 10px;\n}\n\n.header-button{\n    caret-color: transparent;\n    /* background-color: turquoise; */\n    height: 50px;\n    width: 150px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n}\n\n.header-button:hover{\n    border-bottom: 3px solid white;\n}\n\n.card{\n    height:100%;\n    width:100%;\n    display: flex;    \n    justify-content: center;\n    align-items: center;\n    border-radius: 10px;\n    font-size: 20px;\n}", "",{"version":3,"sources":["webpack://./src/style.css"],"names":[],"mappings":"AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,SAAS;AACb;;AAEA;;IAEI,YAAY;IACZ,0CAA0C;IAC1C,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,eAAe;IACf,kCAAkC;IAClC,mBAAmB;AACvB;;;AAGA;IACI,aAAa;IACb,YAAY;IACZ,uBAAuB;IACvB,mBAAmB;IACnB,QAAQ;IACR,2CAA2C;IAC3C,uCAAuC;IACvC,eAAe;IACf,gBAAgB;AACpB;;AAEA;IACI,YAAY;IACZ,iCAAiC;IACjC,YAAY;IACZ,uBAAuB;IACvB,mBAAmB;IACnB,mDAA2B;IAC3B,uCAAuC;AAC3C;;AAEA;IACI,oCAAoC;IACpC,WAAW;IACX,WAAW;IACX,UAAU;IACV,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,mBAAmB;AACvB;;AAEA;IACI,wBAAwB;IACxB,iCAAiC;IACjC,YAAY;IACZ,YAAY;IACZ,aAAa;IACb,uBAAuB;IACvB,mBAAmB;;AAEvB;;AAEA;IACI,8BAA8B;AAClC;;AAEA;IACI,WAAW;IACX,UAAU;IACV,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,mBAAmB;IACnB,eAAe;AACnB","sourcesContent":["@import url('https://fonts.googleapis.com/css2?family=Lobster&display=swap');\n\n*{\n    caret-color: transparent;\n}\n\nbody{\n    margin: 0;\n}\n\n#title{\n    \n    height: 10vh;\n    background-color: rgba(255, 255, 255, 0.8);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    font-size: 40px;\n    font-family: 'Lobster', sans-serif;\n    color: rgb(0, 0, 0);\n}\n\n\n#header{\n    display: flex;\n    height: 10vh;\n    justify-content: center;\n    align-items: center;\n    gap:30px;\n    background-color: rgba(17, 120, 216, 0.692);\n    font-family: 'Josefin Sans', sans-serif;\n    font-size: 25px;\n    font-weight: 500;\n}\n\n#middle{\n    display:flex;\n    background-color: rgb(88, 83, 33);\n    height: 90vh;\n    justify-content: center;\n    align-items: center;\n    background: url('icon.svg');\n    font-family: 'Josefin Sans', sans-serif;\n}\n\n#middle-window{\n    background-color: rgba(0, 0, 0, 0.7);\n    color:white;\n    height: 70%;\n    width: 50%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: 10px;\n}\n\n.header-button{\n    caret-color: transparent;\n    /* background-color: turquoise; */\n    height: 50px;\n    width: 150px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n}\n\n.header-button:hover{\n    border-bottom: 3px solid white;\n}\n\n.card{\n    height:100%;\n    width:100%;\n    display: flex;    \n    justify-content: center;\n    align-items: center;\n    border-radius: 10px;\n    font-size: 20px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }

  if (!url) {
    return url;
  }

  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them

  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }

  if (options.hash) {
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/cssesc/cssesc.js":
/*!***************************************!*\
  !*** ./node_modules/cssesc/cssesc.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
/*! https://mths.be/cssesc v3.0.0 by @mathias */


var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge = function merge(options, defaults) {
	if (!options) {
		return defaults;
	}
	var result = {};
	for (var key in defaults) {
		// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
		// only recognized option names are used.
		result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
	}
	return result;
};

var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexAlwaysEscape = /['"\\]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
	options = merge(options, cssesc.options);
	if (options.quotes != 'single' && options.quotes != 'double') {
		options.quotes = 'single';
	}
	var quote = options.quotes == 'double' ? '"' : '\'';
	var isIdentifier = options.isIdentifier;

	var firstChar = string.charAt(0);
	var output = '';
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var character = string.charAt(counter++);
		var codePoint = character.charCodeAt();
		var value = void 0;
		// If it’s not a printable ASCII character…
		if (codePoint < 0x20 || codePoint > 0x7E) {
			if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
				// It’s a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// next character is low surrogate
					codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
				} else {
					// It’s an unmatched surrogate; only append this code unit, in case
					// the next code unit is the high surrogate of a surrogate pair.
					counter--;
				}
			}
			value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
		} else {
			if (options.escapeEverything) {
				if (regexAnySingleEscape.test(character)) {
					value = '\\' + character;
				} else {
					value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
				}
			} else if (/[\t\n\f\r\x0B]/.test(character)) {
				value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
			} else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
				value = '\\' + character;
			} else {
				value = character;
			}
		}
		output += value;
	}

	if (isIdentifier) {
		if (/^-[-\d]/.test(output)) {
			output = '\\-' + output.slice(1);
		} else if (/\d/.test(firstChar)) {
			output = '\\3' + firstChar + ' ' + output.slice(1);
		}
	}

	// Remove spaces after `\HEX` escapes that are not followed by a hex digit,
	// since they’re redundant. Note that this is only possible if the escape
	// sequence isn’t preceded by an odd number of backslashes.
	output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
		if ($1 && $1.length % 2) {
			// It’s not safe to remove the space, so don’t.
			return $0;
		}
		// Strip the space.
		return ($1 || '') + $2;
	});

	if (!isIdentifier && options.wrap) {
		return quote + output + quote;
	}
	return output;
};

// Expose default options (so they can be overridden globally).
cssesc.options = {
	'escapeEverything': false,
	'isIdentifier': false,
	'quotes': 'single',
	'wrap': false
};

cssesc.version = '3.0.0';

module.exports = cssesc;


/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/index.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _processor = _interopRequireDefault(__webpack_require__(/*! ./processor */ "./node_modules/postcss-selector-parser/dist/processor.js"));

var selectors = _interopRequireWildcard(__webpack_require__(/*! ./selectors */ "./node_modules/postcss-selector-parser/dist/selectors/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var parser = function parser(processor) {
  return new _processor["default"](processor);
};

Object.assign(parser, selectors);
delete parser.__esModule;
var _default = parser;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/parser.js":
/*!*************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/parser.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _root = _interopRequireDefault(__webpack_require__(/*! ./selectors/root */ "./node_modules/postcss-selector-parser/dist/selectors/root.js"));

var _selector = _interopRequireDefault(__webpack_require__(/*! ./selectors/selector */ "./node_modules/postcss-selector-parser/dist/selectors/selector.js"));

var _className = _interopRequireDefault(__webpack_require__(/*! ./selectors/className */ "./node_modules/postcss-selector-parser/dist/selectors/className.js"));

var _comment = _interopRequireDefault(__webpack_require__(/*! ./selectors/comment */ "./node_modules/postcss-selector-parser/dist/selectors/comment.js"));

var _id = _interopRequireDefault(__webpack_require__(/*! ./selectors/id */ "./node_modules/postcss-selector-parser/dist/selectors/id.js"));

var _tag = _interopRequireDefault(__webpack_require__(/*! ./selectors/tag */ "./node_modules/postcss-selector-parser/dist/selectors/tag.js"));

var _string = _interopRequireDefault(__webpack_require__(/*! ./selectors/string */ "./node_modules/postcss-selector-parser/dist/selectors/string.js"));

var _pseudo = _interopRequireDefault(__webpack_require__(/*! ./selectors/pseudo */ "./node_modules/postcss-selector-parser/dist/selectors/pseudo.js"));

var _attribute = _interopRequireWildcard(__webpack_require__(/*! ./selectors/attribute */ "./node_modules/postcss-selector-parser/dist/selectors/attribute.js"));

var _universal = _interopRequireDefault(__webpack_require__(/*! ./selectors/universal */ "./node_modules/postcss-selector-parser/dist/selectors/universal.js"));

var _combinator = _interopRequireDefault(__webpack_require__(/*! ./selectors/combinator */ "./node_modules/postcss-selector-parser/dist/selectors/combinator.js"));

var _nesting = _interopRequireDefault(__webpack_require__(/*! ./selectors/nesting */ "./node_modules/postcss-selector-parser/dist/selectors/nesting.js"));

var _sortAscending = _interopRequireDefault(__webpack_require__(/*! ./sortAscending */ "./node_modules/postcss-selector-parser/dist/sortAscending.js"));

var _tokenize = _interopRequireWildcard(__webpack_require__(/*! ./tokenize */ "./node_modules/postcss-selector-parser/dist/tokenize.js"));

var tokens = _interopRequireWildcard(__webpack_require__(/*! ./tokenTypes */ "./node_modules/postcss-selector-parser/dist/tokenTypes.js"));

var types = _interopRequireWildcard(__webpack_require__(/*! ./selectors/types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js"));

var _util = __webpack_require__(/*! ./util */ "./node_modules/postcss-selector-parser/dist/util/index.js");

var _WHITESPACE_TOKENS, _Object$assign;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));

function tokenStart(token) {
  return {
    line: token[_tokenize.FIELDS.START_LINE],
    column: token[_tokenize.FIELDS.START_COL]
  };
}

function tokenEnd(token) {
  return {
    line: token[_tokenize.FIELDS.END_LINE],
    column: token[_tokenize.FIELDS.END_COL]
  };
}

function getSource(startLine, startColumn, endLine, endColumn) {
  return {
    start: {
      line: startLine,
      column: startColumn
    },
    end: {
      line: endLine,
      column: endColumn
    }
  };
}

function getTokenSource(token) {
  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
}

function getTokenSourceSpan(startToken, endToken) {
  if (!startToken) {
    return undefined;
  }

  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
}

function unescapeProp(node, prop) {
  var value = node[prop];

  if (typeof value !== "string") {
    return;
  }

  if (value.indexOf("\\") !== -1) {
    (0, _util.ensureObject)(node, 'raws');
    node[prop] = (0, _util.unesc)(value);

    if (node.raws[prop] === undefined) {
      node.raws[prop] = value;
    }
  }

  return node;
}

function indexesOf(array, item) {
  var i = -1;
  var indexes = [];

  while ((i = array.indexOf(item, i + 1)) !== -1) {
    indexes.push(i);
  }

  return indexes;
}

function uniqs() {
  var list = Array.prototype.concat.apply([], arguments);
  return list.filter(function (item, i) {
    return i === list.indexOf(item);
  });
}

var Parser = /*#__PURE__*/function () {
  function Parser(rule, options) {
    if (options === void 0) {
      options = {};
    }

    this.rule = rule;
    this.options = Object.assign({
      lossy: false,
      safe: false
    }, options);
    this.position = 0;
    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
    this.tokens = (0, _tokenize["default"])({
      css: this.css,
      error: this._errorGenerator(),
      safe: this.options.safe
    });
    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
    this.root = new _root["default"]({
      source: rootSource
    });
    this.root.errorGenerator = this._errorGenerator();
    var selector = new _selector["default"]({
      source: {
        start: {
          line: 1,
          column: 1
        }
      }
    });
    this.root.append(selector);
    this.current = selector;
    this.loop();
  }

  var _proto = Parser.prototype;

  _proto._errorGenerator = function _errorGenerator() {
    var _this = this;

    return function (message, errorOptions) {
      if (typeof _this.rule === 'string') {
        return new Error(message);
      }

      return _this.rule.error(message, errorOptions);
    };
  };

  _proto.attribute = function attribute() {
    var attr = [];
    var startingToken = this.currToken;
    this.position++;

    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      attr.push(this.currToken);
      this.position++;
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
    }

    var len = attr.length;
    var node = {
      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
    };

    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
    }

    var pos = 0;
    var spaceBefore = '';
    var commentBefore = '';
    var lastAdded = null;
    var spaceAfterMeaningfulToken = false;

    while (pos < len) {
      var token = attr[pos];
      var content = this.content(token);
      var next = attr[pos + 1];

      switch (token[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          // if (
          //     len === 1 ||
          //     pos === 0 && this.content(next) === '|'
          // ) {
          //     return this.expected('attribute', token[TOKEN.START_POS], content);
          // }
          spaceAfterMeaningfulToken = true;

          if (this.options.lossy) {
            break;
          }

          if (lastAdded) {
            (0, _util.ensureObject)(node, 'spaces', lastAdded);
            var prevContent = node.spaces[lastAdded].after || '';
            node.spaces[lastAdded].after = prevContent + content;
            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

            if (existingComment) {
              node.raws.spaces[lastAdded].after = existingComment + content;
            }
          } else {
            spaceBefore = spaceBefore + content;
            commentBefore = commentBefore + content;
          }

          break;

        case tokens.asterisk:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = spaceBefore;
              commentBefore = '';
            }

            node.namespace = (node.namespace || "") + content;
            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;

            if (rawValue) {
              node.raws.namespace += content;
            }

            lastAdded = 'namespace';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.dollar:
          if (lastAdded === "value") {
            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
            node.value += "$";

            if (oldRawValue) {
              node.raws.value = oldRawValue + "$";
            }

            break;
          }

        // Falls through

        case tokens.caret:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.combinator:
          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          if (content !== '|') {
            spaceAfterMeaningfulToken = false;
            break;
          }

          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if (!node.namespace && !node.attribute) {
            node.namespace = true;
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.word:
          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
          !node.operator && !node.namespace) {
            node.namespace = content;
            lastAdded = 'namespace';
          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = commentBefore;
              commentBefore = '';
            }

            node.attribute = (node.attribute || "") + content;

            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;

            if (_rawValue) {
              node.raws.attribute += content;
            }

            lastAdded = 'attribute';
          } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
            var _unescaped = (0, _util.unesc)(content);

            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';

            var oldValue = node.value || '';
            node.value = oldValue + _unescaped;
            node.quoteMark = null;

            if (_unescaped !== content || _oldRawValue) {
              (0, _util.ensureObject)(node, 'raws');
              node.raws.value = (_oldRawValue || oldValue) + content;
            }

            lastAdded = 'value';
          } else {
            var insensitive = content === 'i' || content === "I";

            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
              node.insensitive = insensitive;

              if (!insensitive || content === "I") {
                (0, _util.ensureObject)(node, 'raws');
                node.raws.insensitiveFlag = content;
              }

              lastAdded = 'insensitive';

              if (spaceBefore) {
                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                node.spaces.insensitive.before = spaceBefore;
                spaceBefore = '';
              }

              if (commentBefore) {
                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                node.raws.spaces.insensitive.before = commentBefore;
                commentBefore = '';
              }
            } else if (node.value || node.value === '') {
              lastAdded = 'value';
              node.value += content;

              if (node.raws.value) {
                node.raws.value += content;
              }
            }
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.str:
          if (!node.attribute || !node.operator) {
            return this.error("Expected an attribute followed by an operator preceding the string.", {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          var _unescapeValue = (0, _attribute.unescapeValue)(content),
              unescaped = _unescapeValue.unescaped,
              quoteMark = _unescapeValue.quoteMark;

          node.value = unescaped;
          node.quoteMark = quoteMark;
          lastAdded = 'value';
          (0, _util.ensureObject)(node, 'raws');
          node.raws.value = content;
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.equals:
          if (!node.attribute) {
            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
          }

          if (node.value) {
            return this.error('Unexpected "=" found; an operator was already defined.', {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          node.operator = node.operator ? node.operator + content : content;
          lastAdded = 'operator';
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.comment:
          if (lastAdded) {
            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
              node.raws.spaces[lastAdded].after = rawLastComment + content;
            } else {
              var lastValue = node[lastAdded] || '';
              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
              (0, _util.ensureObject)(node, 'raws');
              node.raws[lastAdded] = rawLastValue + content;
            }
          } else {
            commentBefore = commentBefore + content;
          }

          break;

        default:
          return this.error("Unexpected \"" + content + "\" found.", {
            index: token[_tokenize.FIELDS.START_POS]
          });
      }

      pos++;
    }

    unescapeProp(node, "attribute");
    unescapeProp(node, "namespace");
    this.newNode(new _attribute["default"](node));
    this.position++;
  }
  /**
   * return a node containing meaningless garbage up to (but not including) the specified token position.
   * if the token position is negative, all remaining tokens are consumed.
   *
   * This returns an array containing a single string node if all whitespace,
   * otherwise an array of comment nodes with space before and after.
   *
   * These tokens are not added to the current selector, the caller can add them or use them to amend
   * a previous node's space metadata.
   *
   * In lossy mode, this returns only comments.
   */
  ;

  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
    if (stopPosition < 0) {
      stopPosition = this.tokens.length;
    }

    var startPosition = this.position;
    var nodes = [];
    var space = "";
    var lastComment = undefined;

    do {
      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        if (!this.options.lossy) {
          space += this.content();
        }
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
        var spaces = {};

        if (space) {
          spaces.before = space;
          space = "";
        }

        lastComment = new _comment["default"]({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          spaces: spaces
        });
        nodes.push(lastComment);
      }
    } while (++this.position < stopPosition);

    if (space) {
      if (lastComment) {
        lastComment.spaces.after = space;
      } else if (!this.options.lossy) {
        var firstToken = this.tokens[startPosition];
        var lastToken = this.tokens[this.position - 1];
        nodes.push(new _string["default"]({
          value: '',
          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces: {
            before: space,
            after: ''
          }
        }));
      }
    }

    return nodes;
  }
  /**
   * 
   * @param {*} nodes 
   */
  ;

  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
    var _this2 = this;

    if (requiredSpace === void 0) {
      requiredSpace = false;
    }

    var space = "";
    var rawSpace = "";
    nodes.forEach(function (n) {
      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);

      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);

      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
    });

    if (rawSpace === space) {
      rawSpace = undefined;
    }

    var result = {
      space: space,
      rawSpace: rawSpace
    };
    return result;
  };

  _proto.isNamedCombinator = function isNamedCombinator(position) {
    if (position === void 0) {
      position = this.position;
    }

    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
  };

  _proto.namedCombinator = function namedCombinator() {
    if (this.isNamedCombinator()) {
      var nameRaw = this.content(this.tokens[this.position + 1]);
      var name = (0, _util.unesc)(nameRaw).toLowerCase();
      var raws = {};

      if (name !== nameRaw) {
        raws.value = "/" + nameRaw + "/";
      }

      var node = new _combinator["default"]({
        value: "/" + name + "/",
        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
        raws: raws
      });
      this.position = this.position + 3;
      return node;
    } else {
      this.unexpected();
    }
  };

  _proto.combinator = function combinator() {
    var _this3 = this;

    if (this.content() === '|') {
      return this.namespace();
    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.


    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);

      if (nodes.length > 0) {
        var last = this.current.last;

        if (last) {
          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
              space = _this$convertWhitespa.space,
              rawSpace = _this$convertWhitespa.rawSpace;

          if (rawSpace !== undefined) {
            last.rawSpaceAfter += rawSpace;
          }

          last.spaces.after += space;
        } else {
          nodes.forEach(function (n) {
            return _this3.newNode(n);
          });
        }
      }

      return;
    }

    var firstToken = this.currToken;
    var spaceOrDescendantSelectorNodes = undefined;

    if (nextSigTokenPos > this.position) {
      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
    }

    var node;

    if (this.isNamedCombinator()) {
      node = this.namedCombinator();
    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
      node = new _combinator["default"]({
        value: this.content(),
        source: getTokenSource(this.currToken),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
      });
      this.position++;
    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass
    } else if (!spaceOrDescendantSelectorNodes) {
      this.unexpected();
    }

    if (node) {
      if (spaceOrDescendantSelectorNodes) {
        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
            _space = _this$convertWhitespa2.space,
            _rawSpace = _this$convertWhitespa2.rawSpace;

        node.spaces.before = _space;
        node.rawSpaceBefore = _rawSpace;
      }
    } else {
      // descendant combinator
      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
          _space2 = _this$convertWhitespa3.space,
          _rawSpace2 = _this$convertWhitespa3.rawSpace;

      if (!_rawSpace2) {
        _rawSpace2 = _space2;
      }

      var spaces = {};
      var raws = {
        spaces: {}
      };

      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
        spaces.before = _space2.slice(0, _space2.length - 1);
        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
        spaces.after = _space2.slice(1);
        raws.spaces.after = _rawSpace2.slice(1);
      } else {
        raws.value = _rawSpace2;
      }

      node = new _combinator["default"]({
        value: ' ',
        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
        spaces: spaces,
        raws: raws
      });
    }

    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
      node.spaces.after = this.optionalSpace(this.content());
      this.position++;
    }

    return this.newNode(node);
  };

  _proto.comma = function comma() {
    if (this.position === this.tokens.length - 1) {
      this.root.trailingComma = true;
      this.position++;
      return;
    }

    this.current._inferEndPosition();

    var selector = new _selector["default"]({
      source: {
        start: tokenStart(this.tokens[this.position + 1])
      }
    });
    this.current.parent.append(selector);
    this.current = selector;
    this.position++;
  };

  _proto.comment = function comment() {
    var current = this.currToken;
    this.newNode(new _comment["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.error = function error(message, opts) {
    throw this.root.error(message, opts);
  };

  _proto.missingBackslash = function missingBackslash() {
    return this.error('Expected a backslash preceding the semicolon.', {
      index: this.currToken[_tokenize.FIELDS.START_POS]
    });
  };

  _proto.missingParenthesis = function missingParenthesis() {
    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.missingSquareBracket = function missingSquareBracket() {
    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.unexpected = function unexpected() {
    return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.namespace = function namespace() {
    var before = this.prevToken && this.content(this.prevToken) || true;

    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.position++;
      return this.word(before);
    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
      this.position++;
      return this.universal(before);
    }
  };

  _proto.nesting = function nesting() {
    if (this.nextToken) {
      var nextContent = this.content(this.nextToken);

      if (nextContent === "|") {
        this.position++;
        return;
      }
    }

    var current = this.currToken;
    this.newNode(new _nesting["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.parentheses = function parentheses() {
    var last = this.current.last;
    var unbalanced = 1;
    this.position++;

    if (last && last.type === types.PSEUDO) {
      var selector = new _selector["default"]({
        source: {
          start: tokenStart(this.tokens[this.position - 1])
        }
      });
      var cache = this.current;
      last.append(selector);
      this.current = selector;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        if (unbalanced) {
          this.parse();
        } else {
          this.current.source.end = tokenEnd(this.currToken);
          this.current.parent.source.end = tokenEnd(this.currToken);
          this.position++;
        }
      }

      this.current = cache;
    } else {
      // I think this case should be an error. It's used to implement a basic parse of media queries
      // but I don't think it's a good idea.
      var parenStart = this.currToken;
      var parenValue = "(";
      var parenEnd;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        parenEnd = this.currToken;
        parenValue += this.parseParenthesisToken(this.currToken);
        this.position++;
      }

      if (last) {
        last.appendToPropertyAndEscape("value", parenValue, parenValue);
      } else {
        this.newNode(new _string["default"]({
          value: parenValue,
          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
        }));
      }
    }

    if (unbalanced) {
      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.pseudo = function pseudo() {
    var _this4 = this;

    var pseudoStr = '';
    var startingToken = this.currToken;

    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
      pseudoStr += this.content();
      this.position++;
    }

    if (!this.currToken) {
      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.splitWord(false, function (first, length) {
        pseudoStr += first;

        _this4.newNode(new _pseudo["default"]({
          value: pseudoStr,
          source: getTokenSourceSpan(startingToken, _this4.currToken),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        }));

        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          _this4.error('Misplaced parenthesis.', {
            index: _this4.nextToken[_tokenize.FIELDS.START_POS]
          });
        }
      });
    } else {
      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.space = function space() {
    var content = this.content(); // Handle space before and after the selector

    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
      return node.type === 'comment';
    })) {
      this.spaces = this.optionalSpace(content);
      this.position++;
    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
      this.current.last.spaces.after = this.optionalSpace(content);
      this.position++;
    } else {
      this.combinator();
    }
  };

  _proto.string = function string() {
    var current = this.currToken;
    this.newNode(new _string["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.universal = function universal(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    var current = this.currToken;
    this.newNode(new _universal["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }), namespace);
    this.position++;
  };

  _proto.splitWord = function splitWord(namespace, firstCallback) {
    var _this5 = this;

    var nextToken = this.nextToken;
    var word = this.content();

    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
      this.position++;
      var current = this.content();
      word += current;

      if (current.lastIndexOf('\\') === current.length - 1) {
        var next = this.nextToken;

        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
          word += this.requiredSpace(this.content(next));
          this.position++;
        }
      }

      nextToken = this.nextToken;
    }

    var hasClass = indexesOf(word, '.').filter(function (i) {
      // Allow escaped dot within class name
      var escapedDot = word[i - 1] === '\\'; // Allow decimal numbers percent in @keyframes

      var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
      return !escapedDot && !isKeyframesPercent;
    });
    var hasId = indexesOf(word, '#').filter(function (i) {
      return word[i - 1] !== '\\';
    }); // Eliminate Sass interpolations from the list of id indexes

    var interpolations = indexesOf(word, '#{');

    if (interpolations.length) {
      hasId = hasId.filter(function (hashIndex) {
        return !~interpolations.indexOf(hashIndex);
      });
    }

    var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
    indices.forEach(function (ind, i) {
      var index = indices[i + 1] || word.length;
      var value = word.slice(ind, index);

      if (i === 0 && firstCallback) {
        return firstCallback.call(_this5, value, indices.length);
      }

      var node;
      var current = _this5.currToken;
      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

      if (~hasClass.indexOf(ind)) {
        var classNameOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _className["default"](unescapeProp(classNameOpts, "value"));
      } else if (~hasId.indexOf(ind)) {
        var idOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _id["default"](unescapeProp(idOpts, "value"));
      } else {
        var tagOpts = {
          value: value,
          source: source,
          sourceIndex: sourceIndex
        };
        unescapeProp(tagOpts, "value");
        node = new _tag["default"](tagOpts);
      }

      _this5.newNode(node, namespace); // Ensure that the namespace is used only once


      namespace = null;
    });
    this.position++;
  };

  _proto.word = function word(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    return this.splitWord(namespace);
  };

  _proto.loop = function loop() {
    while (this.position < this.tokens.length) {
      this.parse(true);
    }

    this.current._inferEndPosition();

    return this.root;
  };

  _proto.parse = function parse(throwOnParenthesis) {
    switch (this.currToken[_tokenize.FIELDS.TYPE]) {
      case tokens.space:
        this.space();
        break;

      case tokens.comment:
        this.comment();
        break;

      case tokens.openParenthesis:
        this.parentheses();
        break;

      case tokens.closeParenthesis:
        if (throwOnParenthesis) {
          this.missingParenthesis();
        }

        break;

      case tokens.openSquare:
        this.attribute();
        break;

      case tokens.dollar:
      case tokens.caret:
      case tokens.equals:
      case tokens.word:
        this.word();
        break;

      case tokens.colon:
        this.pseudo();
        break;

      case tokens.comma:
        this.comma();
        break;

      case tokens.asterisk:
        this.universal();
        break;

      case tokens.ampersand:
        this.nesting();
        break;

      case tokens.slash:
      case tokens.combinator:
        this.combinator();
        break;

      case tokens.str:
        this.string();
        break;
      // These cases throw; no break needed.

      case tokens.closeSquare:
        this.missingSquareBracket();

      case tokens.semicolon:
        this.missingBackslash();

      default:
        this.unexpected();
    }
  }
  /**
   * Helpers
   */
  ;

  _proto.expected = function expected(description, index, found) {
    if (Array.isArray(description)) {
      var last = description.pop();
      description = description.join(', ') + " or " + last;
    }

    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

    if (!found) {
      return this.error("Expected " + an + " " + description + ".", {
        index: index
      });
    }

    return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
      index: index
    });
  };

  _proto.requiredSpace = function requiredSpace(space) {
    return this.options.lossy ? ' ' : space;
  };

  _proto.optionalSpace = function optionalSpace(space) {
    return this.options.lossy ? '' : space;
  };

  _proto.lossySpace = function lossySpace(space, required) {
    if (this.options.lossy) {
      return required ? ' ' : '';
    } else {
      return space;
    }
  };

  _proto.parseParenthesisToken = function parseParenthesisToken(token) {
    var content = this.content(token);

    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
      return this.requiredSpace(content);
    } else {
      return content;
    }
  };

  _proto.newNode = function newNode(node, namespace) {
    if (namespace) {
      if (/^ +$/.test(namespace)) {
        if (!this.options.lossy) {
          this.spaces = (this.spaces || '') + namespace;
        }

        namespace = true;
      }

      node.namespace = namespace;
      unescapeProp(node, "namespace");
    }

    if (this.spaces) {
      node.spaces.before = this.spaces;
      this.spaces = '';
    }

    return this.current.append(node);
  };

  _proto.content = function content(token) {
    if (token === void 0) {
      token = this.currToken;
    }

    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
  };

  /**
   * returns the index of the next non-whitespace, non-comment token.
   * returns -1 if no meaningful token is found.
   */
  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
    if (startPosition === void 0) {
      startPosition = this.position + 1;
    }

    var searchPosition = startPosition;

    while (searchPosition < this.tokens.length) {
      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
        searchPosition++;
        continue;
      } else {
        return searchPosition;
      }
    }

    return -1;
  };

  _createClass(Parser, [{
    key: "currToken",
    get: function get() {
      return this.tokens[this.position];
    }
  }, {
    key: "nextToken",
    get: function get() {
      return this.tokens[this.position + 1];
    }
  }, {
    key: "prevToken",
    get: function get() {
      return this.tokens[this.position - 1];
    }
  }]);

  return Parser;
}();

exports["default"] = Parser;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/processor.js":
/*!****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/processor.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _parser = _interopRequireDefault(__webpack_require__(/*! ./parser */ "./node_modules/postcss-selector-parser/dist/parser.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Processor = /*#__PURE__*/function () {
  function Processor(func, options) {
    this.func = func || function noop() {};

    this.funcRes = null;
    this.options = options;
  }

  var _proto = Processor.prototype;

  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.updateSelector === false) {
      return false;
    } else {
      return typeof rule !== "string";
    }
  };

  _proto._isLossy = function _isLossy(options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.lossless === false) {
      return true;
    } else {
      return false;
    }
  };

  _proto._root = function _root(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var parser = new _parser["default"](rule, this._parseOptions(options));
    return parser.root;
  };

  _proto._parseOptions = function _parseOptions(options) {
    return {
      lossy: this._isLossy(options)
    };
  };

  _proto._run = function _run(rule, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    return new Promise(function (resolve, reject) {
      try {
        var root = _this._root(rule, options);

        Promise.resolve(_this.func(root)).then(function (transform) {
          var string = undefined;

          if (_this._shouldUpdateSelector(rule, options)) {
            string = root.toString();
            rule.selector = string;
          }

          return {
            transform: transform,
            root: root,
            string: string
          };
        }).then(resolve, reject);
      } catch (e) {
        reject(e);
        return;
      }
    });
  };

  _proto._runSync = function _runSync(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var root = this._root(rule, options);

    var transform = this.func(root);

    if (transform && typeof transform.then === "function") {
      throw new Error("Selector processor returned a promise to a synchronous call.");
    }

    var string = undefined;

    if (options.updateSelector && typeof rule !== "string") {
      string = root.toString();
      rule.selector = string;
    }

    return {
      transform: transform,
      root: root,
      string: string
    };
  }
  /**
   * Process rule into a selector AST.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<parser.Root>} The AST of the selector after processing it.
   */
  ;

  _proto.ast = function ast(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.root;
    });
  }
  /**
   * Process rule into a selector AST synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {parser.Root} The AST of the selector after processing it.
   */
  ;

  _proto.astSync = function astSync(rule, options) {
    return this._runSync(rule, options).root;
  }
  /**
   * Process a selector into a transformed value asynchronously
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<any>} The value returned by the processor.
   */
  ;

  _proto.transform = function transform(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.transform;
    });
  }
  /**
   * Process a selector into a transformed value synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {any} The value returned by the processor.
   */
  ;

  _proto.transformSync = function transformSync(rule, options) {
    return this._runSync(rule, options).transform;
  }
  /**
   * Process a selector into a new selector string asynchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.process = function process(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.string || result.root.toString();
    });
  }
  /**
   * Process a selector into a new selector string synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.processSync = function processSync(rule, options) {
    var result = this._runSync(rule, options);

    return result.string || result.root.toString();
  };

  return Processor;
}();

exports["default"] = Processor;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/attribute.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/attribute.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.unescapeValue = unescapeValue;
exports["default"] = void 0;

var _cssesc = _interopRequireDefault(__webpack_require__(/*! cssesc */ "./node_modules/cssesc/cssesc.js"));

var _unesc = _interopRequireDefault(__webpack_require__(/*! ../util/unesc */ "./node_modules/postcss-selector-parser/dist/util/unesc.js"));

var _namespace = _interopRequireDefault(__webpack_require__(/*! ./namespace */ "./node_modules/postcss-selector-parser/dist/selectors/namespace.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

var _CSSESC_QUOTE_OPTIONS;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var deprecate = __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js");

var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

function unescapeValue(value) {
  var deprecatedUsage = false;
  var quoteMark = null;
  var unescaped = value;
  var m = unescaped.match(WRAPPED_IN_QUOTES);

  if (m) {
    quoteMark = m[1];
    unescaped = m[2];
  }

  unescaped = (0, _unesc["default"])(unescaped);

  if (unescaped !== value) {
    deprecatedUsage = true;
  }

  return {
    deprecatedUsage: deprecatedUsage,
    unescaped: unescaped,
    quoteMark: quoteMark
  };
}

function handleDeprecatedContructorOpts(opts) {
  if (opts.quoteMark !== undefined) {
    return opts;
  }

  if (opts.value === undefined) {
    return opts;
  }

  warnOfDeprecatedConstructor();

  var _unescapeValue = unescapeValue(opts.value),
      quoteMark = _unescapeValue.quoteMark,
      unescaped = _unescapeValue.unescaped;

  if (!opts.raws) {
    opts.raws = {};
  }

  if (opts.raws.value === undefined) {
    opts.raws.value = opts.value;
  }

  opts.value = unescaped;
  opts.quoteMark = quoteMark;
  return opts;
}

var Attribute = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Attribute, _Namespace);

  function Attribute(opts) {
    var _this;

    if (opts === void 0) {
      opts = {};
    }

    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
    _this.type = _types.ATTRIBUTE;
    _this.raws = _this.raws || {};
    Object.defineProperty(_this.raws, 'unquoted', {
      get: deprecate(function () {
        return _this.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
      set: deprecate(function () {
        return _this.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
    });
    _this._constructed = true;
    return _this;
  }
  /**
   * Returns the Attribute's value quoted such that it would be legal to use
   * in the value of a css file. The original value's quotation setting
   * used for stringification is left unchanged. See `setValue(value, options)`
   * if you want to control the quote settings of a new value for the attribute.
   *
   * You can also change the quotation used for the current value by setting quoteMark.
   *
   * Options:
   *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
   *     option is not set, the original value for quoteMark will be used. If
   *     indeterminate, a double quote is used. The legal values are:
   *     * `null` - the value will be unquoted and characters will be escaped as necessary.
   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
   *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
   *     over the quoteMark option value.
   *   * smart {boolean} - if true, will select a quote mark based on the value
   *     and the other options specified here. See the `smartQuoteMark()`
   *     method.
   **/


  var _proto = Attribute.prototype;

  _proto.getQuotedValue = function getQuotedValue(options) {
    if (options === void 0) {
      options = {};
    }

    var quoteMark = this._determineQuoteMark(options);

    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
    var escaped = (0, _cssesc["default"])(this._value, cssescopts);
    return escaped;
  };

  _proto._determineQuoteMark = function _determineQuoteMark(options) {
    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
  }
  /**
   * Set the unescaped value with the specified quotation options. The value
   * provided must not include any wrapping quote marks -- those quotes will
   * be interpreted as part of the value and escaped accordingly.
   */
  ;

  _proto.setValue = function setValue(value, options) {
    if (options === void 0) {
      options = {};
    }

    this._value = value;
    this._quoteMark = this._determineQuoteMark(options);

    this._syncRawValue();
  }
  /**
   * Intelligently select a quoteMark value based on the value's contents. If
   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
   * mark will be picked that minimizes the number of escapes.
   *
   * If there's no clear winner, the quote mark from these options is used,
   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
   * true). If the quoteMark is unspecified, a double quote is used.
   *
   * @param options This takes the quoteMark and preferCurrentQuoteMark options
   * from the quoteValue method.
   */
  ;

  _proto.smartQuoteMark = function smartQuoteMark(options) {
    var v = this.value;
    var numSingleQuotes = v.replace(/[^']/g, '').length;
    var numDoubleQuotes = v.replace(/[^"]/g, '').length;

    if (numSingleQuotes + numDoubleQuotes === 0) {
      var escaped = (0, _cssesc["default"])(v, {
        isIdentifier: true
      });

      if (escaped === v) {
        return Attribute.NO_QUOTE;
      } else {
        var pref = this.preferredQuoteMark(options);

        if (pref === Attribute.NO_QUOTE) {
          // pick a quote mark that isn't none and see if it's smaller
          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
          var opts = CSSESC_QUOTE_OPTIONS[quote];
          var quoteValue = (0, _cssesc["default"])(v, opts);

          if (quoteValue.length < escaped.length) {
            return quote;
          }
        }

        return pref;
      }
    } else if (numDoubleQuotes === numSingleQuotes) {
      return this.preferredQuoteMark(options);
    } else if (numDoubleQuotes < numSingleQuotes) {
      return Attribute.DOUBLE_QUOTE;
    } else {
      return Attribute.SINGLE_QUOTE;
    }
  }
  /**
   * Selects the preferred quote mark based on the options and the current quote mark value.
   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
   * instead.
   */
  ;

  _proto.preferredQuoteMark = function preferredQuoteMark(options) {
    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

    if (quoteMark === undefined) {
      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
    }

    if (quoteMark === undefined) {
      quoteMark = Attribute.DOUBLE_QUOTE;
    }

    return quoteMark;
  };

  _proto._syncRawValue = function _syncRawValue() {
    var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

    if (rawValue === this._value) {
      if (this.raws) {
        delete this.raws.value;
      }
    } else {
      this.raws.value = rawValue;
    }
  };

  _proto._handleEscapes = function _handleEscapes(prop, value) {
    if (this._constructed) {
      var escaped = (0, _cssesc["default"])(value, {
        isIdentifier: true
      });

      if (escaped !== value) {
        this.raws[prop] = escaped;
      } else {
        delete this.raws[prop];
      }
    }
  };

  _proto._spacesFor = function _spacesFor(name) {
    var attrSpaces = {
      before: '',
      after: ''
    };
    var spaces = this.spaces[name] || {};
    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
    return Object.assign(attrSpaces, spaces, rawSpaces);
  };

  _proto._stringFor = function _stringFor(name, spaceName, concat) {
    if (spaceName === void 0) {
      spaceName = name;
    }

    if (concat === void 0) {
      concat = defaultAttrConcat;
    }

    var attrSpaces = this._spacesFor(spaceName);

    return concat(this.stringifyProperty(name), attrSpaces);
  }
  /**
   * returns the offset of the attribute part specified relative to the
   * start of the node of the output string.
   *
   * * "ns" - alias for "namespace"
   * * "namespace" - the namespace if it exists.
   * * "attribute" - the attribute name
   * * "attributeNS" - the start of the attribute or its namespace
   * * "operator" - the match operator of the attribute
   * * "value" - The value (string or identifier)
   * * "insensitive" - the case insensitivity flag;
   * @param part One of the possible values inside an attribute.
   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
   */
  ;

  _proto.offsetOf = function offsetOf(name) {
    var count = 1;

    var attributeSpaces = this._spacesFor("attribute");

    count += attributeSpaces.before.length;

    if (name === "namespace" || name === "ns") {
      return this.namespace ? count : -1;
    }

    if (name === "attributeNS") {
      return count;
    }

    count += this.namespaceString.length;

    if (this.namespace) {
      count += 1;
    }

    if (name === "attribute") {
      return count;
    }

    count += this.stringifyProperty("attribute").length;
    count += attributeSpaces.after.length;

    var operatorSpaces = this._spacesFor("operator");

    count += operatorSpaces.before.length;
    var operator = this.stringifyProperty("operator");

    if (name === "operator") {
      return operator ? count : -1;
    }

    count += operator.length;
    count += operatorSpaces.after.length;

    var valueSpaces = this._spacesFor("value");

    count += valueSpaces.before.length;
    var value = this.stringifyProperty("value");

    if (name === "value") {
      return value ? count : -1;
    }

    count += value.length;
    count += valueSpaces.after.length;

    var insensitiveSpaces = this._spacesFor("insensitive");

    count += insensitiveSpaces.before.length;

    if (name === "insensitive") {
      return this.insensitive ? count : -1;
    }

    return -1;
  };

  _proto.toString = function toString() {
    var _this2 = this;

    var selector = [this.rawSpaceBefore, '['];
    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

    if (this.operator && (this.value || this.value === '')) {
      selector.push(this._stringFor('operator'));
      selector.push(this._stringFor('value'));
      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
          attrSpaces.before = " ";
        }

        return defaultAttrConcat(attrValue, attrSpaces);
      }));
    }

    selector.push(']');
    selector.push(this.rawSpaceAfter);
    return selector.join('');
  };

  _createClass(Attribute, [{
    key: "quoted",
    get: function get() {
      var qm = this.quoteMark;
      return qm === "'" || qm === '"';
    },
    set: function set(value) {
      warnOfDeprecatedQuotedAssignment();
    }
    /**
     * returns a single (`'`) or double (`"`) quote character if the value is quoted.
     * returns `null` if the value is not quoted.
     * returns `undefined` if the quotation state is unknown (this can happen when
     * the attribute is constructed without specifying a quote mark.)
     */

  }, {
    key: "quoteMark",
    get: function get() {
      return this._quoteMark;
    }
    /**
     * Set the quote mark to be used by this attribute's value.
     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
     * value is updated accordingly.
     *
     * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
     */
    ,
    set: function set(quoteMark) {
      if (!this._constructed) {
        this._quoteMark = quoteMark;
        return;
      }

      if (this._quoteMark !== quoteMark) {
        this._quoteMark = quoteMark;

        this._syncRawValue();
      }
    }
  }, {
    key: "qualifiedAttribute",
    get: function get() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    }
  }, {
    key: "insensitiveFlag",
    get: function get() {
      return this.insensitive ? 'i' : '';
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Before 3.0, the value had to be set to an escaped value including any wrapped
     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
     * is unescaped during parsing and any quote marks are removed.
     *
     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
     * a deprecation warning is raised when the new value contains any characters that would
     * require escaping (including if it contains wrapped quotes).
     *
     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
     * how the new value is quoted.
     */
    ,
    set: function set(v) {
      if (this._constructed) {
        var _unescapeValue2 = unescapeValue(v),
            deprecatedUsage = _unescapeValue2.deprecatedUsage,
            unescaped = _unescapeValue2.unescaped,
            quoteMark = _unescapeValue2.quoteMark;

        if (deprecatedUsage) {
          warnOfDeprecatedValueAssignment();
        }

        if (unescaped === this._value && quoteMark === this._quoteMark) {
          return;
        }

        this._value = unescaped;
        this._quoteMark = quoteMark;

        this._syncRawValue();
      } else {
        this._value = v;
      }
    }
  }, {
    key: "attribute",
    get: function get() {
      return this._attribute;
    },
    set: function set(name) {
      this._handleEscapes("attribute", name);

      this._attribute = name;
    }
  }]);

  return Attribute;
}(_namespace["default"]);

exports["default"] = Attribute;
Attribute.NO_QUOTE = null;
Attribute.SINGLE_QUOTE = "'";
Attribute.DOUBLE_QUOTE = '"';
var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
  "'": {
    quotes: 'single',
    wrap: true
  },
  '"': {
    quotes: 'double',
    wrap: true
  }
}, _CSSESC_QUOTE_OPTIONS[null] = {
  isIdentifier: true
}, _CSSESC_QUOTE_OPTIONS);

function defaultAttrConcat(attrValue, attrSpaces) {
  return "" + attrSpaces.before + attrValue + attrSpaces.after;
}

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/className.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/className.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _cssesc = _interopRequireDefault(__webpack_require__(/*! cssesc */ "./node_modules/cssesc/cssesc.js"));

var _util = __webpack_require__(/*! ../util */ "./node_modules/postcss-selector-parser/dist/util/index.js");

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ClassName = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ClassName, _Node);

  function ClassName(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.CLASS;
    _this._constructed = true;
    return _this;
  }

  var _proto = ClassName.prototype;

  _proto.valueToString = function valueToString() {
    return '.' + _Node.prototype.valueToString.call(this);
  };

  _createClass(ClassName, [{
    key: "value",
    get: function get() {
      return this._value;
    },
    set: function set(v) {
      if (this._constructed) {
        var escaped = (0, _cssesc["default"])(v, {
          isIdentifier: true
        });

        if (escaped !== v) {
          (0, _util.ensureObject)(this, "raws");
          this.raws.value = escaped;
        } else if (this.raws) {
          delete this.raws.value;
        }
      }

      this._value = v;
    }
  }]);

  return ClassName;
}(_node["default"]);

exports["default"] = ClassName;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/combinator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/combinator.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Combinator = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Combinator, _Node);

  function Combinator(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMBINATOR;
    return _this;
  }

  return Combinator;
}(_node["default"]);

exports["default"] = Combinator;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/comment.js":
/*!************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/comment.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Comment = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Comment, _Node);

  function Comment(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMMENT;
    return _this;
  }

  return Comment;
}(_node["default"]);

exports["default"] = Comment;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/constructors.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/constructors.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;

var _attribute = _interopRequireDefault(__webpack_require__(/*! ./attribute */ "./node_modules/postcss-selector-parser/dist/selectors/attribute.js"));

var _className = _interopRequireDefault(__webpack_require__(/*! ./className */ "./node_modules/postcss-selector-parser/dist/selectors/className.js"));

var _combinator = _interopRequireDefault(__webpack_require__(/*! ./combinator */ "./node_modules/postcss-selector-parser/dist/selectors/combinator.js"));

var _comment = _interopRequireDefault(__webpack_require__(/*! ./comment */ "./node_modules/postcss-selector-parser/dist/selectors/comment.js"));

var _id = _interopRequireDefault(__webpack_require__(/*! ./id */ "./node_modules/postcss-selector-parser/dist/selectors/id.js"));

var _nesting = _interopRequireDefault(__webpack_require__(/*! ./nesting */ "./node_modules/postcss-selector-parser/dist/selectors/nesting.js"));

var _pseudo = _interopRequireDefault(__webpack_require__(/*! ./pseudo */ "./node_modules/postcss-selector-parser/dist/selectors/pseudo.js"));

var _root = _interopRequireDefault(__webpack_require__(/*! ./root */ "./node_modules/postcss-selector-parser/dist/selectors/root.js"));

var _selector = _interopRequireDefault(__webpack_require__(/*! ./selector */ "./node_modules/postcss-selector-parser/dist/selectors/selector.js"));

var _string = _interopRequireDefault(__webpack_require__(/*! ./string */ "./node_modules/postcss-selector-parser/dist/selectors/string.js"));

var _tag = _interopRequireDefault(__webpack_require__(/*! ./tag */ "./node_modules/postcss-selector-parser/dist/selectors/tag.js"));

var _universal = _interopRequireDefault(__webpack_require__(/*! ./universal */ "./node_modules/postcss-selector-parser/dist/selectors/universal.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var attribute = function attribute(opts) {
  return new _attribute["default"](opts);
};

exports.attribute = attribute;

var className = function className(opts) {
  return new _className["default"](opts);
};

exports.className = className;

var combinator = function combinator(opts) {
  return new _combinator["default"](opts);
};

exports.combinator = combinator;

var comment = function comment(opts) {
  return new _comment["default"](opts);
};

exports.comment = comment;

var id = function id(opts) {
  return new _id["default"](opts);
};

exports.id = id;

var nesting = function nesting(opts) {
  return new _nesting["default"](opts);
};

exports.nesting = nesting;

var pseudo = function pseudo(opts) {
  return new _pseudo["default"](opts);
};

exports.pseudo = pseudo;

var root = function root(opts) {
  return new _root["default"](opts);
};

exports.root = root;

var selector = function selector(opts) {
  return new _selector["default"](opts);
};

exports.selector = selector;

var string = function string(opts) {
  return new _string["default"](opts);
};

exports.string = string;

var tag = function tag(opts) {
  return new _tag["default"](opts);
};

exports.tag = tag;

var universal = function universal(opts) {
  return new _universal["default"](opts);
};

exports.universal = universal;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/container.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/container.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var types = _interopRequireWildcard(__webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Container = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Container, _Node);

  function Container(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;

    if (!_this.nodes) {
      _this.nodes = [];
    }

    return _this;
  }

  var _proto = Container.prototype;

  _proto.append = function append(selector) {
    selector.parent = this;
    this.nodes.push(selector);
    return this;
  };

  _proto.prepend = function prepend(selector) {
    selector.parent = this;
    this.nodes.unshift(selector);
    return this;
  };

  _proto.at = function at(index) {
    return this.nodes[index];
  };

  _proto.index = function index(child) {
    if (typeof child === 'number') {
      return child;
    }

    return this.nodes.indexOf(child);
  };

  _proto.removeChild = function removeChild(child) {
    child = this.index(child);
    this.at(child).parent = undefined;
    this.nodes.splice(child, 1);
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  };

  _proto.removeAll = function removeAll() {
    for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
      var node = _step.value;
      node.parent = undefined;
    }

    this.nodes = [];
    return this;
  };

  _proto.empty = function empty() {
    return this.removeAll();
  };

  _proto.insertAfter = function insertAfter(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex + 1, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (oldIndex <= index) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto.insertBefore = function insertBefore(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index <= oldIndex) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
    var found = undefined;
    this.each(function (node) {
      if (node.atPosition) {
        var foundChild = node.atPosition(line, col);

        if (foundChild) {
          found = foundChild;
          return false;
        }
      } else if (node.isAtPosition(line, col)) {
        found = node;
        return false;
      }
    });
    return found;
  }
  /**
   * Return the most specific node at the line and column number given.
   * The source location is based on the original parsed location, locations aren't
   * updated as selector nodes are mutated.
   * 
   * Note that this location is relative to the location of the first character
   * of the selector, and not the location of the selector in the overall document
   * when used in conjunction with postcss.
   *
   * If not found, returns undefined.
   * @param {number} line The line number of the node to find. (1-based index)
   * @param {number} col  The column number of the node to find. (1-based index)
   */
  ;

  _proto.atPosition = function atPosition(line, col) {
    if (this.isAtPosition(line, col)) {
      return this._findChildAtPosition(line, col) || this;
    } else {
      return undefined;
    }
  };

  _proto._inferEndPosition = function _inferEndPosition() {
    if (this.last && this.last.source && this.last.source.end) {
      this.source = this.source || {};
      this.source.end = this.source.end || {};
      Object.assign(this.source.end, this.last.source.end);
    }
  };

  _proto.each = function each(callback) {
    if (!this.lastEach) {
      this.lastEach = 0;
    }

    if (!this.indexes) {
      this.indexes = {};
    }

    this.lastEach++;
    var id = this.lastEach;
    this.indexes[id] = 0;

    if (!this.length) {
      return undefined;
    }

    var index, result;

    while (this.indexes[id] < this.length) {
      index = this.indexes[id];
      result = callback(this.at(index), index);

      if (result === false) {
        break;
      }

      this.indexes[id] += 1;
    }

    delete this.indexes[id];

    if (result === false) {
      return false;
    }
  };

  _proto.walk = function walk(callback) {
    return this.each(function (node, i) {
      var result = callback(node, i);

      if (result !== false && node.length) {
        result = node.walk(callback);
      }

      if (result === false) {
        return false;
      }
    });
  };

  _proto.walkAttributes = function walkAttributes(callback) {
    var _this2 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ATTRIBUTE) {
        return callback.call(_this2, selector);
      }
    });
  };

  _proto.walkClasses = function walkClasses(callback) {
    var _this3 = this;

    return this.walk(function (selector) {
      if (selector.type === types.CLASS) {
        return callback.call(_this3, selector);
      }
    });
  };

  _proto.walkCombinators = function walkCombinators(callback) {
    var _this4 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMBINATOR) {
        return callback.call(_this4, selector);
      }
    });
  };

  _proto.walkComments = function walkComments(callback) {
    var _this5 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMMENT) {
        return callback.call(_this5, selector);
      }
    });
  };

  _proto.walkIds = function walkIds(callback) {
    var _this6 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ID) {
        return callback.call(_this6, selector);
      }
    });
  };

  _proto.walkNesting = function walkNesting(callback) {
    var _this7 = this;

    return this.walk(function (selector) {
      if (selector.type === types.NESTING) {
        return callback.call(_this7, selector);
      }
    });
  };

  _proto.walkPseudos = function walkPseudos(callback) {
    var _this8 = this;

    return this.walk(function (selector) {
      if (selector.type === types.PSEUDO) {
        return callback.call(_this8, selector);
      }
    });
  };

  _proto.walkTags = function walkTags(callback) {
    var _this9 = this;

    return this.walk(function (selector) {
      if (selector.type === types.TAG) {
        return callback.call(_this9, selector);
      }
    });
  };

  _proto.walkUniversals = function walkUniversals(callback) {
    var _this10 = this;

    return this.walk(function (selector) {
      if (selector.type === types.UNIVERSAL) {
        return callback.call(_this10, selector);
      }
    });
  };

  _proto.split = function split(callback) {
    var _this11 = this;

    var current = [];
    return this.reduce(function (memo, node, index) {
      var split = callback.call(_this11, node);
      current.push(node);

      if (split) {
        memo.push(current);
        current = [];
      } else if (index === _this11.length - 1) {
        memo.push(current);
      }

      return memo;
    }, []);
  };

  _proto.map = function map(callback) {
    return this.nodes.map(callback);
  };

  _proto.reduce = function reduce(callback, memo) {
    return this.nodes.reduce(callback, memo);
  };

  _proto.every = function every(callback) {
    return this.nodes.every(callback);
  };

  _proto.some = function some(callback) {
    return this.nodes.some(callback);
  };

  _proto.filter = function filter(callback) {
    return this.nodes.filter(callback);
  };

  _proto.sort = function sort(callback) {
    return this.nodes.sort(callback);
  };

  _proto.toString = function toString() {
    return this.map(String).join('');
  };

  _createClass(Container, [{
    key: "first",
    get: function get() {
      return this.at(0);
    }
  }, {
    key: "last",
    get: function get() {
      return this.at(this.length - 1);
    }
  }, {
    key: "length",
    get: function get() {
      return this.nodes.length;
    }
  }]);

  return Container;
}(_node["default"]);

exports["default"] = Container;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/guards.js":
/*!***********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/guards.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.isNode = isNode;
exports.isPseudoElement = isPseudoElement;
exports.isPseudoClass = isPseudoClass;
exports.isContainer = isContainer;
exports.isNamespace = isNamespace;
exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

var _IS_TYPE;

var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

function isNode(node) {
  return typeof node === "object" && IS_TYPE[node.type];
}

function isNodeType(type, node) {
  return isNode(node) && node.type === type;
}

var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
exports.isAttribute = isAttribute;
var isClassName = isNodeType.bind(null, _types.CLASS);
exports.isClassName = isClassName;
var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
exports.isCombinator = isCombinator;
var isComment = isNodeType.bind(null, _types.COMMENT);
exports.isComment = isComment;
var isIdentifier = isNodeType.bind(null, _types.ID);
exports.isIdentifier = isIdentifier;
var isNesting = isNodeType.bind(null, _types.NESTING);
exports.isNesting = isNesting;
var isPseudo = isNodeType.bind(null, _types.PSEUDO);
exports.isPseudo = isPseudo;
var isRoot = isNodeType.bind(null, _types.ROOT);
exports.isRoot = isRoot;
var isSelector = isNodeType.bind(null, _types.SELECTOR);
exports.isSelector = isSelector;
var isString = isNodeType.bind(null, _types.STRING);
exports.isString = isString;
var isTag = isNodeType.bind(null, _types.TAG);
exports.isTag = isTag;
var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
exports.isUniversal = isUniversal;

function isPseudoElement(node) {
  return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
}

function isPseudoClass(node) {
  return isPseudo(node) && !isPseudoElement(node);
}

function isContainer(node) {
  return !!(isNode(node) && node.walk);
}

function isNamespace(node) {
  return isAttribute(node) || isTag(node);
}

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/id.js":
/*!*******************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/id.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ID = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ID, _Node);

  function ID(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.ID;
    return _this;
  }

  var _proto = ID.prototype;

  _proto.valueToString = function valueToString() {
    return '#' + _Node.prototype.valueToString.call(this);
  };

  return ID;
}(_node["default"]);

exports["default"] = ID;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _types[key]) return;
  exports[key] = _types[key];
});

var _constructors = __webpack_require__(/*! ./constructors */ "./node_modules/postcss-selector-parser/dist/selectors/constructors.js");

Object.keys(_constructors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constructors[key]) return;
  exports[key] = _constructors[key];
});

var _guards = __webpack_require__(/*! ./guards */ "./node_modules/postcss-selector-parser/dist/selectors/guards.js");

Object.keys(_guards).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _guards[key]) return;
  exports[key] = _guards[key];
});

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/namespace.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/namespace.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _cssesc = _interopRequireDefault(__webpack_require__(/*! cssesc */ "./node_modules/cssesc/cssesc.js"));

var _util = __webpack_require__(/*! ../util */ "./node_modules/postcss-selector-parser/dist/util/index.js");

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Namespace = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Namespace, _Node);

  function Namespace() {
    return _Node.apply(this, arguments) || this;
  }

  var _proto = Namespace.prototype;

  _proto.qualifiedName = function qualifiedName(value) {
    if (this.namespace) {
      return this.namespaceString + "|" + value;
    } else {
      return value;
    }
  };

  _proto.valueToString = function valueToString() {
    return this.qualifiedName(_Node.prototype.valueToString.call(this));
  };

  _createClass(Namespace, [{
    key: "namespace",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      if (namespace === true || namespace === "*" || namespace === "&") {
        this._namespace = namespace;

        if (this.raws) {
          delete this.raws.namespace;
        }

        return;
      }

      var escaped = (0, _cssesc["default"])(namespace, {
        isIdentifier: true
      });
      this._namespace = namespace;

      if (escaped !== namespace) {
        (0, _util.ensureObject)(this, "raws");
        this.raws.namespace = escaped;
      } else if (this.raws) {
        delete this.raws.namespace;
      }
    }
  }, {
    key: "ns",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      this.namespace = namespace;
    }
  }, {
    key: "namespaceString",
    get: function get() {
      if (this.namespace) {
        var ns = this.stringifyProperty("namespace");

        if (ns === true) {
          return '';
        } else {
          return ns;
        }
      } else {
        return '';
      }
    }
  }]);

  return Namespace;
}(_node["default"]);

exports["default"] = Namespace;
;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/nesting.js":
/*!************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/nesting.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Nesting = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Nesting, _Node);

  function Nesting(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.NESTING;
    _this.value = '&';
    return _this;
  }

  return Nesting;
}(_node["default"]);

exports["default"] = Nesting;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/node.js":
/*!*********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/node.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _util = __webpack_require__(/*! ../util */ "./node_modules/postcss-selector-parser/dist/util/index.js");

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var cloneNode = function cloneNode(obj, parent) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) {
      continue;
    }

    var value = obj[i];
    var type = typeof value;

    if (i === 'parent' && type === 'object') {
      if (parent) {
        cloned[i] = parent;
      }
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      cloned[i] = cloneNode(value, cloned);
    }
  }

  return cloned;
};

var Node = /*#__PURE__*/function () {
  function Node(opts) {
    if (opts === void 0) {
      opts = {};
    }

    Object.assign(this, opts);
    this.spaces = this.spaces || {};
    this.spaces.before = this.spaces.before || '';
    this.spaces.after = this.spaces.after || '';
  }

  var _proto = Node.prototype;

  _proto.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    this.parent = undefined;
    return this;
  };

  _proto.replaceWith = function replaceWith() {
    if (this.parent) {
      for (var index in arguments) {
        this.parent.insertBefore(this, arguments[index]);
      }

      this.remove();
    }

    return this;
  };

  _proto.next = function next() {
    return this.parent.at(this.parent.index(this) + 1);
  };

  _proto.prev = function prev() {
    return this.parent.at(this.parent.index(this) - 1);
  };

  _proto.clone = function clone(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = cloneNode(this);

    for (var name in overrides) {
      cloned[name] = overrides[name];
    }

    return cloned;
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows non standard syntax to be appended to an existing property
   * by specifying the escaped value. By specifying the escaped value,
   * illegal characters are allowed to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped optional. the escaped value of the property.
   */
  ;

  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    var originalValue = this[name];
    var originalEscaped = this.raws[name];
    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

    if (originalEscaped || valueEscaped !== value) {
      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
    } else {
      delete this.raws[name]; // delete any escaped value that was created by the setter.
    }
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows the escaped value to be specified directly, allowing illegal
   * characters to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped the escaped value of the property.
   */
  ;

  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    this.raws[name] = valueEscaped;
  }
  /**
   * When you want a value to passed through to CSS directly. This method
   * deletes the corresponding raw value causing the stringifier to fallback
   * to the unescaped value.
   * @param {string} name the property to set.
   * @param {any} value The value that is both escaped and unescaped.
   */
  ;

  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    if (this.raws) {
      delete this.raws[name];
    }
  }
  /**
   *
   * @param {number} line The number (starting with 1)
   * @param {number} column The column number (starting with 1)
   */
  ;

  _proto.isAtPosition = function isAtPosition(line, column) {
    if (this.source && this.source.start && this.source.end) {
      if (this.source.start.line > line) {
        return false;
      }

      if (this.source.end.line < line) {
        return false;
      }

      if (this.source.start.line === line && this.source.start.column > column) {
        return false;
      }

      if (this.source.end.line === line && this.source.end.column < column) {
        return false;
      }

      return true;
    }

    return undefined;
  };

  _proto.stringifyProperty = function stringifyProperty(name) {
    return this.raws && this.raws[name] || this[name];
  };

  _proto.valueToString = function valueToString() {
    return String(this.stringifyProperty("value"));
  };

  _proto.toString = function toString() {
    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
  };

  _createClass(Node, [{
    key: "rawSpaceBefore",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

      if (rawSpace === undefined) {
        rawSpace = this.spaces && this.spaces.before;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.before = raw;
    }
  }, {
    key: "rawSpaceAfter",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

      if (rawSpace === undefined) {
        rawSpace = this.spaces.after;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.after = raw;
    }
  }]);

  return Node;
}();

exports["default"] = Node;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/pseudo.js":
/*!***********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/pseudo.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _container = _interopRequireDefault(__webpack_require__(/*! ./container */ "./node_modules/postcss-selector-parser/dist/selectors/container.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Pseudo = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Pseudo, _Container);

  function Pseudo(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.PSEUDO;
    return _this;
  }

  var _proto = Pseudo.prototype;

  _proto.toString = function toString() {
    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
    return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
  };

  return Pseudo;
}(_container["default"]);

exports["default"] = Pseudo;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/root.js":
/*!*********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/root.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _container = _interopRequireDefault(__webpack_require__(/*! ./container */ "./node_modules/postcss-selector-parser/dist/selectors/container.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Root = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Root, _Container);

  function Root(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.ROOT;
    return _this;
  }

  var _proto = Root.prototype;

  _proto.toString = function toString() {
    var str = this.reduce(function (memo, selector) {
      memo.push(String(selector));
      return memo;
    }, []).join(',');
    return this.trailingComma ? str + ',' : str;
  };

  _proto.error = function error(message, options) {
    if (this._error) {
      return this._error(message, options);
    } else {
      return new Error(message);
    }
  };

  _createClass(Root, [{
    key: "errorGenerator",
    set: function set(handler) {
      this._error = handler;
    }
  }]);

  return Root;
}(_container["default"]);

exports["default"] = Root;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/selector.js":
/*!*************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/selector.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _container = _interopRequireDefault(__webpack_require__(/*! ./container */ "./node_modules/postcss-selector-parser/dist/selectors/container.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Selector = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Selector, _Container);

  function Selector(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.SELECTOR;
    return _this;
  }

  return Selector;
}(_container["default"]);

exports["default"] = Selector;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/string.js":
/*!***********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/string.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var String = /*#__PURE__*/function (_Node) {
  _inheritsLoose(String, _Node);

  function String(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.STRING;
    return _this;
  }

  return String;
}(_node["default"]);

exports["default"] = String;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/tag.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _namespace = _interopRequireDefault(__webpack_require__(/*! ./namespace */ "./node_modules/postcss-selector-parser/dist/selectors/namespace.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Tag = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Tag, _Namespace);

  function Tag(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.TAG;
    return _this;
  }

  return Tag;
}(_namespace["default"]);

exports["default"] = Tag;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/types.js":
/*!**********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/types.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
var TAG = 'tag';
exports.TAG = TAG;
var STRING = 'string';
exports.STRING = STRING;
var SELECTOR = 'selector';
exports.SELECTOR = SELECTOR;
var ROOT = 'root';
exports.ROOT = ROOT;
var PSEUDO = 'pseudo';
exports.PSEUDO = PSEUDO;
var NESTING = 'nesting';
exports.NESTING = NESTING;
var ID = 'id';
exports.ID = ID;
var COMMENT = 'comment';
exports.COMMENT = COMMENT;
var COMBINATOR = 'combinator';
exports.COMBINATOR = COMBINATOR;
var CLASS = 'class';
exports.CLASS = CLASS;
var ATTRIBUTE = 'attribute';
exports.ATTRIBUTE = ATTRIBUTE;
var UNIVERSAL = 'universal';
exports.UNIVERSAL = UNIVERSAL;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/universal.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/universal.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _namespace = _interopRequireDefault(__webpack_require__(/*! ./namespace */ "./node_modules/postcss-selector-parser/dist/selectors/namespace.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Universal = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Universal, _Namespace);

  function Universal(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.UNIVERSAL;
    _this.value = '*';
    return _this;
  }

  return Universal;
}(_namespace["default"]);

exports["default"] = Universal;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/sortAscending.js":
/*!********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/sortAscending.js ***!
  \********************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = sortAscending;

function sortAscending(list) {
  return list.sort(function (a, b) {
    return a - b;
  });
}

;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/tokenTypes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/tokenTypes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
var ampersand = 38; // `&`.charCodeAt(0);

exports.ampersand = ampersand;
var asterisk = 42; // `*`.charCodeAt(0);

exports.asterisk = asterisk;
var at = 64; // `@`.charCodeAt(0);

exports.at = at;
var comma = 44; // `,`.charCodeAt(0);

exports.comma = comma;
var colon = 58; // `:`.charCodeAt(0);

exports.colon = colon;
var semicolon = 59; // `;`.charCodeAt(0);

exports.semicolon = semicolon;
var openParenthesis = 40; // `(`.charCodeAt(0);

exports.openParenthesis = openParenthesis;
var closeParenthesis = 41; // `)`.charCodeAt(0);

exports.closeParenthesis = closeParenthesis;
var openSquare = 91; // `[`.charCodeAt(0);

exports.openSquare = openSquare;
var closeSquare = 93; // `]`.charCodeAt(0);

exports.closeSquare = closeSquare;
var dollar = 36; // `$`.charCodeAt(0);

exports.dollar = dollar;
var tilde = 126; // `~`.charCodeAt(0);

exports.tilde = tilde;
var caret = 94; // `^`.charCodeAt(0);

exports.caret = caret;
var plus = 43; // `+`.charCodeAt(0);

exports.plus = plus;
var equals = 61; // `=`.charCodeAt(0);

exports.equals = equals;
var pipe = 124; // `|`.charCodeAt(0);

exports.pipe = pipe;
var greaterThan = 62; // `>`.charCodeAt(0);

exports.greaterThan = greaterThan;
var space = 32; // ` `.charCodeAt(0);

exports.space = space;
var singleQuote = 39; // `'`.charCodeAt(0);

exports.singleQuote = singleQuote;
var doubleQuote = 34; // `"`.charCodeAt(0);

exports.doubleQuote = doubleQuote;
var slash = 47; // `/`.charCodeAt(0);

exports.slash = slash;
var bang = 33; // `!`.charCodeAt(0);

exports.bang = bang;
var backslash = 92; // '\\'.charCodeAt(0);

exports.backslash = backslash;
var cr = 13; // '\r'.charCodeAt(0);

exports.cr = cr;
var feed = 12; // '\f'.charCodeAt(0);

exports.feed = feed;
var newline = 10; // '\n'.charCodeAt(0);

exports.newline = newline;
var tab = 9; // '\t'.charCodeAt(0);
// Expose aliases primarily for readability.

exports.tab = tab;
var str = singleQuote; // No good single character representation!

exports.str = str;
var comment = -1;
exports.comment = comment;
var word = -2;
exports.word = word;
var combinator = -3;
exports.combinator = combinator;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/tokenize.js":
/*!***************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/tokenize.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = tokenize;
exports.FIELDS = void 0;

var t = _interopRequireWildcard(__webpack_require__(/*! ./tokenTypes */ "./node_modules/postcss-selector-parser/dist/tokenTypes.js"));

var _unescapable, _wordDelimiters;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
var hex = {};
var hexChars = "0123456789abcdefABCDEF";

for (var i = 0; i < hexChars.length; i++) {
  hex[hexChars.charCodeAt(i)] = true;
}
/**
 *  Returns the last index of the bar css word
 * @param {string} css The string in which the word begins
 * @param {number} start The index into the string where word's first letter occurs
 */


function consumeWord(css, start) {
  var next = start;
  var code;

  do {
    code = css.charCodeAt(next);

    if (wordDelimiters[code]) {
      return next - 1;
    } else if (code === t.backslash) {
      next = consumeEscape(css, next) + 1;
    } else {
      // All other characters are part of the word
      next++;
    }
  } while (next < css.length);

  return next - 1;
}
/**
 *  Returns the last index of the escape sequence
 * @param {string} css The string in which the sequence begins
 * @param {number} start The index into the string where escape character (`\`) occurs.
 */


function consumeEscape(css, start) {
  var next = start;
  var code = css.charCodeAt(next + 1);

  if (unescapable[code]) {// just consume the escape char
  } else if (hex[code]) {
    var hexDigits = 0; // consume up to 6 hex chars

    do {
      next++;
      hexDigits++;
      code = css.charCodeAt(next + 1);
    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


    if (hexDigits < 6 && code === t.space) {
      next++;
    }
  } else {
    // the next char is part of the current word
    next++;
  }

  return next;
}

var FIELDS = {
  TYPE: 0,
  START_LINE: 1,
  START_COL: 2,
  END_LINE: 3,
  END_COL: 4,
  START_POS: 5,
  END_POS: 6
};
exports.FIELDS = FIELDS;

function tokenize(input) {
  var tokens = [];
  var css = input.css.valueOf();
  var _css = css,
      length = _css.length;
  var offset = -1;
  var line = 1;
  var start = 0;
  var end = 0;
  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

  function unclosed(what, fix) {
    if (input.safe) {
      // fyi: this is never set to true.
      css += fix;
      next = css.length - 1;
    } else {
      throw input.error('Unclosed ' + what, line, start - offset, start);
    }
  }

  while (start < length) {
    code = css.charCodeAt(start);

    if (code === t.newline) {
      offset = start;
      line += 1;
    }

    switch (code) {
      case t.space:
      case t.tab:
      case t.newline:
      case t.cr:
      case t.feed:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);

          if (code === t.newline) {
            offset = next;
            line += 1;
          }
        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

        tokenType = t.space;
        endLine = line;
        endColumn = next - offset - 1;
        end = next;
        break;

      case t.plus:
      case t.greaterThan:
      case t.tilde:
      case t.pipe:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

        tokenType = t.combinator;
        endLine = line;
        endColumn = start - offset;
        end = next;
        break;
      // Consume these characters as single tokens.

      case t.asterisk:
      case t.ampersand:
      case t.bang:
      case t.comma:
      case t.equals:
      case t.dollar:
      case t.caret:
      case t.openSquare:
      case t.closeSquare:
      case t.colon:
      case t.semicolon:
      case t.openParenthesis:
      case t.closeParenthesis:
        next = start;
        tokenType = code;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      case t.singleQuote:
      case t.doubleQuote:
        quote = code === t.singleQuote ? "'" : '"';
        next = start;

        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) {
            unclosed('quote', quote);
          }

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === t.backslash) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        tokenType = t.str;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      default:
        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
          next = css.indexOf('*/', start + 2) + 1;

          if (next === 0) {
            unclosed('comment', '*/');
          }

          content = css.slice(start, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          tokenType = t.comment;
          line = nextLine;
          endLine = nextLine;
          endColumn = next - nextOffset;
        } else if (code === t.slash) {
          next = start;
          tokenType = code;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
        } else {
          next = consumeWord(css, start);
          tokenType = t.word;
          endLine = line;
          endColumn = next - offset;
        }

        end = next + 1;
        break;
    } // Ensure that the token structure remains consistent


    tokens.push([tokenType, // [0] Token type
    line, // [1] Starting line
    start - offset, // [2] Starting column
    endLine, // [3] Ending line
    endColumn, // [4] Ending column
    start, // [5] Start position / Source index
    end // [6] End position
    ]); // Reset offset for the next token

    if (nextOffset) {
      offset = nextOffset;
      nextOffset = null;
    }

    start = end;
  }

  return tokens;
}

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/ensureObject.js":
/*!************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/ensureObject.js ***!
  \************************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = ensureObject;

function ensureObject(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      obj[prop] = {};
    }

    obj = obj[prop];
  }
}

module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/getProp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/getProp.js ***!
  \*******************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = getProp;

function getProp(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      return undefined;
    }

    obj = obj[prop];
  }

  return obj;
}

module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;

var _unesc = _interopRequireDefault(__webpack_require__(/*! ./unesc */ "./node_modules/postcss-selector-parser/dist/util/unesc.js"));

exports.unesc = _unesc["default"];

var _getProp = _interopRequireDefault(__webpack_require__(/*! ./getProp */ "./node_modules/postcss-selector-parser/dist/util/getProp.js"));

exports.getProp = _getProp["default"];

var _ensureObject = _interopRequireDefault(__webpack_require__(/*! ./ensureObject */ "./node_modules/postcss-selector-parser/dist/util/ensureObject.js"));

exports.ensureObject = _ensureObject["default"];

var _stripComments = _interopRequireDefault(__webpack_require__(/*! ./stripComments */ "./node_modules/postcss-selector-parser/dist/util/stripComments.js"));

exports.stripComments = _stripComments["default"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/stripComments.js":
/*!*************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/stripComments.js ***!
  \*************************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = stripComments;

function stripComments(str) {
  var s = "";
  var commentStart = str.indexOf("/*");
  var lastEnd = 0;

  while (commentStart >= 0) {
    s = s + str.slice(lastEnd, commentStart);
    var commentEnd = str.indexOf("*/", commentStart + 2);

    if (commentEnd < 0) {
      return s;
    }

    lastEnd = commentEnd + 2;
    commentStart = str.indexOf("/*", lastEnd);
  }

  s = s + str.slice(lastEnd);
  return s;
}

module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/unesc.js":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/unesc.js ***!
  \*****************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = unesc;

// Many thanks for this post which made this migration much easier.
// https://mathiasbynens.be/notes/css-escapes

/**
 * 
 * @param {string} str 
 * @returns {[string, number]|undefined}
 */
function gobbleHex(str) {
  var lower = str.toLowerCase();
  var hex = '';
  var spaceTerminated = false;

  for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
    var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]

    var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point

    spaceTerminated = code === 32;

    if (!valid) {
      break;
    }

    hex += lower[i];
  }

  if (hex.length === 0) {
    return undefined;
  }

  var codePoint = parseInt(hex, 16);
  var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for
  // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
  // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point

  if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
    return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
  }

  return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
}

var CONTAINS_ESCAPE = /\\/;

function unesc(str) {
  var needToProcess = CONTAINS_ESCAPE.test(str);

  if (!needToProcess) {
    return str;
  }

  var ret = "";

  for (var i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      var gobbled = gobbleHex(str.slice(i + 1, i + 7));

      if (gobbled !== undefined) {
        ret += gobbled[0];
        i += gobbled[1];
        continue;
      } // Retain a pair of \\ if double escaped `\\\\`
      // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e


      if (str[i + 1] === "\\") {
        ret += "\\";
        i++;
        continue;
      } // if \\ is at the end of the string retain it
      // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb


      if (str.length === i + 1) {
        ret += str[i];
      }

      continue;
    }

    ret += str[i];
  }

  return ret;
}

module.exports = exports.default;

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./src/style.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ "./src/contact.js":
/*!************************!*\
  !*** ./src/contact.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

let contact = document.createElement('div');
contact.textContent = "Contact";
contact.classList.add('header-button');

let screen = document.querySelector('#middle-window');



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (contact);

/***/ }),

/***/ "./src/home.js":
/*!*********************!*\
  !*** ./src/home.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

let screen = document.querySelector('#middle-window');

let home = document.createElement('div');
home.textContent = 'Home';
home.classList.add('header-button');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (home);


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _home_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./home.js */ "./src/home.js");
/* harmony import */ var _menu_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./menu.js */ "./src/menu.js");
/* harmony import */ var _contact_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contact.js */ "./src/contact.js");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style.css */ "./src/style.css");
/* harmony import */ var postcss_selector_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! postcss-selector-parser */ "./node_modules/postcss-selector-parser/dist/index.js");
/* harmony import */ var postcss_selector_parser__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(postcss_selector_parser__WEBPACK_IMPORTED_MODULE_4__);







let content = document.createElement('div');
content.setAttribute('id','content');

let title = document.createElement('div');
title.setAttribute('id','title');
title.textContent = "Twisted Cones";
content.appendChild(title);

let header = document.createElement('div');
header.setAttribute('id','header');
header.appendChild(_home_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
header.appendChild(_menu_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
header.appendChild(_contact_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

content.appendChild(header);

let middle = document.createElement('div');
middle.setAttribute('id','middle');
let screen = document.createElement('div');
write_home();
screen.setAttribute('id','middle-window');
middle.appendChild(screen);
content.appendChild(middle);

_home_js__WEBPACK_IMPORTED_MODULE_0__["default"].addEventListener('click',write_home);

function write_home(){
    screen.innerHTML = '';
    screen.style.cssText = "dispay:flex; flex-direction:column; box-sizing:border-box; padding:50px; ";
    let text1 = document.createElement('h1');
    text1.setAttribute('id', 'text1');
    text1.textContent = "The best Ice Cream chain around.";

    let text2 = document.createElement('h3');
    text2.setAttribute('id', 'text2');
    text2.textContent = "Ice Creams are personal. So create your own flavour and make your cone your own. The possibilites are limitless.";


    screen.appendChild(text1);
    screen.appendChild(text2);

}

_menu_js__WEBPACK_IMPORTED_MODULE_1__["default"].addEventListener('click', write_menu)

function write_menu(){
    screen.innerHTML = '';
    screen.style.cssText = "display: grid; box-sizing: border-box; grid-template: 1fr 1fr/ 1fr 1fr; gap:20px; padding:40px;";

    let card1 = document.createElement('div');
    card1.classList.add('card');
    card1.textContent = "Chocolate";
    card1.style.backgroundColor = "brown";
    card1.style.color = 'white';

    let card2 = document.createElement('div');
    card2.classList.add('card');
    card2.textContent = "Strawberry";
    card2.style.backgroundColor = "pink";
    card2.style.color = 'black';

    let card3 = document.createElement('div');
    card3.classList.add('card');
    card3.textContent = "Pista";
    card3.style.backgroundColor = "lightgreen";
    card3.style.color = 'black';

    let card4 = document.createElement('div');
    card4.classList.add('card');
    card4.textContent = "Black Currant";
    card4.style.backgroundColor = "gray";
    card4.style.color = 'white';

    screen.appendChild(card1);
    screen.appendChild(card2);
    screen.appendChild(card3);
    screen.appendChild(card4);

}

_contact_js__WEBPACK_IMPORTED_MODULE_2__["default"].addEventListener('click', write_contact)

function write_contact(){
    screen.innerHTML = '';
    screen.style.cssText = "";

    let c1 = document.createElement('div');
    let p11 = document.createElement('p');
    p11.textContent = "Rocky Bhai"
    p11.style.fontSize = "30px";

    let p12 = document.createElement('p');
    p12.textContent = "CEO of India";

    let p13 = document.createElement('p');
    p13.textContent = "rockyash@narachi.co.in";
    c1.appendChild(p11);
    c1.appendChild(p12);
    c1.appendChild(p13);

    screen.appendChild(c1);

    
eateElement('div');
    


}

document.body.appendChild(content);


/***/ }),

/***/ "./src/menu.js":
/*!*********************!*\
  !*** ./src/menu.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
let screen = document.querySelector('#middle-window');

let menu = document.createElement('div');
menu.textContent = "Menu";
menu.classList.add('header-button');



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (menu);

/***/ }),

/***/ "./src/icon.svg":
/*!**********************!*\
  !*** ./src/icon.svg ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "8b0f4e372776bc043f35.svg";

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/index.js"));
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU0sb0VBQW9FO0FBQzFFLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7OztBQUd2QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFD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RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkUsNEJBQTRCO0FBQ3pHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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bkI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsSUFBSTtBQUNKLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9DQUFvQzs7O0FBRzFDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FB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QSx5Q0FBeUMsdUJBQXVCLHVCQUF1QixjQUFjO0FBQ3JHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQXFCOztBQUVyQjtBQUNBO0FBQ0EsMkNBQTJDLHdCQUF3QixpQ0FBaUMsVUFBVSxhQUFhOztBQUUzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9FQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDcEhBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vc3JjL3N0eWxlLmNzcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9jc3Nlc2MvY3NzZXNjLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3QvcGFyc2VyLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9wcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy9hdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy9jbGFzc05hbWUuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy9jb21iaW5hdG9yLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvY29tbWVudC5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL2NvbnN0cnVjdG9ycy5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL2NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL2d1YXJkcy5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL2lkLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy9uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy9uZXN0aW5nLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvbm9kZS5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL3BzZXVkby5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL3Jvb3QuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy9zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL3RhZy5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL3R5cGVzLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvdW5pdmVyc2FsLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zb3J0QXNjZW5kaW5nLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC90b2tlblR5cGVzLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC90b2tlbml6ZS5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3QvdXRpbC9lbnN1cmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3V0aWwvZ2V0UHJvcC5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3QvdXRpbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3QvdXRpbC9zdHJpcENvbW1lbnRzLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC91dGlsL3VuZXNjLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9zcmMvc3R5bGUuY3NzPzcxNjMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL3NyYy9jb250YWN0LmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9zcmMvaG9tZS5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9zcmMvbWVudS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSBuZXcgVVJMKFwiaWNvbi5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJAaW1wb3J0IHVybChodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PUxvYnN0ZXImZGlzcGxheT1zd2FwKTtcIl0pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIip7XFxuICAgIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuYm9keXtcXG4gICAgbWFyZ2luOiAwO1xcbn1cXG5cXG4jdGl0bGV7XFxuICAgIFxcbiAgICBoZWlnaHQ6IDEwdmg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGZvbnQtc2l6ZTogNDBweDtcXG4gICAgZm9udC1mYW1pbHk6ICdMb2JzdGVyJywgc2Fucy1zZXJpZjtcXG4gICAgY29sb3I6IHJnYigwLCAwLCAwKTtcXG59XFxuXFxuXFxuI2hlYWRlcntcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgaGVpZ2h0OiAxMHZoO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZ2FwOjMwcHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTcsIDEyMCwgMjE2LCAwLjY5Mik7XFxuICAgIGZvbnQtZmFtaWx5OiAnSm9zZWZpbiBTYW5zJywgc2Fucy1zZXJpZjtcXG4gICAgZm9udC1zaXplOiAyNXB4O1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbn1cXG5cXG4jbWlkZGxle1xcbiAgICBkaXNwbGF5OmZsZXg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYig4OCwgODMsIDMzKTtcXG4gICAgaGVpZ2h0OiA5MHZoO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyArIFwiKTtcXG4gICAgZm9udC1mYW1pbHk6ICdKb3NlZmluIFNhbnMnLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG4jbWlkZGxlLXdpbmRvd3tcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xcbiAgICBjb2xvcjp3aGl0ZTtcXG4gICAgaGVpZ2h0OiA3MCU7XFxuICAgIHdpZHRoOiA1MCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbn1cXG5cXG4uaGVhZGVyLWJ1dHRvbntcXG4gICAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAvKiBiYWNrZ3JvdW5kLWNvbG9yOiB0dXJxdW9pc2U7ICovXFxuICAgIGhlaWdodDogNTBweDtcXG4gICAgd2lkdGg6IDE1MHB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG5cXG59XFxuXFxuLmhlYWRlci1idXR0b246aG92ZXJ7XFxuICAgIGJvcmRlci1ib3R0b206IDNweCBzb2xpZCB3aGl0ZTtcXG59XFxuXFxuLmNhcmR7XFxuICAgIGhlaWdodDoxMDAlO1xcbiAgICB3aWR0aDoxMDAlO1xcbiAgICBkaXNwbGF5OiBmbGV4OyAgICBcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgIGZvbnQtc2l6ZTogMjBweDtcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFFQTtJQUNJLHdCQUF3QjtBQUM1Qjs7QUFFQTtJQUNJLFNBQVM7QUFDYjs7QUFFQTs7SUFFSSxZQUFZO0lBQ1osMENBQTBDO0lBQzFDLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLGVBQWU7SUFDZixrQ0FBa0M7SUFDbEMsbUJBQW1CO0FBQ3ZCOzs7QUFHQTtJQUNJLGFBQWE7SUFDYixZQUFZO0lBQ1osdUJBQXVCO0lBQ3ZCLG1CQUFtQjtJQUNuQixRQUFRO0lBQ1IsMkNBQTJDO0lBQzNDLHVDQUF1QztJQUN2QyxlQUFlO0lBQ2YsZ0JBQWdCO0FBQ3BCOztBQUVBO0lBQ0ksWUFBWTtJQUNaLGlDQUFpQztJQUNqQyxZQUFZO0lBQ1osdUJBQXVCO0lBQ3ZCLG1CQUFtQjtJQUNuQixtREFBMkI7SUFDM0IsdUNBQXVDO0FBQzNDOztBQUVBO0lBQ0ksb0NBQW9DO0lBQ3BDLFdBQVc7SUFDWCxXQUFXO0lBQ1gsVUFBVTtJQUNWLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLHdCQUF3QjtJQUN4QixpQ0FBaUM7SUFDakMsWUFBWTtJQUNaLFlBQVk7SUFDWixhQUFhO0lBQ2IsdUJBQXVCO0lBQ3ZCLG1CQUFtQjs7QUFFdkI7O0FBRUE7SUFDSSw4QkFBOEI7QUFDbEM7O0FBRUE7SUFDSSxXQUFXO0lBQ1gsVUFBVTtJQUNWLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixlQUFlO0FBQ25CXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBpbXBvcnQgdXJsKCdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PUxvYnN0ZXImZGlzcGxheT1zd2FwJyk7XFxuXFxuKntcXG4gICAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG5ib2R5e1xcbiAgICBtYXJnaW46IDA7XFxufVxcblxcbiN0aXRsZXtcXG4gICAgXFxuICAgIGhlaWdodDogMTB2aDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZm9udC1zaXplOiA0MHB4O1xcbiAgICBmb250LWZhbWlseTogJ0xvYnN0ZXInLCBzYW5zLXNlcmlmO1xcbiAgICBjb2xvcjogcmdiKDAsIDAsIDApO1xcbn1cXG5cXG5cXG4jaGVhZGVye1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBoZWlnaHQ6IDEwdmg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBnYXA6MzBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNywgMTIwLCAyMTYsIDAuNjkyKTtcXG4gICAgZm9udC1mYW1pbHk6ICdKb3NlZmluIFNhbnMnLCBzYW5zLXNlcmlmO1xcbiAgICBmb250LXNpemU6IDI1cHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxufVxcblxcbiNtaWRkbGV7XFxuICAgIGRpc3BsYXk6ZmxleDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDg4LCA4MywgMzMpO1xcbiAgICBoZWlnaHQ6IDkwdmg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoJ2ljb24uc3ZnJyk7XFxuICAgIGZvbnQtZmFtaWx5OiAnSm9zZWZpbiBTYW5zJywgc2Fucy1zZXJpZjtcXG59XFxuXFxuI21pZGRsZS13aW5kb3d7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcXG4gICAgY29sb3I6d2hpdGU7XFxuICAgIGhlaWdodDogNzAlO1xcbiAgICB3aWR0aDogNTAlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG59XFxuXFxuLmhlYWRlci1idXR0b257XFxuICAgIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgLyogYmFja2dyb3VuZC1jb2xvcjogdHVycXVvaXNlOyAqL1xcbiAgICBoZWlnaHQ6IDUwcHg7XFxuICAgIHdpZHRoOiAxNTBweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuXFxufVxcblxcbi5oZWFkZXItYnV0dG9uOmhvdmVye1xcbiAgICBib3JkZXItYm90dG9tOiAzcHggc29saWQgd2hpdGU7XFxufVxcblxcbi5jYXJke1xcbiAgICBoZWlnaHQ6MTAwJTtcXG4gICAgd2lkdGg6MTAwJTtcXG4gICAgZGlzcGxheTogZmxleDsgICAgXFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgICBmb250LXNpemU6IDIwcHg7XFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoIXVybCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB1cmwgPSBTdHJpbmcodXJsLl9fZXNNb2R1bGUgPyB1cmwuZGVmYXVsdCA6IHVybCk7IC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuXG4gIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgdXJsICs9IG9wdGlvbnMuaGFzaDtcbiAgfSAvLyBTaG91bGQgdXJsIGJlIHdyYXBwZWQ/XG4gIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG5cblxuICBpZiAoL1tcIicoKSBcXHRcXG5dfCglMjApLy50ZXN0KHVybCkgfHwgb3B0aW9ucy5uZWVkUXVvdGVzKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdCh1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLCBcIlxcXCJcIik7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsIi8qISBodHRwczovL210aHMuYmUvY3NzZXNjIHYzLjAuMCBieSBAbWF0aGlhcyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0ID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZShvcHRpb25zLCBkZWZhdWx0cykge1xuXHRpZiAoIW9wdGlvbnMpIHtcblx0XHRyZXR1cm4gZGVmYXVsdHM7XG5cdH1cblx0dmFyIHJlc3VsdCA9IHt9O1xuXHRmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcblx0XHQvLyBgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KGtleSkgeyDigKYgfWAgaXMgbm90IG5lZWRlZCBoZXJlLCBzaW5jZVxuXHRcdC8vIG9ubHkgcmVjb2duaXplZCBvcHRpb24gbmFtZXMgYXJlIHVzZWQuXG5cdFx0cmVzdWx0W2tleV0gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGtleSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0c1trZXldO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgcmVnZXhBbnlTaW5nbGVFc2NhcGUgPSAvWyAtLFxcLlxcLzotQFxcWy1cXF5gXFx7LX5dLztcbnZhciByZWdleFNpbmdsZUVzY2FwZSA9IC9bIC0sXFwuXFwvOi1AXFxbXFxdXFxeYFxcey1+XS87XG52YXIgcmVnZXhBbHdheXNFc2NhcGUgPSAvWydcIlxcXFxdLztcbnZhciByZWdleEV4Y2Vzc2l2ZVNwYWNlcyA9IC8oXnxcXFxcKyk/KFxcXFxbQS1GMC05XXsxLDZ9KVxceDIwKD8hW2EtZkEtRjAtOVxceDIwXSkvZztcblxuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2Nzcy1lc2NhcGVzI2Nzc1xudmFyIGNzc2VzYyA9IGZ1bmN0aW9uIGNzc2VzYyhzdHJpbmcsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGNzc2VzYy5vcHRpb25zKTtcblx0aWYgKG9wdGlvbnMucXVvdGVzICE9ICdzaW5nbGUnICYmIG9wdGlvbnMucXVvdGVzICE9ICdkb3VibGUnKSB7XG5cdFx0b3B0aW9ucy5xdW90ZXMgPSAnc2luZ2xlJztcblx0fVxuXHR2YXIgcXVvdGUgPSBvcHRpb25zLnF1b3RlcyA9PSAnZG91YmxlJyA/ICdcIicgOiAnXFwnJztcblx0dmFyIGlzSWRlbnRpZmllciA9IG9wdGlvbnMuaXNJZGVudGlmaWVyO1xuXG5cdHZhciBmaXJzdENoYXIgPSBzdHJpbmcuY2hhckF0KDApO1xuXHR2YXIgb3V0cHV0ID0gJyc7XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFyIGNoYXJhY3RlciA9IHN0cmluZy5jaGFyQXQoY291bnRlcisrKTtcblx0XHR2YXIgY29kZVBvaW50ID0gY2hhcmFjdGVyLmNoYXJDb2RlQXQoKTtcblx0XHR2YXIgdmFsdWUgPSB2b2lkIDA7XG5cdFx0Ly8gSWYgaXTigJlzIG5vdCBhIHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXLigKZcblx0XHRpZiAoY29kZVBvaW50IDwgMHgyMCB8fCBjb2RlUG9pbnQgPiAweDdFKSB7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gSXTigJlzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHtcblx0XHRcdFx0XHQvLyBuZXh0IGNoYXJhY3RlciBpcyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0Y29kZVBvaW50ID0gKChjb2RlUG9pbnQgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBJdOKAmXMgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2Vcblx0XHRcdFx0XHQvLyB0aGUgbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9ICdcXFxcJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICcgJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKG9wdGlvbnMuZXNjYXBlRXZlcnl0aGluZykge1xuXHRcdFx0XHRpZiAocmVnZXhBbnlTaW5nbGVFc2NhcGUudGVzdChjaGFyYWN0ZXIpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjaGFyYWN0ZXI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnICc7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoL1tcXHRcXG5cXGZcXHJcXHgwQl0vLnRlc3QoY2hhcmFjdGVyKSkge1xuXHRcdFx0XHR2YWx1ZSA9ICdcXFxcJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICcgJztcblx0XHRcdH0gZWxzZSBpZiAoY2hhcmFjdGVyID09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyICYmIChjaGFyYWN0ZXIgPT0gJ1wiJyAmJiBxdW90ZSA9PSBjaGFyYWN0ZXIgfHwgY2hhcmFjdGVyID09ICdcXCcnICYmIHF1b3RlID09IGNoYXJhY3RlcikgfHwgaXNJZGVudGlmaWVyICYmIHJlZ2V4U2luZ2xlRXNjYXBlLnRlc3QoY2hhcmFjdGVyKSkge1xuXHRcdFx0XHR2YWx1ZSA9ICdcXFxcJyArIGNoYXJhY3Rlcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gY2hhcmFjdGVyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRvdXRwdXQgKz0gdmFsdWU7XG5cdH1cblxuXHRpZiAoaXNJZGVudGlmaWVyKSB7XG5cdFx0aWYgKC9eLVstXFxkXS8udGVzdChvdXRwdXQpKSB7XG5cdFx0XHRvdXRwdXQgPSAnXFxcXC0nICsgb3V0cHV0LnNsaWNlKDEpO1xuXHRcdH0gZWxzZSBpZiAoL1xcZC8udGVzdChmaXJzdENoYXIpKSB7XG5cdFx0XHRvdXRwdXQgPSAnXFxcXDMnICsgZmlyc3RDaGFyICsgJyAnICsgb3V0cHV0LnNsaWNlKDEpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSBzcGFjZXMgYWZ0ZXIgYFxcSEVYYCBlc2NhcGVzIHRoYXQgYXJlIG5vdCBmb2xsb3dlZCBieSBhIGhleCBkaWdpdCxcblx0Ly8gc2luY2UgdGhleeKAmXJlIHJlZHVuZGFudC4gTm90ZSB0aGF0IHRoaXMgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgZXNjYXBlXG5cdC8vIHNlcXVlbmNlIGlzbuKAmXQgcHJlY2VkZWQgYnkgYW4gb2RkIG51bWJlciBvZiBiYWNrc2xhc2hlcy5cblx0b3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UocmVnZXhFeGNlc3NpdmVTcGFjZXMsIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG5cdFx0aWYgKCQxICYmICQxLmxlbmd0aCAlIDIpIHtcblx0XHRcdC8vIEl04oCZcyBub3Qgc2FmZSB0byByZW1vdmUgdGhlIHNwYWNlLCBzbyBkb27igJl0LlxuXHRcdFx0cmV0dXJuICQwO1xuXHRcdH1cblx0XHQvLyBTdHJpcCB0aGUgc3BhY2UuXG5cdFx0cmV0dXJuICgkMSB8fCAnJykgKyAkMjtcblx0fSk7XG5cblx0aWYgKCFpc0lkZW50aWZpZXIgJiYgb3B0aW9ucy53cmFwKSB7XG5cdFx0cmV0dXJuIHF1b3RlICsgb3V0cHV0ICsgcXVvdGU7XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn07XG5cbi8vIEV4cG9zZSBkZWZhdWx0IG9wdGlvbnMgKHNvIHRoZXkgY2FuIGJlIG92ZXJyaWRkZW4gZ2xvYmFsbHkpLlxuY3NzZXNjLm9wdGlvbnMgPSB7XG5cdCdlc2NhcGVFdmVyeXRoaW5nJzogZmFsc2UsXG5cdCdpc0lkZW50aWZpZXInOiBmYWxzZSxcblx0J3F1b3Rlcyc6ICdzaW5nbGUnLFxuXHQnd3JhcCc6IGZhbHNlXG59O1xuXG5jc3Nlc2MudmVyc2lvbiA9ICczLjAuMCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY3NzZXNjO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9wcm9jZXNzb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Byb2Nlc3NvclwiKSk7XG5cbnZhciBzZWxlY3RvcnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9zZWxlY3RvcnNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBwYXJzZXIgPSBmdW5jdGlvbiBwYXJzZXIocHJvY2Vzc29yKSB7XG4gIHJldHVybiBuZXcgX3Byb2Nlc3NvcltcImRlZmF1bHRcIl0ocHJvY2Vzc29yKTtcbn07XG5cbk9iamVjdC5hc3NpZ24ocGFyc2VyLCBzZWxlY3RvcnMpO1xuZGVsZXRlIHBhcnNlci5fX2VzTW9kdWxlO1xudmFyIF9kZWZhdWx0ID0gcGFyc2VyO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcm9vdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2VsZWN0b3JzL3Jvb3RcIikpO1xuXG52YXIgX3NlbGVjdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvc2VsZWN0b3JcIikpO1xuXG52YXIgX2NsYXNzTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2VsZWN0b3JzL2NsYXNzTmFtZVwiKSk7XG5cbnZhciBfY29tbWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2VsZWN0b3JzL2NvbW1lbnRcIikpO1xuXG52YXIgX2lkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvaWRcIikpO1xuXG52YXIgX3RhZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2VsZWN0b3JzL3RhZ1wiKSk7XG5cbnZhciBfc3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvc3RyaW5nXCIpKTtcblxudmFyIF9wc2V1ZG8gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NlbGVjdG9ycy9wc2V1ZG9cIikpO1xuXG52YXIgX2F0dHJpYnV0ZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3NlbGVjdG9ycy9hdHRyaWJ1dGVcIikpO1xuXG52YXIgX3VuaXZlcnNhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2VsZWN0b3JzL3VuaXZlcnNhbFwiKSk7XG5cbnZhciBfY29tYmluYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2VsZWN0b3JzL2NvbWJpbmF0b3JcIikpO1xuXG52YXIgX25lc3RpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NlbGVjdG9ycy9uZXN0aW5nXCIpKTtcblxudmFyIF9zb3J0QXNjZW5kaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zb3J0QXNjZW5kaW5nXCIpKTtcblxudmFyIF90b2tlbml6ZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3Rva2VuaXplXCIpKTtcblxudmFyIHRva2VucyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3Rva2VuVHlwZXNcIikpO1xuXG52YXIgdHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvdHlwZXNcIikpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgX1dISVRFU1BBQ0VfVE9LRU5TLCBfT2JqZWN0JGFzc2lnbjtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBXSElURVNQQUNFX1RPS0VOUyA9IChfV0hJVEVTUEFDRV9UT0tFTlMgPSB7fSwgX1dISVRFU1BBQ0VfVE9LRU5TW3Rva2Vucy5zcGFjZV0gPSB0cnVlLCBfV0hJVEVTUEFDRV9UT0tFTlNbdG9rZW5zLmNyXSA9IHRydWUsIF9XSElURVNQQUNFX1RPS0VOU1t0b2tlbnMuZmVlZF0gPSB0cnVlLCBfV0hJVEVTUEFDRV9UT0tFTlNbdG9rZW5zLm5ld2xpbmVdID0gdHJ1ZSwgX1dISVRFU1BBQ0VfVE9LRU5TW3Rva2Vucy50YWJdID0gdHJ1ZSwgX1dISVRFU1BBQ0VfVE9LRU5TKTtcbnZhciBXSElURVNQQUNFX0VRVUlWX1RPS0VOUyA9IE9iamVjdC5hc3NpZ24oe30sIFdISVRFU1BBQ0VfVE9LRU5TLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bdG9rZW5zLmNvbW1lbnRdID0gdHJ1ZSwgX09iamVjdCRhc3NpZ24pKTtcblxuZnVuY3Rpb24gdG9rZW5TdGFydCh0b2tlbikge1xuICByZXR1cm4ge1xuICAgIGxpbmU6IHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfTElORV0sXG4gICAgY29sdW1uOiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9rZW5FbmQodG9rZW4pIHtcbiAgcmV0dXJuIHtcbiAgICBsaW5lOiB0b2tlbltfdG9rZW5pemUuRklFTERTLkVORF9MSU5FXSxcbiAgICBjb2x1bW46IHRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlKHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbikge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiB7XG4gICAgICBsaW5lOiBzdGFydExpbmUsXG4gICAgICBjb2x1bW46IHN0YXJ0Q29sdW1uXG4gICAgfSxcbiAgICBlbmQ6IHtcbiAgICAgIGxpbmU6IGVuZExpbmUsXG4gICAgICBjb2x1bW46IGVuZENvbHVtblxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW5Tb3VyY2UodG9rZW4pIHtcbiAgcmV0dXJuIGdldFNvdXJjZSh0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0xJTkVdLCB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF0sIHRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0xJTkVdLCB0b2tlbltfdG9rZW5pemUuRklFTERTLkVORF9DT0xdKTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW5Tb3VyY2VTcGFuKHN0YXJ0VG9rZW4sIGVuZFRva2VuKSB7XG4gIGlmICghc3RhcnRUb2tlbikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U291cmNlKHN0YXJ0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9MSU5FXSwgc3RhcnRUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF0sIGVuZFRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0xJTkVdLCBlbmRUb2tlbltfdG9rZW5pemUuRklFTERTLkVORF9DT0xdKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVQcm9wKG5vZGUsIHByb3ApIHtcbiAgdmFyIHZhbHVlID0gbm9kZVtwcm9wXTtcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkge1xuICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJyk7XG4gICAgbm9kZVtwcm9wXSA9ICgwLCBfdXRpbC51bmVzYykodmFsdWUpO1xuXG4gICAgaWYgKG5vZGUucmF3c1twcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2RlLnJhd3NbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gaW5kZXhlc09mKGFycmF5LCBpdGVtKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciBpbmRleGVzID0gW107XG5cbiAgd2hpbGUgKChpID0gYXJyYXkuaW5kZXhPZihpdGVtLCBpICsgMSkpICE9PSAtMSkge1xuICAgIGluZGV4ZXMucHVzaChpKTtcbiAgfVxuXG4gIHJldHVybiBpbmRleGVzO1xufVxuXG5mdW5jdGlvbiB1bmlxcygpIHtcbiAgdmFyIGxpc3QgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcmd1bWVudHMpO1xuICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICByZXR1cm4gaSA9PT0gbGlzdC5pbmRleE9mKGl0ZW0pO1xuICB9KTtcbn1cblxudmFyIFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhcnNlcihydWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMucnVsZSA9IHJ1bGU7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsb3NzeTogZmFsc2UsXG4gICAgICBzYWZlOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgIHRoaXMuY3NzID0gdHlwZW9mIHRoaXMucnVsZSA9PT0gJ3N0cmluZycgPyB0aGlzLnJ1bGUgOiB0aGlzLnJ1bGUuc2VsZWN0b3I7XG4gICAgdGhpcy50b2tlbnMgPSAoMCwgX3Rva2VuaXplW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgY3NzOiB0aGlzLmNzcyxcbiAgICAgIGVycm9yOiB0aGlzLl9lcnJvckdlbmVyYXRvcigpLFxuICAgICAgc2FmZTogdGhpcy5vcHRpb25zLnNhZmVcbiAgICB9KTtcbiAgICB2YXIgcm9vdFNvdXJjZSA9IGdldFRva2VuU291cmNlU3Bhbih0aGlzLnRva2Vuc1swXSwgdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0pO1xuICAgIHRoaXMucm9vdCA9IG5ldyBfcm9vdFtcImRlZmF1bHRcIl0oe1xuICAgICAgc291cmNlOiByb290U291cmNlXG4gICAgfSk7XG4gICAgdGhpcy5yb290LmVycm9yR2VuZXJhdG9yID0gdGhpcy5fZXJyb3JHZW5lcmF0b3IoKTtcbiAgICB2YXIgc2VsZWN0b3IgPSBuZXcgX3NlbGVjdG9yW1wiZGVmYXVsdFwiXSh7XG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgIGNvbHVtbjogMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yb290LmFwcGVuZChzZWxlY3Rvcik7XG4gICAgdGhpcy5jdXJyZW50ID0gc2VsZWN0b3I7XG4gICAgdGhpcy5sb29wKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2Vycm9yR2VuZXJhdG9yID0gZnVuY3Rpb24gX2Vycm9yR2VuZXJhdG9yKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yT3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBfdGhpcy5ydWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMucnVsZS5lcnJvcihtZXNzYWdlLCBlcnJvck9wdGlvbnMpO1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGF0dHJpYnV0ZSgpIHtcbiAgICB2YXIgYXR0ciA9IFtdO1xuICAgIHZhciBzdGFydGluZ1Rva2VuID0gdGhpcy5jdXJyVG9rZW47XG4gICAgdGhpcy5wb3NpdGlvbisrO1xuXG4gICAgd2hpbGUgKHRoaXMucG9zaXRpb24gPCB0aGlzLnRva2Vucy5sZW5ndGggJiYgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSAhPT0gdG9rZW5zLmNsb3NlU3F1YXJlKSB7XG4gICAgICBhdHRyLnB1c2godGhpcy5jdXJyVG9rZW4pO1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdICE9PSB0b2tlbnMuY2xvc2VTcXVhcmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdjbG9zaW5nIHNxdWFyZSBicmFja2V0JywgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gYXR0ci5sZW5ndGg7XG4gICAgdmFyIG5vZGUgPSB7XG4gICAgICBzb3VyY2U6IGdldFNvdXJjZShzdGFydGluZ1Rva2VuWzFdLCBzdGFydGluZ1Rva2VuWzJdLCB0aGlzLmN1cnJUb2tlblszXSwgdGhpcy5jdXJyVG9rZW5bNF0pLFxuICAgICAgc291cmNlSW5kZXg6IHN0YXJ0aW5nVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgfTtcblxuICAgIGlmIChsZW4gPT09IDEgJiYgIX5bdG9rZW5zLndvcmRdLmluZGV4T2YoYXR0clswXVtfdG9rZW5pemUuRklFTERTLlRZUEVdKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoJ2F0dHJpYnV0ZScsIGF0dHJbMF1bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgc3BhY2VCZWZvcmUgPSAnJztcbiAgICB2YXIgY29tbWVudEJlZm9yZSA9ICcnO1xuICAgIHZhciBsYXN0QWRkZWQgPSBudWxsO1xuICAgIHZhciBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG5cbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICB2YXIgdG9rZW4gPSBhdHRyW3Bvc107XG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudCh0b2tlbik7XG4gICAgICB2YXIgbmV4dCA9IGF0dHJbcG9zICsgMV07XG5cbiAgICAgIHN3aXRjaCAodG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSkge1xuICAgICAgICBjYXNlIHRva2Vucy5zcGFjZTpcbiAgICAgICAgICAvLyBpZiAoXG4gICAgICAgICAgLy8gICAgIGxlbiA9PT0gMSB8fFxuICAgICAgICAgIC8vICAgICBwb3MgPT09IDAgJiYgdGhpcy5jb250ZW50KG5leHQpID09PSAnfCdcbiAgICAgICAgICAvLyApIHtcbiAgICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoJ2F0dHJpYnV0ZScsIHRva2VuW1RPS0VOLlNUQVJUX1BPU10sIGNvbnRlbnQpO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9zc3kpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYXN0QWRkZWQpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdzcGFjZXMnLCBsYXN0QWRkZWQpO1xuICAgICAgICAgICAgdmFyIHByZXZDb250ZW50ID0gbm9kZS5zcGFjZXNbbGFzdEFkZGVkXS5hZnRlciB8fCAnJztcbiAgICAgICAgICAgIG5vZGUuc3BhY2VzW2xhc3RBZGRlZF0uYWZ0ZXIgPSBwcmV2Q29udGVudCArIGNvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdDb21tZW50ID0gKDAsIF91dGlsLmdldFByb3ApKG5vZGUsICdyYXdzJywgJ3NwYWNlcycsIGxhc3RBZGRlZCwgJ2FmdGVyJykgfHwgbnVsbDtcblxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ29tbWVudCkge1xuICAgICAgICAgICAgICBub2RlLnJhd3Muc3BhY2VzW2xhc3RBZGRlZF0uYWZ0ZXIgPSBleGlzdGluZ0NvbW1lbnQgKyBjb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGFjZUJlZm9yZSA9IHNwYWNlQmVmb3JlICsgY29udGVudDtcbiAgICAgICAgICAgIGNvbW1lbnRCZWZvcmUgPSBjb21tZW50QmVmb3JlICsgY29udGVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRva2Vucy5hc3RlcmlzazpcbiAgICAgICAgICBpZiAobmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuZXF1YWxzKSB7XG4gICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gY29udGVudDtcbiAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdvcGVyYXRvcic7XG4gICAgICAgICAgfSBlbHNlIGlmICgoIW5vZGUubmFtZXNwYWNlIHx8IGxhc3RBZGRlZCA9PT0gXCJuYW1lc3BhY2VcIiAmJiAhc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbikgJiYgbmV4dCkge1xuICAgICAgICAgICAgaWYgKHNwYWNlQmVmb3JlKSB7XG4gICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdzcGFjZXMnLCAnYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAgIG5vZGUuc3BhY2VzLmF0dHJpYnV0ZS5iZWZvcmUgPSBzcGFjZUJlZm9yZTtcbiAgICAgICAgICAgICAgc3BhY2VCZWZvcmUgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnLCAnc3BhY2VzJywgJ2F0dHJpYnV0ZScpO1xuICAgICAgICAgICAgICBub2RlLnJhd3Muc3BhY2VzLmF0dHJpYnV0ZS5iZWZvcmUgPSBzcGFjZUJlZm9yZTtcbiAgICAgICAgICAgICAgY29tbWVudEJlZm9yZSA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLm5hbWVzcGFjZSA9IChub2RlLm5hbWVzcGFjZSB8fCBcIlwiKSArIGNvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAnbmFtZXNwYWNlJykgfHwgbnVsbDtcblxuICAgICAgICAgICAgaWYgKHJhd1ZhbHVlKSB7XG4gICAgICAgICAgICAgIG5vZGUucmF3cy5uYW1lc3BhY2UgKz0gY29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdEFkZGVkID0gJ25hbWVzcGFjZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdG9rZW5zLmRvbGxhcjpcbiAgICAgICAgICBpZiAobGFzdEFkZGVkID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgIHZhciBvbGRSYXdWYWx1ZSA9ICgwLCBfdXRpbC5nZXRQcm9wKShub2RlLCAncmF3cycsICd2YWx1ZScpO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSArPSBcIiRcIjtcblxuICAgICAgICAgICAgaWYgKG9sZFJhd1ZhbHVlKSB7XG4gICAgICAgICAgICAgIG5vZGUucmF3cy52YWx1ZSA9IG9sZFJhd1ZhbHVlICsgXCIkXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBGYWxscyB0aHJvdWdoXG5cbiAgICAgICAgY2FzZSB0b2tlbnMuY2FyZXQ6XG4gICAgICAgICAgaWYgKG5leHRbX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmVxdWFscykge1xuICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IGNvbnRlbnQ7XG4gICAgICAgICAgICBsYXN0QWRkZWQgPSAnb3BlcmF0b3InO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRva2Vucy5jb21iaW5hdG9yOlxuICAgICAgICAgIGlmIChjb250ZW50ID09PSAnficgJiYgbmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuZXF1YWxzKSB7XG4gICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gY29udGVudDtcbiAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdvcGVyYXRvcic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRlbnQgIT09ICd8Jykge1xuICAgICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHRbX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmVxdWFscykge1xuICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IGNvbnRlbnQ7XG4gICAgICAgICAgICBsYXN0QWRkZWQgPSAnb3BlcmF0b3InO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUubmFtZXNwYWNlICYmICFub2RlLmF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgbm9kZS5uYW1lc3BhY2UgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRva2Vucy53b3JkOlxuICAgICAgICAgIGlmIChuZXh0ICYmIHRoaXMuY29udGVudChuZXh0KSA9PT0gJ3wnICYmIGF0dHJbcG9zICsgMl0gJiYgYXR0cltwb3MgKyAyXVtfdG9rZW5pemUuRklFTERTLlRZUEVdICE9PSB0b2tlbnMuZXF1YWxzICYmIC8vIHRoaXMgbG9vay1haGVhZCBwcm9iYWJseSBmYWlscyB3aXRoIGNvbW1lbnQgbm9kZXMgaW52b2x2ZWQuXG4gICAgICAgICAgIW5vZGUub3BlcmF0b3IgJiYgIW5vZGUubmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBub2RlLm5hbWVzcGFjZSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICBsYXN0QWRkZWQgPSAnbmFtZXNwYWNlJztcbiAgICAgICAgICB9IGVsc2UgaWYgKCFub2RlLmF0dHJpYnV0ZSB8fCBsYXN0QWRkZWQgPT09IFwiYXR0cmlidXRlXCIgJiYgIXNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChzcGFjZUJlZm9yZSkge1xuICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAnc3BhY2VzJywgJ2F0dHJpYnV0ZScpO1xuICAgICAgICAgICAgICBub2RlLnNwYWNlcy5hdHRyaWJ1dGUuYmVmb3JlID0gc3BhY2VCZWZvcmU7XG4gICAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21tZW50QmVmb3JlKSB7XG4gICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJywgJ3NwYWNlcycsICdhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgICAgbm9kZS5yYXdzLnNwYWNlcy5hdHRyaWJ1dGUuYmVmb3JlID0gY29tbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgY29tbWVudEJlZm9yZSA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLmF0dHJpYnV0ZSA9IChub2RlLmF0dHJpYnV0ZSB8fCBcIlwiKSArIGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIHZhciBfcmF3VmFsdWUgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAnYXR0cmlidXRlJykgfHwgbnVsbDtcblxuICAgICAgICAgICAgaWYgKF9yYXdWYWx1ZSkge1xuICAgICAgICAgICAgICBub2RlLnJhd3MuYXR0cmlidXRlICs9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdhdHRyaWJ1dGUnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUudmFsdWUgJiYgbm9kZS52YWx1ZSAhPT0gXCJcIiB8fCBsYXN0QWRkZWQgPT09IFwidmFsdWVcIiAmJiAhc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbikge1xuICAgICAgICAgICAgdmFyIF91bmVzY2FwZWQgPSAoMCwgX3V0aWwudW5lc2MpKGNvbnRlbnQpO1xuXG4gICAgICAgICAgICB2YXIgX29sZFJhd1ZhbHVlID0gKDAsIF91dGlsLmdldFByb3ApKG5vZGUsICdyYXdzJywgJ3ZhbHVlJykgfHwgJyc7XG5cbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IG5vZGUudmFsdWUgfHwgJyc7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gb2xkVmFsdWUgKyBfdW5lc2NhcGVkO1xuICAgICAgICAgICAgbm9kZS5xdW90ZU1hcmsgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoX3VuZXNjYXBlZCAhPT0gY29udGVudCB8fCBfb2xkUmF3VmFsdWUpIHtcbiAgICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnKTtcbiAgICAgICAgICAgICAgbm9kZS5yYXdzLnZhbHVlID0gKF9vbGRSYXdWYWx1ZSB8fCBvbGRWYWx1ZSkgKyBjb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0QWRkZWQgPSAndmFsdWUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5zZW5zaXRpdmUgPSBjb250ZW50ID09PSAnaScgfHwgY29udGVudCA9PT0gXCJJXCI7XG5cbiAgICAgICAgICAgIGlmICgobm9kZS52YWx1ZSB8fCBub2RlLnZhbHVlID09PSAnJykgJiYgKG5vZGUucXVvdGVNYXJrIHx8IHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4pKSB7XG4gICAgICAgICAgICAgIG5vZGUuaW5zZW5zaXRpdmUgPSBpbnNlbnNpdGl2ZTtcblxuICAgICAgICAgICAgICBpZiAoIWluc2Vuc2l0aXZlIHx8IGNvbnRlbnQgPT09IFwiSVwiKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnKTtcbiAgICAgICAgICAgICAgICBub2RlLnJhd3MuaW5zZW5zaXRpdmVGbGFnID0gY29udGVudDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdpbnNlbnNpdGl2ZSc7XG5cbiAgICAgICAgICAgICAgaWYgKHNwYWNlQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3NwYWNlcycsICdpbnNlbnNpdGl2ZScpO1xuICAgICAgICAgICAgICAgIG5vZGUuc3BhY2VzLmluc2Vuc2l0aXZlLmJlZm9yZSA9IHNwYWNlQmVmb3JlO1xuICAgICAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gJyc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29tbWVudEJlZm9yZSkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJywgJ3NwYWNlcycsICdpbnNlbnNpdGl2ZScpO1xuICAgICAgICAgICAgICAgIG5vZGUucmF3cy5zcGFjZXMuaW5zZW5zaXRpdmUuYmVmb3JlID0gY29tbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgICBjb21tZW50QmVmb3JlID0gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSB8fCBub2RlLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICBsYXN0QWRkZWQgPSAndmFsdWUnO1xuICAgICAgICAgICAgICBub2RlLnZhbHVlICs9IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKG5vZGUucmF3cy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmF3cy52YWx1ZSArPSBjb250ZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdG9rZW5zLnN0cjpcbiAgICAgICAgICBpZiAoIW5vZGUuYXR0cmlidXRlIHx8ICFub2RlLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIkV4cGVjdGVkIGFuIGF0dHJpYnV0ZSBmb2xsb3dlZCBieSBhbiBvcGVyYXRvciBwcmVjZWRpbmcgdGhlIHN0cmluZy5cIiwge1xuICAgICAgICAgICAgICBpbmRleDogdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3VuZXNjYXBlVmFsdWUgPSAoMCwgX2F0dHJpYnV0ZS51bmVzY2FwZVZhbHVlKShjb250ZW50KSxcbiAgICAgICAgICAgICAgdW5lc2NhcGVkID0gX3VuZXNjYXBlVmFsdWUudW5lc2NhcGVkLFxuICAgICAgICAgICAgICBxdW90ZU1hcmsgPSBfdW5lc2NhcGVWYWx1ZS5xdW90ZU1hcms7XG5cbiAgICAgICAgICBub2RlLnZhbHVlID0gdW5lc2NhcGVkO1xuICAgICAgICAgIG5vZGUucXVvdGVNYXJrID0gcXVvdGVNYXJrO1xuICAgICAgICAgIGxhc3RBZGRlZCA9ICd2YWx1ZSc7XG4gICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnKTtcbiAgICAgICAgICBub2RlLnJhd3MudmFsdWUgPSBjb250ZW50O1xuICAgICAgICAgIHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRva2Vucy5lcXVhbHM6XG4gICAgICAgICAgaWYgKCFub2RlLmF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoJ2F0dHJpYnV0ZScsIHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSwgY29udGVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdVbmV4cGVjdGVkIFwiPVwiIGZvdW5kOyBhbiBvcGVyYXRvciB3YXMgYWxyZWFkeSBkZWZpbmVkLicsIHtcbiAgICAgICAgICAgICAgaW5kZXg6IHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZS5vcGVyYXRvciA9IG5vZGUub3BlcmF0b3IgPyBub2RlLm9wZXJhdG9yICsgY29udGVudCA6IGNvbnRlbnQ7XG4gICAgICAgICAgbGFzdEFkZGVkID0gJ29wZXJhdG9yJztcbiAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0b2tlbnMuY29tbWVudDpcbiAgICAgICAgICBpZiAobGFzdEFkZGVkKSB7XG4gICAgICAgICAgICBpZiAoc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiB8fCBuZXh0ICYmIG5leHRbX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLnNwYWNlIHx8IGxhc3RBZGRlZCA9PT0gJ2luc2Vuc2l0aXZlJykge1xuICAgICAgICAgICAgICB2YXIgbGFzdENvbW1lbnQgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3NwYWNlcycsIGxhc3RBZGRlZCwgJ2FmdGVyJykgfHwgJyc7XG4gICAgICAgICAgICAgIHZhciByYXdMYXN0Q29tbWVudCA9ICgwLCBfdXRpbC5nZXRQcm9wKShub2RlLCAncmF3cycsICdzcGFjZXMnLCBsYXN0QWRkZWQsICdhZnRlcicpIHx8IGxhc3RDb21tZW50O1xuICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycsICdzcGFjZXMnLCBsYXN0QWRkZWQpO1xuICAgICAgICAgICAgICBub2RlLnJhd3Muc3BhY2VzW2xhc3RBZGRlZF0uYWZ0ZXIgPSByYXdMYXN0Q29tbWVudCArIGNvbnRlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbGFzdFZhbHVlID0gbm9kZVtsYXN0QWRkZWRdIHx8ICcnO1xuICAgICAgICAgICAgICB2YXIgcmF3TGFzdFZhbHVlID0gKDAsIF91dGlsLmdldFByb3ApKG5vZGUsICdyYXdzJywgbGFzdEFkZGVkKSB8fCBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJyk7XG4gICAgICAgICAgICAgIG5vZGUucmF3c1tsYXN0QWRkZWRdID0gcmF3TGFzdFZhbHVlICsgY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tbWVudEJlZm9yZSA9IGNvbW1lbnRCZWZvcmUgKyBjb250ZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIFxcXCJcIiArIGNvbnRlbnQgKyBcIlxcXCIgZm91bmQuXCIsIHtcbiAgICAgICAgICAgIGluZGV4OiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgdW5lc2NhcGVQcm9wKG5vZGUsIFwiYXR0cmlidXRlXCIpO1xuICAgIHVuZXNjYXBlUHJvcChub2RlLCBcIm5hbWVzcGFjZVwiKTtcbiAgICB0aGlzLm5ld05vZGUobmV3IF9hdHRyaWJ1dGVbXCJkZWZhdWx0XCJdKG5vZGUpKTtcbiAgICB0aGlzLnBvc2l0aW9uKys7XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybiBhIG5vZGUgY29udGFpbmluZyBtZWFuaW5nbGVzcyBnYXJiYWdlIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIHNwZWNpZmllZCB0b2tlbiBwb3NpdGlvbi5cbiAgICogaWYgdGhlIHRva2VuIHBvc2l0aW9uIGlzIG5lZ2F0aXZlLCBhbGwgcmVtYWluaW5nIHRva2VucyBhcmUgY29uc3VtZWQuXG4gICAqXG4gICAqIFRoaXMgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGEgc2luZ2xlIHN0cmluZyBub2RlIGlmIGFsbCB3aGl0ZXNwYWNlLFxuICAgKiBvdGhlcndpc2UgYW4gYXJyYXkgb2YgY29tbWVudCBub2RlcyB3aXRoIHNwYWNlIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gICAqXG4gICAqIFRoZXNlIHRva2VucyBhcmUgbm90IGFkZGVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdG9yLCB0aGUgY2FsbGVyIGNhbiBhZGQgdGhlbSBvciB1c2UgdGhlbSB0byBhbWVuZFxuICAgKiBhIHByZXZpb3VzIG5vZGUncyBzcGFjZSBtZXRhZGF0YS5cbiAgICpcbiAgICogSW4gbG9zc3kgbW9kZSwgdGhpcyByZXR1cm5zIG9ubHkgY29tbWVudHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlV2hpdGVzcGFjZUVxdWl2YWxlbnRUb2tlbnMgPSBmdW5jdGlvbiBwYXJzZVdoaXRlc3BhY2VFcXVpdmFsZW50VG9rZW5zKHN0b3BQb3NpdGlvbikge1xuICAgIGlmIChzdG9wUG9zaXRpb24gPCAwKSB7XG4gICAgICBzdG9wUG9zaXRpb24gPSB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBzcGFjZSA9IFwiXCI7XG4gICAgdmFyIGxhc3RDb21tZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKFdISVRFU1BBQ0VfVE9LRU5TW3RoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV1dKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxvc3N5KSB7XG4gICAgICAgICAgc3BhY2UgKz0gdGhpcy5jb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNvbW1lbnQpIHtcbiAgICAgICAgdmFyIHNwYWNlcyA9IHt9O1xuXG4gICAgICAgIGlmIChzcGFjZSkge1xuICAgICAgICAgIHNwYWNlcy5iZWZvcmUgPSBzcGFjZTtcbiAgICAgICAgICBzcGFjZSA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0Q29tbWVudCA9IG5ldyBfY29tbWVudFtcImRlZmF1bHRcIl0oe1xuICAgICAgICAgIHZhbHVlOiB0aGlzLmNvbnRlbnQoKSxcbiAgICAgICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlKHRoaXMuY3VyclRva2VuKSxcbiAgICAgICAgICBzb3VyY2VJbmRleDogdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLFxuICAgICAgICAgIHNwYWNlczogc3BhY2VzXG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKGxhc3RDb21tZW50KTtcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK3RoaXMucG9zaXRpb24gPCBzdG9wUG9zaXRpb24pO1xuXG4gICAgaWYgKHNwYWNlKSB7XG4gICAgICBpZiAobGFzdENvbW1lbnQpIHtcbiAgICAgICAgbGFzdENvbW1lbnQuc3BhY2VzLmFmdGVyID0gc3BhY2U7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMubG9zc3kpIHtcbiAgICAgICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLnRva2Vuc1tzdGFydFBvc2l0aW9uXTtcbiAgICAgICAgdmFyIGxhc3RUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gLSAxXTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgX3N0cmluZ1tcImRlZmF1bHRcIl0oe1xuICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICBzb3VyY2U6IGdldFNvdXJjZShmaXJzdFRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfTElORV0sIGZpcnN0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9DT0xdLCBsYXN0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5FTkRfTElORV0sIGxhc3RUb2tlbltfdG9rZW5pemUuRklFTERTLkVORF9DT0xdKSxcbiAgICAgICAgICBzb3VyY2VJbmRleDogZmlyc3RUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10sXG4gICAgICAgICAgc3BhY2VzOiB7XG4gICAgICAgICAgICBiZWZvcmU6IHNwYWNlLFxuICAgICAgICAgICAgYWZ0ZXI6ICcnXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIC8qKlxuICAgKiBcbiAgICogQHBhcmFtIHsqfSBub2RlcyBcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY29udmVydFdoaXRlc3BhY2VOb2Rlc1RvU3BhY2UgPSBmdW5jdGlvbiBjb252ZXJ0V2hpdGVzcGFjZU5vZGVzVG9TcGFjZShub2RlcywgcmVxdWlyZWRTcGFjZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKHJlcXVpcmVkU3BhY2UgPT09IHZvaWQgMCkge1xuICAgICAgcmVxdWlyZWRTcGFjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzcGFjZSA9IFwiXCI7XG4gICAgdmFyIHJhd1NwYWNlID0gXCJcIjtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICB2YXIgc3BhY2VCZWZvcmUgPSBfdGhpczIubG9zc3lTcGFjZShuLnNwYWNlcy5iZWZvcmUsIHJlcXVpcmVkU3BhY2UpO1xuXG4gICAgICB2YXIgcmF3U3BhY2VCZWZvcmUgPSBfdGhpczIubG9zc3lTcGFjZShuLnJhd1NwYWNlQmVmb3JlLCByZXF1aXJlZFNwYWNlKTtcblxuICAgICAgc3BhY2UgKz0gc3BhY2VCZWZvcmUgKyBfdGhpczIubG9zc3lTcGFjZShuLnNwYWNlcy5hZnRlciwgcmVxdWlyZWRTcGFjZSAmJiBzcGFjZUJlZm9yZS5sZW5ndGggPT09IDApO1xuICAgICAgcmF3U3BhY2UgKz0gc3BhY2VCZWZvcmUgKyBuLnZhbHVlICsgX3RoaXMyLmxvc3N5U3BhY2Uobi5yYXdTcGFjZUFmdGVyLCByZXF1aXJlZFNwYWNlICYmIHJhd1NwYWNlQmVmb3JlLmxlbmd0aCA9PT0gMCk7XG4gICAgfSk7XG5cbiAgICBpZiAocmF3U3BhY2UgPT09IHNwYWNlKSB7XG4gICAgICByYXdTcGFjZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc3BhY2U6IHNwYWNlLFxuICAgICAgcmF3U3BhY2U6IHJhd1NwYWNlXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5pc05hbWVkQ29tYmluYXRvciA9IGZ1bmN0aW9uIGlzTmFtZWRDb21iaW5hdG9yKHBvc2l0aW9uKSB7XG4gICAgaWYgKHBvc2l0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2tlbnNbcG9zaXRpb24gKyAwXSAmJiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDBdW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5zbGFzaCAmJiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDFdICYmIHRoaXMudG9rZW5zW3Bvc2l0aW9uICsgMV1bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLndvcmQgJiYgdGhpcy50b2tlbnNbcG9zaXRpb24gKyAyXSAmJiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDJdW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5zbGFzaDtcbiAgfTtcblxuICBfcHJvdG8ubmFtZWRDb21iaW5hdG9yID0gZnVuY3Rpb24gbmFtZWRDb21iaW5hdG9yKCkge1xuICAgIGlmICh0aGlzLmlzTmFtZWRDb21iaW5hdG9yKCkpIHtcbiAgICAgIHZhciBuYW1lUmF3ID0gdGhpcy5jb250ZW50KHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gKyAxXSk7XG4gICAgICB2YXIgbmFtZSA9ICgwLCBfdXRpbC51bmVzYykobmFtZVJhdykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByYXdzID0ge307XG5cbiAgICAgIGlmIChuYW1lICE9PSBuYW1lUmF3KSB7XG4gICAgICAgIHJhd3MudmFsdWUgPSBcIi9cIiArIG5hbWVSYXcgKyBcIi9cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBuZXcgX2NvbWJpbmF0b3JbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgdmFsdWU6IFwiL1wiICsgbmFtZSArIFwiL1wiLFxuICAgICAgICBzb3VyY2U6IGdldFNvdXJjZSh0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0xJTkVdLCB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF0sIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gKyAyXVtfdG9rZW5pemUuRklFTERTLkVORF9MSU5FXSwgdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDJdW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pLFxuICAgICAgICBzb3VyY2VJbmRleDogdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLFxuICAgICAgICByYXdzOiByYXdzXG4gICAgICB9KTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uICsgMztcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbWJpbmF0b3IgPSBmdW5jdGlvbiBjb21iaW5hdG9yKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuY29udGVudCgpID09PSAnfCcpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZSgpO1xuICAgIH0gLy8gV2UgbmVlZCB0byBkZWNpZGUgYmV0d2VlbiBhIHNwYWNlIHRoYXQncyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciBhbmQgbWVhbmluZ2xlc3Mgd2hpdGVzcGFjZSBhdCB0aGUgZW5kIG9mIGEgc2VsZWN0b3IuXG5cblxuICAgIHZhciBuZXh0U2lnVG9rZW5Qb3MgPSB0aGlzLmxvY2F0ZU5leHRNZWFuaW5nZnVsVG9rZW4odGhpcy5wb3NpdGlvbik7XG5cbiAgICBpZiAobmV4dFNpZ1Rva2VuUG9zIDwgMCB8fCB0aGlzLnRva2Vuc1tuZXh0U2lnVG9rZW5Qb3NdW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21tYSkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5wYXJzZVdoaXRlc3BhY2VFcXVpdmFsZW50VG9rZW5zKG5leHRTaWdUb2tlblBvcyk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5jdXJyZW50Lmxhc3Q7XG5cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkY29udmVydFdoaXRlc3BhID0gdGhpcy5jb252ZXJ0V2hpdGVzcGFjZU5vZGVzVG9TcGFjZShub2RlcyksXG4gICAgICAgICAgICAgIHNwYWNlID0gX3RoaXMkY29udmVydFdoaXRlc3BhLnNwYWNlLFxuICAgICAgICAgICAgICByYXdTcGFjZSA9IF90aGlzJGNvbnZlcnRXaGl0ZXNwYS5yYXdTcGFjZTtcblxuICAgICAgICAgIGlmIChyYXdTcGFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYXN0LnJhd1NwYWNlQWZ0ZXIgKz0gcmF3U3BhY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGFzdC5zcGFjZXMuYWZ0ZXIgKz0gc3BhY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5uZXdOb2RlKG4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMuY3VyclRva2VuO1xuICAgIHZhciBzcGFjZU9yRGVzY2VuZGFudFNlbGVjdG9yTm9kZXMgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV4dFNpZ1Rva2VuUG9zID4gdGhpcy5wb3NpdGlvbikge1xuICAgICAgc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzID0gdGhpcy5wYXJzZVdoaXRlc3BhY2VFcXVpdmFsZW50VG9rZW5zKG5leHRTaWdUb2tlblBvcyk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAodGhpcy5pc05hbWVkQ29tYmluYXRvcigpKSB7XG4gICAgICBub2RlID0gdGhpcy5uYW1lZENvbWJpbmF0b3IoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21iaW5hdG9yKSB7XG4gICAgICBub2RlID0gbmV3IF9jb21iaW5hdG9yW1wiZGVmYXVsdFwiXSh7XG4gICAgICAgIHZhbHVlOiB0aGlzLmNvbnRlbnQoKSxcbiAgICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZSh0aGlzLmN1cnJUb2tlbiksXG4gICAgICAgIHNvdXJjZUluZGV4OiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH0gZWxzZSBpZiAoV0hJVEVTUEFDRV9UT0tFTlNbdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXV0pIHsvLyBwYXNzXG4gICAgfSBlbHNlIGlmICghc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgaWYgKHNwYWNlT3JEZXNjZW5kYW50U2VsZWN0b3JOb2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMkY29udmVydFdoaXRlc3BhMiA9IHRoaXMuY29udmVydFdoaXRlc3BhY2VOb2Rlc1RvU3BhY2Uoc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzKSxcbiAgICAgICAgICAgIF9zcGFjZSA9IF90aGlzJGNvbnZlcnRXaGl0ZXNwYTIuc3BhY2UsXG4gICAgICAgICAgICBfcmF3U3BhY2UgPSBfdGhpcyRjb252ZXJ0V2hpdGVzcGEyLnJhd1NwYWNlO1xuXG4gICAgICAgIG5vZGUuc3BhY2VzLmJlZm9yZSA9IF9zcGFjZTtcbiAgICAgICAgbm9kZS5yYXdTcGFjZUJlZm9yZSA9IF9yYXdTcGFjZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVzY2VuZGFudCBjb21iaW5hdG9yXG4gICAgICB2YXIgX3RoaXMkY29udmVydFdoaXRlc3BhMyA9IHRoaXMuY29udmVydFdoaXRlc3BhY2VOb2Rlc1RvU3BhY2Uoc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzLCB0cnVlKSxcbiAgICAgICAgICBfc3BhY2UyID0gX3RoaXMkY29udmVydFdoaXRlc3BhMy5zcGFjZSxcbiAgICAgICAgICBfcmF3U3BhY2UyID0gX3RoaXMkY29udmVydFdoaXRlc3BhMy5yYXdTcGFjZTtcblxuICAgICAgaWYgKCFfcmF3U3BhY2UyKSB7XG4gICAgICAgIF9yYXdTcGFjZTIgPSBfc3BhY2UyO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3BhY2VzID0ge307XG4gICAgICB2YXIgcmF3cyA9IHtcbiAgICAgICAgc3BhY2VzOiB7fVxuICAgICAgfTtcblxuICAgICAgaWYgKF9zcGFjZTIuZW5kc1dpdGgoJyAnKSAmJiBfcmF3U3BhY2UyLmVuZHNXaXRoKCcgJykpIHtcbiAgICAgICAgc3BhY2VzLmJlZm9yZSA9IF9zcGFjZTIuc2xpY2UoMCwgX3NwYWNlMi5sZW5ndGggLSAxKTtcbiAgICAgICAgcmF3cy5zcGFjZXMuYmVmb3JlID0gX3Jhd1NwYWNlMi5zbGljZSgwLCBfcmF3U3BhY2UyLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChfc3BhY2UyLnN0YXJ0c1dpdGgoJyAnKSAmJiBfcmF3U3BhY2UyLnN0YXJ0c1dpdGgoJyAnKSkge1xuICAgICAgICBzcGFjZXMuYWZ0ZXIgPSBfc3BhY2UyLnNsaWNlKDEpO1xuICAgICAgICByYXdzLnNwYWNlcy5hZnRlciA9IF9yYXdTcGFjZTIuc2xpY2UoMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXdzLnZhbHVlID0gX3Jhd1NwYWNlMjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5ldyBfY29tYmluYXRvcltcImRlZmF1bHRcIl0oe1xuICAgICAgICB2YWx1ZTogJyAnLFxuICAgICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlU3BhbihmaXJzdFRva2VuLCB0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uIC0gMV0pLFxuICAgICAgICBzb3VyY2VJbmRleDogZmlyc3RUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10sXG4gICAgICAgIHNwYWNlczogc3BhY2VzLFxuICAgICAgICByYXdzOiByYXdzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jdXJyVG9rZW4gJiYgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLnNwYWNlKSB7XG4gICAgICBub2RlLnNwYWNlcy5hZnRlciA9IHRoaXMub3B0aW9uYWxTcGFjZSh0aGlzLmNvbnRlbnQoKSk7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubmV3Tm9kZShub2RlKTtcbiAgfTtcblxuICBfcHJvdG8uY29tbWEgPSBmdW5jdGlvbiBjb21tYSgpIHtcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5yb290LnRyYWlsaW5nQ29tbWEgPSB0cnVlO1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudC5faW5mZXJFbmRQb3NpdGlvbigpO1xuXG4gICAgdmFyIHNlbGVjdG9yID0gbmV3IF9zZWxlY3RvcltcImRlZmF1bHRcIl0oe1xuICAgICAgc291cmNlOiB7XG4gICAgICAgIHN0YXJ0OiB0b2tlblN0YXJ0KHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gKyAxXSlcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmN1cnJlbnQucGFyZW50LmFwcGVuZChzZWxlY3Rvcik7XG4gICAgdGhpcy5jdXJyZW50ID0gc2VsZWN0b3I7XG4gICAgdGhpcy5wb3NpdGlvbisrO1xuICB9O1xuXG4gIF9wcm90by5jb21tZW50ID0gZnVuY3Rpb24gY29tbWVudCgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VyclRva2VuO1xuICAgIHRoaXMubmV3Tm9kZShuZXcgX2NvbW1lbnRbXCJkZWZhdWx0XCJdKHtcbiAgICAgIHZhbHVlOiB0aGlzLmNvbnRlbnQoKSxcbiAgICAgIHNvdXJjZTogZ2V0VG9rZW5Tb3VyY2UoY3VycmVudCksXG4gICAgICBzb3VyY2VJbmRleDogY3VycmVudFtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cbiAgICB9KSk7XG4gICAgdGhpcy5wb3NpdGlvbisrO1xuICB9O1xuXG4gIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIG9wdHMpIHtcbiAgICB0aHJvdyB0aGlzLnJvb3QuZXJyb3IobWVzc2FnZSwgb3B0cyk7XG4gIH07XG5cbiAgX3Byb3RvLm1pc3NpbmdCYWNrc2xhc2ggPSBmdW5jdGlvbiBtaXNzaW5nQmFja3NsYXNoKCkge1xuICAgIHJldHVybiB0aGlzLmVycm9yKCdFeHBlY3RlZCBhIGJhY2tzbGFzaCBwcmVjZWRpbmcgdGhlIHNlbWljb2xvbi4nLCB7XG4gICAgICBpbmRleDogdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pc3NpbmdQYXJlbnRoZXNpcyA9IGZ1bmN0aW9uIG1pc3NpbmdQYXJlbnRoZXNpcygpIHtcbiAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnb3BlbmluZyBwYXJlbnRoZXNpcycsIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pc3NpbmdTcXVhcmVCcmFja2V0ID0gZnVuY3Rpb24gbWlzc2luZ1NxdWFyZUJyYWNrZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoJ29wZW5pbmcgc3F1YXJlIGJyYWNrZXQnLCB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10pO1xuICB9O1xuXG4gIF9wcm90by51bmV4cGVjdGVkID0gZnVuY3Rpb24gdW5leHBlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgJ1wiICsgdGhpcy5jb250ZW50KCkgKyBcIicuIEVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyB3aXRoIFxcXFwgbWF5IGhlbHAuXCIsIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSk7XG4gIH07XG5cbiAgX3Byb3RvLm5hbWVzcGFjZSA9IGZ1bmN0aW9uIG5hbWVzcGFjZSgpIHtcbiAgICB2YXIgYmVmb3JlID0gdGhpcy5wcmV2VG9rZW4gJiYgdGhpcy5jb250ZW50KHRoaXMucHJldlRva2VuKSB8fCB0cnVlO1xuXG4gICAgaWYgKHRoaXMubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy53b3JkKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdGhpcy53b3JkKGJlZm9yZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHRUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuYXN0ZXJpc2spIHtcbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0aGlzLnVuaXZlcnNhbChiZWZvcmUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubmVzdGluZyA9IGZ1bmN0aW9uIG5lc3RpbmcoKSB7XG4gICAgaWYgKHRoaXMubmV4dFRva2VuKSB7XG4gICAgICB2YXIgbmV4dENvbnRlbnQgPSB0aGlzLmNvbnRlbnQodGhpcy5uZXh0VG9rZW4pO1xuXG4gICAgICBpZiAobmV4dENvbnRlbnQgPT09IFwifFwiKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyVG9rZW47XG4gICAgdGhpcy5uZXdOb2RlKG5ldyBfbmVzdGluZ1tcImRlZmF1bHRcIl0oe1xuICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZShjdXJyZW50KSxcbiAgICAgIHNvdXJjZUluZGV4OiBjdXJyZW50W190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuICAgIH0pKTtcbiAgICB0aGlzLnBvc2l0aW9uKys7XG4gIH07XG5cbiAgX3Byb3RvLnBhcmVudGhlc2VzID0gZnVuY3Rpb24gcGFyZW50aGVzZXMoKSB7XG4gICAgdmFyIGxhc3QgPSB0aGlzLmN1cnJlbnQubGFzdDtcbiAgICB2YXIgdW5iYWxhbmNlZCA9IDE7XG4gICAgdGhpcy5wb3NpdGlvbisrO1xuXG4gICAgaWYgKGxhc3QgJiYgbGFzdC50eXBlID09PSB0eXBlcy5QU0VVRE8pIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IG5ldyBfc2VsZWN0b3JbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgc3RhcnQ6IHRva2VuU3RhcnQodGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiAtIDFdKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuY3VycmVudDtcbiAgICAgIGxhc3QuYXBwZW5kKHNlbGVjdG9yKTtcbiAgICAgIHRoaXMuY3VycmVudCA9IHNlbGVjdG9yO1xuXG4gICAgICB3aGlsZSAodGhpcy5wb3NpdGlvbiA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiB1bmJhbGFuY2VkKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMub3BlblBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgdW5iYWxhbmNlZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jbG9zZVBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgdW5iYWxhbmNlZC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuYmFsYW5jZWQpIHtcbiAgICAgICAgICB0aGlzLnBhcnNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0b2tlbkVuZCh0aGlzLmN1cnJUb2tlbik7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnBhcmVudC5zb3VyY2UuZW5kID0gdG9rZW5FbmQodGhpcy5jdXJyVG9rZW4pO1xuICAgICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnQgPSBjYWNoZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSSB0aGluayB0aGlzIGNhc2Ugc2hvdWxkIGJlIGFuIGVycm9yLiBJdCdzIHVzZWQgdG8gaW1wbGVtZW50IGEgYmFzaWMgcGFyc2Ugb2YgbWVkaWEgcXVlcmllc1xuICAgICAgLy8gYnV0IEkgZG9uJ3QgdGhpbmsgaXQncyBhIGdvb2QgaWRlYS5cbiAgICAgIHZhciBwYXJlblN0YXJ0ID0gdGhpcy5jdXJyVG9rZW47XG4gICAgICB2YXIgcGFyZW5WYWx1ZSA9IFwiKFwiO1xuICAgICAgdmFyIHBhcmVuRW5kO1xuXG4gICAgICB3aGlsZSAodGhpcy5wb3NpdGlvbiA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiB1bmJhbGFuY2VkKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMub3BlblBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgdW5iYWxhbmNlZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jbG9zZVBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgdW5iYWxhbmNlZC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW5FbmQgPSB0aGlzLmN1cnJUb2tlbjtcbiAgICAgICAgcGFyZW5WYWx1ZSArPSB0aGlzLnBhcnNlUGFyZW50aGVzaXNUb2tlbih0aGlzLmN1cnJUb2tlbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgbGFzdC5hcHBlbmRUb1Byb3BlcnR5QW5kRXNjYXBlKFwidmFsdWVcIiwgcGFyZW5WYWx1ZSwgcGFyZW5WYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5ld05vZGUobmV3IF9zdHJpbmdbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgICB2YWx1ZTogcGFyZW5WYWx1ZSxcbiAgICAgICAgICBzb3VyY2U6IGdldFNvdXJjZShwYXJlblN0YXJ0W190b2tlbml6ZS5GSUVMRFMuU1RBUlRfTElORV0sIHBhcmVuU3RhcnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9DT0xdLCBwYXJlbkVuZFtfdG9rZW5pemUuRklFTERTLkVORF9MSU5FXSwgcGFyZW5FbmRbX3Rva2VuaXplLkZJRUxEUy5FTkRfQ09MXSksXG4gICAgICAgICAgc291cmNlSW5kZXg6IHBhcmVuU3RhcnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodW5iYWxhbmNlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoJ2Nsb3NpbmcgcGFyZW50aGVzaXMnLCB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucHNldWRvID0gZnVuY3Rpb24gcHNldWRvKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIHBzZXVkb1N0ciA9ICcnO1xuICAgIHZhciBzdGFydGluZ1Rva2VuID0gdGhpcy5jdXJyVG9rZW47XG5cbiAgICB3aGlsZSAodGhpcy5jdXJyVG9rZW4gJiYgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNvbG9uKSB7XG4gICAgICBwc2V1ZG9TdHIgKz0gdGhpcy5jb250ZW50KCk7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmN1cnJUb2tlbikge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoWydwc2V1ZG8tY2xhc3MnLCAncHNldWRvLWVsZW1lbnQnXSwgdGhpcy5wb3NpdGlvbiAtIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMud29yZCkge1xuICAgICAgdGhpcy5zcGxpdFdvcmQoZmFsc2UsIGZ1bmN0aW9uIChmaXJzdCwgbGVuZ3RoKSB7XG4gICAgICAgIHBzZXVkb1N0ciArPSBmaXJzdDtcblxuICAgICAgICBfdGhpczQubmV3Tm9kZShuZXcgX3BzZXVkb1tcImRlZmF1bHRcIl0oe1xuICAgICAgICAgIHZhbHVlOiBwc2V1ZG9TdHIsXG4gICAgICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZVNwYW4oc3RhcnRpbmdUb2tlbiwgX3RoaXM0LmN1cnJUb2tlbiksXG4gICAgICAgICAgc291cmNlSW5kZXg6IHN0YXJ0aW5nVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiBfdGhpczQubmV4dFRva2VuICYmIF90aGlzNC5uZXh0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLm9wZW5QYXJlbnRoZXNpcykge1xuICAgICAgICAgIF90aGlzNC5lcnJvcignTWlzcGxhY2VkIHBhcmVudGhlc2lzLicsIHtcbiAgICAgICAgICAgIGluZGV4OiBfdGhpczQubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoWydwc2V1ZG8tY2xhc3MnLCAncHNldWRvLWVsZW1lbnQnXSwgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNwYWNlID0gZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQoKTsgLy8gSGFuZGxlIHNwYWNlIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHNlbGVjdG9yXG5cbiAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gMCB8fCB0aGlzLnByZXZUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuY29tbWEgfHwgdGhpcy5wcmV2VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLm9wZW5QYXJlbnRoZXNpcyB8fCB0aGlzLmN1cnJlbnQubm9kZXMuZXZlcnkoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjb21tZW50JztcbiAgICB9KSkge1xuICAgICAgdGhpcy5zcGFjZXMgPSB0aGlzLm9wdGlvbmFsU3BhY2UoY29udGVudCk7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvc2l0aW9uID09PSB0aGlzLnRva2Vucy5sZW5ndGggLSAxIHx8IHRoaXMubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21tYSB8fCB0aGlzLm5leHRUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuY2xvc2VQYXJlbnRoZXNpcykge1xuICAgICAgdGhpcy5jdXJyZW50Lmxhc3Quc3BhY2VzLmFmdGVyID0gdGhpcy5vcHRpb25hbFNwYWNlKGNvbnRlbnQpO1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbWJpbmF0b3IoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VyclRva2VuO1xuICAgIHRoaXMubmV3Tm9kZShuZXcgX3N0cmluZ1tcImRlZmF1bHRcIl0oe1xuICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZShjdXJyZW50KSxcbiAgICAgIHNvdXJjZUluZGV4OiBjdXJyZW50W190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuICAgIH0pKTtcbiAgICB0aGlzLnBvc2l0aW9uKys7XG4gIH07XG5cbiAgX3Byb3RvLnVuaXZlcnNhbCA9IGZ1bmN0aW9uIHVuaXZlcnNhbChuYW1lc3BhY2UpIHtcbiAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG5cbiAgICBpZiAobmV4dFRva2VuICYmIHRoaXMuY29udGVudChuZXh0VG9rZW4pID09PSAnfCcpIHtcbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZSgpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyVG9rZW47XG4gICAgdGhpcy5uZXdOb2RlKG5ldyBfdW5pdmVyc2FsW1wiZGVmYXVsdFwiXSh7XG4gICAgICB2YWx1ZTogdGhpcy5jb250ZW50KCksXG4gICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlKGN1cnJlbnQpLFxuICAgICAgc291cmNlSW5kZXg6IGN1cnJlbnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgfSksIG5hbWVzcGFjZSk7XG4gICAgdGhpcy5wb3NpdGlvbisrO1xuICB9O1xuXG4gIF9wcm90by5zcGxpdFdvcmQgPSBmdW5jdGlvbiBzcGxpdFdvcmQobmFtZXNwYWNlLCBmaXJzdENhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgdmFyIHdvcmQgPSB0aGlzLmNvbnRlbnQoKTtcblxuICAgIHdoaWxlIChuZXh0VG9rZW4gJiYgflt0b2tlbnMuZG9sbGFyLCB0b2tlbnMuY2FyZXQsIHRva2Vucy5lcXVhbHMsIHRva2Vucy53b3JkXS5pbmRleE9mKG5leHRUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdKSkge1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmNvbnRlbnQoKTtcbiAgICAgIHdvcmQgKz0gY3VycmVudDtcblxuICAgICAgaWYgKGN1cnJlbnQubGFzdEluZGV4T2YoJ1xcXFwnKSA9PT0gY3VycmVudC5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0VG9rZW47XG5cbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuc3BhY2UpIHtcbiAgICAgICAgICB3b3JkICs9IHRoaXMucmVxdWlyZWRTcGFjZSh0aGlzLmNvbnRlbnQobmV4dCkpO1xuICAgICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB9XG5cbiAgICB2YXIgaGFzQ2xhc3MgPSBpbmRleGVzT2Yod29yZCwgJy4nKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIC8vIEFsbG93IGVzY2FwZWQgZG90IHdpdGhpbiBjbGFzcyBuYW1lXG4gICAgICB2YXIgZXNjYXBlZERvdCA9IHdvcmRbaSAtIDFdID09PSAnXFxcXCc7IC8vIEFsbG93IGRlY2ltYWwgbnVtYmVycyBwZXJjZW50IGluIEBrZXlmcmFtZXNcblxuICAgICAgdmFyIGlzS2V5ZnJhbWVzUGVyY2VudCA9IC9eXFxkK1xcLlxcZCslJC8udGVzdCh3b3JkKTtcbiAgICAgIHJldHVybiAhZXNjYXBlZERvdCAmJiAhaXNLZXlmcmFtZXNQZXJjZW50O1xuICAgIH0pO1xuICAgIHZhciBoYXNJZCA9IGluZGV4ZXNPZih3b3JkLCAnIycpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIHdvcmRbaSAtIDFdICE9PSAnXFxcXCc7XG4gICAgfSk7IC8vIEVsaW1pbmF0ZSBTYXNzIGludGVycG9sYXRpb25zIGZyb20gdGhlIGxpc3Qgb2YgaWQgaW5kZXhlc1xuXG4gICAgdmFyIGludGVycG9sYXRpb25zID0gaW5kZXhlc09mKHdvcmQsICcjeycpO1xuXG4gICAgaWYgKGludGVycG9sYXRpb25zLmxlbmd0aCkge1xuICAgICAgaGFzSWQgPSBoYXNJZC5maWx0ZXIoZnVuY3Rpb24gKGhhc2hJbmRleCkge1xuICAgICAgICByZXR1cm4gIX5pbnRlcnBvbGF0aW9ucy5pbmRleE9mKGhhc2hJbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICgwLCBfc29ydEFzY2VuZGluZ1tcImRlZmF1bHRcIl0pKHVuaXFzKFswXS5jb25jYXQoaGFzQ2xhc3MsIGhhc0lkKSkpO1xuICAgIGluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5kLCBpKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRpY2VzW2kgKyAxXSB8fCB3b3JkLmxlbmd0aDtcbiAgICAgIHZhciB2YWx1ZSA9IHdvcmQuc2xpY2UoaW5kLCBpbmRleCk7XG5cbiAgICAgIGlmIChpID09PSAwICYmIGZpcnN0Q2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2FsbGJhY2suY2FsbChfdGhpczUsIHZhbHVlLCBpbmRpY2VzLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlO1xuICAgICAgdmFyIGN1cnJlbnQgPSBfdGhpczUuY3VyclRva2VuO1xuICAgICAgdmFyIHNvdXJjZUluZGV4ID0gY3VycmVudFtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10gKyBpbmRpY2VzW2ldO1xuICAgICAgdmFyIHNvdXJjZSA9IGdldFNvdXJjZShjdXJyZW50WzFdLCBjdXJyZW50WzJdICsgaW5kLCBjdXJyZW50WzNdLCBjdXJyZW50WzJdICsgKGluZGV4IC0gMSkpO1xuXG4gICAgICBpZiAofmhhc0NsYXNzLmluZGV4T2YoaW5kKSkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lT3B0cyA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUuc2xpY2UoMSksXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgc291cmNlSW5kZXg6IHNvdXJjZUluZGV4XG4gICAgICAgIH07XG4gICAgICAgIG5vZGUgPSBuZXcgX2NsYXNzTmFtZVtcImRlZmF1bHRcIl0odW5lc2NhcGVQcm9wKGNsYXNzTmFtZU9wdHMsIFwidmFsdWVcIikpO1xuICAgICAgfSBlbHNlIGlmICh+aGFzSWQuaW5kZXhPZihpbmQpKSB7XG4gICAgICAgIHZhciBpZE9wdHMgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLnNsaWNlKDEpLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHNvdXJjZUluZGV4OiBzb3VyY2VJbmRleFxuICAgICAgICB9O1xuICAgICAgICBub2RlID0gbmV3IF9pZFtcImRlZmF1bHRcIl0odW5lc2NhcGVQcm9wKGlkT3B0cywgXCJ2YWx1ZVwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnT3B0cyA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgc291cmNlSW5kZXg6IHNvdXJjZUluZGV4XG4gICAgICAgIH07XG4gICAgICAgIHVuZXNjYXBlUHJvcCh0YWdPcHRzLCBcInZhbHVlXCIpO1xuICAgICAgICBub2RlID0gbmV3IF90YWdbXCJkZWZhdWx0XCJdKHRhZ09wdHMpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczUubmV3Tm9kZShub2RlLCBuYW1lc3BhY2UpOyAvLyBFbnN1cmUgdGhhdCB0aGUgbmFtZXNwYWNlIGlzIHVzZWQgb25seSBvbmNlXG5cblxuICAgICAgbmFtZXNwYWNlID0gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLnBvc2l0aW9uKys7XG4gIH07XG5cbiAgX3Byb3RvLndvcmQgPSBmdW5jdGlvbiB3b3JkKG5hbWVzcGFjZSkge1xuICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcblxuICAgIGlmIChuZXh0VG9rZW4gJiYgdGhpcy5jb250ZW50KG5leHRUb2tlbikgPT09ICd8Jykge1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3BsaXRXb3JkKG5hbWVzcGFjZSk7XG4gIH07XG5cbiAgX3Byb3RvLmxvb3AgPSBmdW5jdGlvbiBsb29wKCkge1xuICAgIHdoaWxlICh0aGlzLnBvc2l0aW9uIDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnBhcnNlKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudC5faW5mZXJFbmRQb3NpdGlvbigpO1xuXG4gICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0aHJvd09uUGFyZW50aGVzaXMpIHtcbiAgICBzd2l0Y2ggKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0pIHtcbiAgICAgIGNhc2UgdG9rZW5zLnNwYWNlOlxuICAgICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRva2Vucy5jb21tZW50OlxuICAgICAgICB0aGlzLmNvbW1lbnQoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdG9rZW5zLm9wZW5QYXJlbnRoZXNpczpcbiAgICAgICAgdGhpcy5wYXJlbnRoZXNlcygpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0b2tlbnMuY2xvc2VQYXJlbnRoZXNpczpcbiAgICAgICAgaWYgKHRocm93T25QYXJlbnRoZXNpcykge1xuICAgICAgICAgIHRoaXMubWlzc2luZ1BhcmVudGhlc2lzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0b2tlbnMub3BlblNxdWFyZTpcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdG9rZW5zLmRvbGxhcjpcbiAgICAgIGNhc2UgdG9rZW5zLmNhcmV0OlxuICAgICAgY2FzZSB0b2tlbnMuZXF1YWxzOlxuICAgICAgY2FzZSB0b2tlbnMud29yZDpcbiAgICAgICAgdGhpcy53b3JkKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRva2Vucy5jb2xvbjpcbiAgICAgICAgdGhpcy5wc2V1ZG8oKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdG9rZW5zLmNvbW1hOlxuICAgICAgICB0aGlzLmNvbW1hKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRva2Vucy5hc3RlcmlzazpcbiAgICAgICAgdGhpcy51bml2ZXJzYWwoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdG9rZW5zLmFtcGVyc2FuZDpcbiAgICAgICAgdGhpcy5uZXN0aW5nKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRva2Vucy5zbGFzaDpcbiAgICAgIGNhc2UgdG9rZW5zLmNvbWJpbmF0b3I6XG4gICAgICAgIHRoaXMuY29tYmluYXRvcigpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0b2tlbnMuc3RyOlxuICAgICAgICB0aGlzLnN0cmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFRoZXNlIGNhc2VzIHRocm93OyBubyBicmVhayBuZWVkZWQuXG5cbiAgICAgIGNhc2UgdG9rZW5zLmNsb3NlU3F1YXJlOlxuICAgICAgICB0aGlzLm1pc3NpbmdTcXVhcmVCcmFja2V0KCk7XG5cbiAgICAgIGNhc2UgdG9rZW5zLnNlbWljb2xvbjpcbiAgICAgICAgdGhpcy5taXNzaW5nQmFja3NsYXNoKCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGVscGVyc1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5leHBlY3RlZCA9IGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uLCBpbmRleCwgZm91bmQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZXNjcmlwdGlvbikpIHtcbiAgICAgIHZhciBsYXN0ID0gZGVzY3JpcHRpb24ucG9wKCk7XG4gICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLmpvaW4oJywgJykgKyBcIiBvciBcIiArIGxhc3Q7XG4gICAgfVxuXG4gICAgdmFyIGFuID0gL15bYWVpb3VdLy50ZXN0KGRlc2NyaXB0aW9uWzBdKSA/ICdhbicgOiAnYSc7XG5cbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcihcIkV4cGVjdGVkIFwiICsgYW4gKyBcIiBcIiArIGRlc2NyaXB0aW9uICsgXCIuXCIsIHtcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lcnJvcihcIkV4cGVjdGVkIFwiICsgYW4gKyBcIiBcIiArIGRlc2NyaXB0aW9uICsgXCIsIGZvdW5kIFxcXCJcIiArIGZvdW5kICsgXCJcXFwiIGluc3RlYWQuXCIsIHtcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZXF1aXJlZFNwYWNlID0gZnVuY3Rpb24gcmVxdWlyZWRTcGFjZShzcGFjZSkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubG9zc3kgPyAnICcgOiBzcGFjZTtcbiAgfTtcblxuICBfcHJvdG8ub3B0aW9uYWxTcGFjZSA9IGZ1bmN0aW9uIG9wdGlvbmFsU3BhY2Uoc3BhY2UpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxvc3N5ID8gJycgOiBzcGFjZTtcbiAgfTtcblxuICBfcHJvdG8ubG9zc3lTcGFjZSA9IGZ1bmN0aW9uIGxvc3N5U3BhY2Uoc3BhY2UsIHJlcXVpcmVkKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb3NzeSkge1xuICAgICAgcmV0dXJuIHJlcXVpcmVkID8gJyAnIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzcGFjZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlUGFyZW50aGVzaXNUb2tlbiA9IGZ1bmN0aW9uIHBhcnNlUGFyZW50aGVzaXNUb2tlbih0b2tlbikge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50KHRva2VuKTtcblxuICAgIGlmICh0b2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuc3BhY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVkU3BhY2UoY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubmV3Tm9kZSA9IGZ1bmN0aW9uIG5ld05vZGUobm9kZSwgbmFtZXNwYWNlKSB7XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgaWYgKC9eICskLy50ZXN0KG5hbWVzcGFjZSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubG9zc3kpIHtcbiAgICAgICAgICB0aGlzLnNwYWNlcyA9ICh0aGlzLnNwYWNlcyB8fCAnJykgKyBuYW1lc3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lc3BhY2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBub2RlLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgIHVuZXNjYXBlUHJvcChub2RlLCBcIm5hbWVzcGFjZVwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zcGFjZXMpIHtcbiAgICAgIG5vZGUuc3BhY2VzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuICAgICAgdGhpcy5zcGFjZXMgPSAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50LmFwcGVuZChub2RlKTtcbiAgfTtcblxuICBfcHJvdG8uY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQodG9rZW4pIHtcbiAgICBpZiAodG9rZW4gPT09IHZvaWQgMCkge1xuICAgICAgdG9rZW4gPSB0aGlzLmN1cnJUb2tlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jc3Muc2xpY2UodG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLCB0b2tlbltfdG9rZW5pemUuRklFTERTLkVORF9QT1NdKTtcbiAgfTtcblxuICAvKipcbiAgICogcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG5leHQgbm9uLXdoaXRlc3BhY2UsIG5vbi1jb21tZW50IHRva2VuLlxuICAgKiByZXR1cm5zIC0xIGlmIG5vIG1lYW5pbmdmdWwgdG9rZW4gaXMgZm91bmQuXG4gICAqL1xuICBfcHJvdG8ubG9jYXRlTmV4dE1lYW5pbmdmdWxUb2tlbiA9IGZ1bmN0aW9uIGxvY2F0ZU5leHRNZWFuaW5nZnVsVG9rZW4oc3RhcnRQb3NpdGlvbikge1xuICAgIGlmIChzdGFydFBvc2l0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uICsgMTtcbiAgICB9XG5cbiAgICB2YXIgc2VhcmNoUG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKHNlYXJjaFBvc2l0aW9uIDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICBpZiAoV0hJVEVTUEFDRV9FUVVJVl9UT0tFTlNbdGhpcy50b2tlbnNbc2VhcmNoUG9zaXRpb25dW190b2tlbml6ZS5GSUVMRFMuVFlQRV1dKSB7XG4gICAgICAgIHNlYXJjaFBvc2l0aW9uKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlYXJjaFBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoUGFyc2VyLCBbe1xuICAgIGtleTogXCJjdXJyVG9rZW5cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dFRva2VuXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmV2VG9rZW5cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uIC0gMV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhcnNlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQYXJzZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3BhcnNlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFyc2VyXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBQcm9jZXNzb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9jZXNzb3IoZnVuYywgb3B0aW9ucykge1xuICAgIHRoaXMuZnVuYyA9IGZ1bmMgfHwgZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4gICAgdGhpcy5mdW5jUmVzID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFByb2Nlc3Nvci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9zaG91bGRVcGRhdGVTZWxlY3RvciA9IGZ1bmN0aW9uIF9zaG91bGRVcGRhdGVTZWxlY3RvcihydWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG1lcmdlZC51cGRhdGVTZWxlY3RvciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHR5cGVvZiBydWxlICE9PSBcInN0cmluZ1wiO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2lzTG9zc3kgPSBmdW5jdGlvbiBfaXNMb3NzeShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG1lcmdlZC5sb3NzbGVzcyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcm9vdCA9IGZ1bmN0aW9uIF9yb290KHJ1bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IG5ldyBfcGFyc2VyW1wiZGVmYXVsdFwiXShydWxlLCB0aGlzLl9wYXJzZU9wdGlvbnMob3B0aW9ucykpO1xuICAgIHJldHVybiBwYXJzZXIucm9vdDtcbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIF9wYXJzZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBsb3NzeTogdGhpcy5faXNMb3NzeShvcHRpb25zKVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLl9ydW4gPSBmdW5jdGlvbiBfcnVuKHJ1bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcm9vdCA9IF90aGlzLl9yb290KHJ1bGUsIG9wdGlvbnMpO1xuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZShfdGhpcy5mdW5jKHJvb3QpKS50aGVuKGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB2YXIgc3RyaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKF90aGlzLl9zaG91bGRVcGRhdGVTZWxlY3RvcihydWxlLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgc3RyaW5nID0gcm9vdC50b1N0cmluZygpO1xuICAgICAgICAgICAgcnVsZS5zZWxlY3RvciA9IHN0cmluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgICB9O1xuICAgICAgICB9KS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fcnVuU3luYyA9IGZ1bmN0aW9uIF9ydW5TeW5jKHJ1bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLl9yb290KHJ1bGUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuZnVuYyhyb290KTtcblxuICAgIGlmICh0cmFuc2Zvcm0gJiYgdHlwZW9mIHRyYW5zZm9ybS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdG9yIHByb2Nlc3NvciByZXR1cm5lZCBhIHByb21pc2UgdG8gYSBzeW5jaHJvbm91cyBjYWxsLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKG9wdGlvbnMudXBkYXRlU2VsZWN0b3IgJiYgdHlwZW9mIHJ1bGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN0cmluZyA9IHJvb3QudG9TdHJpbmcoKTtcbiAgICAgIHJ1bGUuc2VsZWN0b3IgPSBzdHJpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBydWxlIGludG8gYSBzZWxlY3RvciBBU1QuXG4gICAqXG4gICAqIEBwYXJhbSBydWxlIHtwb3N0Y3NzLlJ1bGUgfCBzdHJpbmd9IFRoZSBjc3Mgc2VsZWN0b3IgdG8gYmUgcHJvY2Vzc2VkXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBwcm9jZXNzaW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHBhcnNlci5Sb290Pn0gVGhlIEFTVCBvZiB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZyBpdC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYXN0ID0gZnVuY3Rpb24gYXN0KHJ1bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVuKHJ1bGUsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5yb290O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIHJ1bGUgaW50byBhIHNlbGVjdG9yIEFTVCBzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gcnVsZSB7cG9zdGNzcy5SdWxlIHwgc3RyaW5nfSBUaGUgY3NzIHNlbGVjdG9yIHRvIGJlIHByb2Nlc3NlZFxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuICAgKiBAcmV0dXJucyB7cGFyc2VyLlJvb3R9IFRoZSBBU1Qgb2YgdGhlIHNlbGVjdG9yIGFmdGVyIHByb2Nlc3NpbmcgaXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFzdFN5bmMgPSBmdW5jdGlvbiBhc3RTeW5jKHJ1bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVuU3luYyhydWxlLCBvcHRpb25zKS5yb290O1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIGEgc2VsZWN0b3IgaW50byBhIHRyYW5zZm9ybWVkIHZhbHVlIGFzeW5jaHJvbm91c2x5XG4gICAqXG4gICAqIEBwYXJhbSBydWxlIHtwb3N0Y3NzLlJ1bGUgfCBzdHJpbmd9IFRoZSBjc3Mgc2VsZWN0b3IgdG8gYmUgcHJvY2Vzc2VkXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBwcm9jZXNzaW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgcHJvY2Vzc29yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0ocnVsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9ydW4ocnVsZSwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRyYW5zZm9ybTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBhIHNlbGVjdG9yIGludG8gYSB0cmFuc2Zvcm1lZCB2YWx1ZSBzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gcnVsZSB7cG9zdGNzcy5SdWxlIHwgc3RyaW5nfSBUaGUgY3NzIHNlbGVjdG9yIHRvIGJlIHByb2Nlc3NlZFxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIHByb2Nlc3Nvci5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udHJhbnNmb3JtU3luYyA9IGZ1bmN0aW9uIHRyYW5zZm9ybVN5bmMocnVsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9ydW5TeW5jKHJ1bGUsIG9wdGlvbnMpLnRyYW5zZm9ybTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBhIHNlbGVjdG9yIGludG8gYSBuZXcgc2VsZWN0b3Igc3RyaW5nIGFzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gcnVsZSB7cG9zdGNzcy5SdWxlIHwgc3RyaW5nfSBUaGUgY3NzIHNlbGVjdG9yIHRvIGJlIHByb2Nlc3NlZFxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MocnVsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9ydW4ocnVsZSwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnN0cmluZyB8fCByZXN1bHQucm9vdC50b1N0cmluZygpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIGEgc2VsZWN0b3IgaW50byBhIG5ldyBzZWxlY3RvciBzdHJpbmcgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHByb2Nlc3NpbmdcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHNlbGVjdG9yIGFmdGVyIHByb2Nlc3NpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnByb2Nlc3NTeW5jID0gZnVuY3Rpb24gcHJvY2Vzc1N5bmMocnVsZSwgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLl9ydW5TeW5jKHJ1bGUsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5zdHJpbmcgfHwgcmVzdWx0LnJvb3QudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gUHJvY2Vzc29yO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFByb2Nlc3Nvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bmVzY2FwZVZhbHVlID0gdW5lc2NhcGVWYWx1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2Nzc2VzYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNzc2VzY1wiKSk7XG5cbnZhciBfdW5lc2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsL3VuZXNjXCIpKTtcblxudmFyIF9uYW1lc3BhY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxudmFyIF9DU1NFU0NfUVVPVEVfT1BUSU9OUztcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKFwidXRpbC1kZXByZWNhdGVcIik7XG5cbnZhciBXUkFQUEVEX0lOX1FVT1RFUyA9IC9eKCd8XCIpKFteXSopXFwxJC87XG52YXIgd2Fybk9mRGVwcmVjYXRlZFZhbHVlQXNzaWdubWVudCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7fSwgXCJBc3NpZ25pbmcgYW4gYXR0cmlidXRlIGEgdmFsdWUgY29udGFpbmluZyBjaGFyYWN0ZXJzIHRoYXQgbWlnaHQgbmVlZCB0byBiZSBlc2NhcGVkIGlzIGRlcHJlY2F0ZWQuIFwiICsgXCJDYWxsIGF0dHJpYnV0ZS5zZXRWYWx1ZSgpIGluc3RlYWQuXCIpO1xudmFyIHdhcm5PZkRlcHJlY2F0ZWRRdW90ZWRBc3NpZ25tZW50ID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHt9LCBcIkFzc2lnbmluZyBhdHRyLnF1b3RlZCBpcyBkZXByZWNhdGVkIGFuZCBoYXMgbm8gZWZmZWN0LiBBc3NpZ24gdG8gYXR0ci5xdW90ZU1hcmsgaW5zdGVhZC5cIik7XG52YXIgd2Fybk9mRGVwcmVjYXRlZENvbnN0cnVjdG9yID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHt9LCBcIkNvbnN0cnVjdGluZyBhbiBBdHRyaWJ1dGUgc2VsZWN0b3Igd2l0aCBhIHZhbHVlIHdpdGhvdXQgc3BlY2lmeWluZyBxdW90ZU1hcmsgaXMgZGVwcmVjYXRlZC4gTm90ZTogVGhlIHZhbHVlIHNob3VsZCBiZSB1bmVzY2FwZWQgbm93LlwiKTtcblxuZnVuY3Rpb24gdW5lc2NhcGVWYWx1ZSh2YWx1ZSkge1xuICB2YXIgZGVwcmVjYXRlZFVzYWdlID0gZmFsc2U7XG4gIHZhciBxdW90ZU1hcmsgPSBudWxsO1xuICB2YXIgdW5lc2NhcGVkID0gdmFsdWU7XG4gIHZhciBtID0gdW5lc2NhcGVkLm1hdGNoKFdSQVBQRURfSU5fUVVPVEVTKTtcblxuICBpZiAobSkge1xuICAgIHF1b3RlTWFyayA9IG1bMV07XG4gICAgdW5lc2NhcGVkID0gbVsyXTtcbiAgfVxuXG4gIHVuZXNjYXBlZCA9ICgwLCBfdW5lc2NbXCJkZWZhdWx0XCJdKSh1bmVzY2FwZWQpO1xuXG4gIGlmICh1bmVzY2FwZWQgIT09IHZhbHVlKSB7XG4gICAgZGVwcmVjYXRlZFVzYWdlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGVwcmVjYXRlZFVzYWdlOiBkZXByZWNhdGVkVXNhZ2UsXG4gICAgdW5lc2NhcGVkOiB1bmVzY2FwZWQsXG4gICAgcXVvdGVNYXJrOiBxdW90ZU1hcmtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRGVwcmVjYXRlZENvbnRydWN0b3JPcHRzKG9wdHMpIHtcbiAgaWYgKG9wdHMucXVvdGVNYXJrICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb3B0cztcbiAgfVxuXG4gIGlmIChvcHRzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb3B0cztcbiAgfVxuXG4gIHdhcm5PZkRlcHJlY2F0ZWRDb25zdHJ1Y3RvcigpO1xuXG4gIHZhciBfdW5lc2NhcGVWYWx1ZSA9IHVuZXNjYXBlVmFsdWUob3B0cy52YWx1ZSksXG4gICAgICBxdW90ZU1hcmsgPSBfdW5lc2NhcGVWYWx1ZS5xdW90ZU1hcmssXG4gICAgICB1bmVzY2FwZWQgPSBfdW5lc2NhcGVWYWx1ZS51bmVzY2FwZWQ7XG5cbiAgaWYgKCFvcHRzLnJhd3MpIHtcbiAgICBvcHRzLnJhd3MgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLnJhd3MudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMucmF3cy52YWx1ZSA9IG9wdHMudmFsdWU7XG4gIH1cblxuICBvcHRzLnZhbHVlID0gdW5lc2NhcGVkO1xuICBvcHRzLnF1b3RlTWFyayA9IHF1b3RlTWFyaztcbiAgcmV0dXJuIG9wdHM7XG59XG5cbnZhciBBdHRyaWJ1dGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9OYW1lc3BhY2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXR0cmlidXRlLCBfTmFtZXNwYWNlKTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9OYW1lc3BhY2UuY2FsbCh0aGlzLCBoYW5kbGVEZXByZWNhdGVkQ29udHJ1Y3Rvck9wdHMob3B0cykpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IF90eXBlcy5BVFRSSUJVVEU7XG4gICAgX3RoaXMucmF3cyA9IF90aGlzLnJhd3MgfHwge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLnJhd3MsICd1bnF1b3RlZCcsIHtcbiAgICAgIGdldDogZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnZhbHVlO1xuICAgICAgfSwgXCJhdHRyLnJhd3MudW5xdW90ZWQgaXMgZGVwcmVjYXRlZC4gQ2FsbCBhdHRyLnZhbHVlIGluc3RlYWQuXCIpLFxuICAgICAgc2V0OiBkZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudmFsdWU7XG4gICAgICB9LCBcIlNldHRpbmcgYXR0ci5yYXdzLnVucXVvdGVkIGlzIGRlcHJlY2F0ZWQgYW5kIGhhcyBubyBlZmZlY3QuIGF0dHIudmFsdWUgaXMgdW5lc2NhcGVkIGJ5IGRlZmF1bHQgbm93LlwiKVxuICAgIH0pO1xuICAgIF90aGlzLl9jb25zdHJ1Y3RlZCA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBBdHRyaWJ1dGUncyB2YWx1ZSBxdW90ZWQgc3VjaCB0aGF0IGl0IHdvdWxkIGJlIGxlZ2FsIHRvIHVzZVxuICAgKiBpbiB0aGUgdmFsdWUgb2YgYSBjc3MgZmlsZS4gVGhlIG9yaWdpbmFsIHZhbHVlJ3MgcXVvdGF0aW9uIHNldHRpbmdcbiAgICogdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uIGlzIGxlZnQgdW5jaGFuZ2VkLiBTZWUgYHNldFZhbHVlKHZhbHVlLCBvcHRpb25zKWBcbiAgICogaWYgeW91IHdhbnQgdG8gY29udHJvbCB0aGUgcXVvdGUgc2V0dGluZ3Mgb2YgYSBuZXcgdmFsdWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBjaGFuZ2UgdGhlIHF1b3RhdGlvbiB1c2VkIGZvciB0aGUgY3VycmVudCB2YWx1ZSBieSBzZXR0aW5nIHF1b3RlTWFyay5cbiAgICpcbiAgICogT3B0aW9uczpcbiAgICogICAqIHF1b3RlTWFyayB7J1wiJyB8IFwiJ1wiIHwgbnVsbH0gLSBVc2UgdGhpcyB2YWx1ZSB0byBxdW90ZSB0aGUgdmFsdWUuIElmIHRoaXNcbiAgICogICAgIG9wdGlvbiBpcyBub3Qgc2V0LCB0aGUgb3JpZ2luYWwgdmFsdWUgZm9yIHF1b3RlTWFyayB3aWxsIGJlIHVzZWQuIElmXG4gICAqICAgICBpbmRldGVybWluYXRlLCBhIGRvdWJsZSBxdW90ZSBpcyB1c2VkLiBUaGUgbGVnYWwgdmFsdWVzIGFyZTpcbiAgICogICAgICogYG51bGxgIC0gdGhlIHZhbHVlIHdpbGwgYmUgdW5xdW90ZWQgYW5kIGNoYXJhY3RlcnMgd2lsbCBiZSBlc2NhcGVkIGFzIG5lY2Vzc2FyeS5cbiAgICogICAgICogYCdgIC0gdGhlIHZhbHVlIHdpbGwgYmUgcXVvdGVkIHdpdGggYSBzaW5nbGUgcXVvdGUgYW5kIHNpbmdsZSBxdW90ZXMgYXJlIGVzY2FwZWQuXG4gICAqICAgICAqIGBcImAgLSB0aGUgdmFsdWUgd2lsbCBiZSBxdW90ZWQgd2l0aCBhIGRvdWJsZSBxdW90ZSBhbmQgZG91YmxlIHF1b3RlcyBhcmUgZXNjYXBlZC5cbiAgICogICAqIHByZWZlckN1cnJlbnRRdW90ZU1hcmsge2Jvb2xlYW59IC0gaWYgdHJ1ZSwgcHJlZmVyIHRoZSBzb3VyY2UgcXVvdGUgbWFya1xuICAgKiAgICAgb3ZlciB0aGUgcXVvdGVNYXJrIG9wdGlvbiB2YWx1ZS5cbiAgICogICAqIHNtYXJ0IHtib29sZWFufSAtIGlmIHRydWUsIHdpbGwgc2VsZWN0IGEgcXVvdGUgbWFyayBiYXNlZCBvbiB0aGUgdmFsdWVcbiAgICogICAgIGFuZCB0aGUgb3RoZXIgb3B0aW9ucyBzcGVjaWZpZWQgaGVyZS4gU2VlIHRoZSBgc21hcnRRdW90ZU1hcmsoKWBcbiAgICogICAgIG1ldGhvZC5cbiAgICoqL1xuXG5cbiAgdmFyIF9wcm90byA9IEF0dHJpYnV0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFF1b3RlZFZhbHVlID0gZnVuY3Rpb24gZ2V0UXVvdGVkVmFsdWUob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcXVvdGVNYXJrID0gdGhpcy5fZGV0ZXJtaW5lUXVvdGVNYXJrKG9wdGlvbnMpO1xuXG4gICAgdmFyIGNzc2VzY29wdHMgPSBDU1NFU0NfUVVPVEVfT1BUSU9OU1txdW90ZU1hcmtdO1xuICAgIHZhciBlc2NhcGVkID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKSh0aGlzLl92YWx1ZSwgY3NzZXNjb3B0cyk7XG4gICAgcmV0dXJuIGVzY2FwZWQ7XG4gIH07XG5cbiAgX3Byb3RvLl9kZXRlcm1pbmVRdW90ZU1hcmsgPSBmdW5jdGlvbiBfZGV0ZXJtaW5lUXVvdGVNYXJrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5zbWFydCA/IHRoaXMuc21hcnRRdW90ZU1hcmsob3B0aW9ucykgOiB0aGlzLnByZWZlcnJlZFF1b3RlTWFyayhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB1bmVzY2FwZWQgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1b3RhdGlvbiBvcHRpb25zLiBUaGUgdmFsdWVcbiAgICogcHJvdmlkZWQgbXVzdCBub3QgaW5jbHVkZSBhbnkgd3JhcHBpbmcgcXVvdGUgbWFya3MgLS0gdGhvc2UgcXVvdGVzIHdpbGxcbiAgICogYmUgaW50ZXJwcmV0ZWQgYXMgcGFydCBvZiB0aGUgdmFsdWUgYW5kIGVzY2FwZWQgYWNjb3JkaW5nbHkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9xdW90ZU1hcmsgPSB0aGlzLl9kZXRlcm1pbmVRdW90ZU1hcmsob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9zeW5jUmF3VmFsdWUoKTtcbiAgfVxuICAvKipcbiAgICogSW50ZWxsaWdlbnRseSBzZWxlY3QgYSBxdW90ZU1hcmsgdmFsdWUgYmFzZWQgb24gdGhlIHZhbHVlJ3MgY29udGVudHMuIElmXG4gICAqIHRoZSB2YWx1ZSBpcyBhIGxlZ2FsIENTUyBpZGVudCwgaXQgd2lsbCBub3QgYmUgcXVvdGVkLiBPdGhlcndpc2UgYSBxdW90ZVxuICAgKiBtYXJrIHdpbGwgYmUgcGlja2VkIHRoYXQgbWluaW1pemVzIHRoZSBudW1iZXIgb2YgZXNjYXBlcy5cbiAgICpcbiAgICogSWYgdGhlcmUncyBubyBjbGVhciB3aW5uZXIsIHRoZSBxdW90ZSBtYXJrIGZyb20gdGhlc2Ugb3B0aW9ucyBpcyB1c2VkLFxuICAgKiB0aGVuIHRoZSBzb3VyY2UgcXVvdGUgbWFyayAodGhpcyBpcyBpbnZlcnRlZCBpZiBgcHJlZmVyQ3VycmVudFF1b3RlTWFya2AgaXNcbiAgICogdHJ1ZSkuIElmIHRoZSBxdW90ZU1hcmsgaXMgdW5zcGVjaWZpZWQsIGEgZG91YmxlIHF1b3RlIGlzIHVzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoaXMgdGFrZXMgdGhlIHF1b3RlTWFyayBhbmQgcHJlZmVyQ3VycmVudFF1b3RlTWFyayBvcHRpb25zXG4gICAqIGZyb20gdGhlIHF1b3RlVmFsdWUgbWV0aG9kLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zbWFydFF1b3RlTWFyayA9IGZ1bmN0aW9uIHNtYXJ0UXVvdGVNYXJrKG9wdGlvbnMpIHtcbiAgICB2YXIgdiA9IHRoaXMudmFsdWU7XG4gICAgdmFyIG51bVNpbmdsZVF1b3RlcyA9IHYucmVwbGFjZSgvW14nXS9nLCAnJykubGVuZ3RoO1xuICAgIHZhciBudW1Eb3VibGVRdW90ZXMgPSB2LnJlcGxhY2UoL1teXCJdL2csICcnKS5sZW5ndGg7XG5cbiAgICBpZiAobnVtU2luZ2xlUXVvdGVzICsgbnVtRG91YmxlUXVvdGVzID09PSAwKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkodiwge1xuICAgICAgICBpc0lkZW50aWZpZXI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXNjYXBlZCA9PT0gdikge1xuICAgICAgICByZXR1cm4gQXR0cmlidXRlLk5PX1FVT1RFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByZWYgPSB0aGlzLnByZWZlcnJlZFF1b3RlTWFyayhvcHRpb25zKTtcblxuICAgICAgICBpZiAocHJlZiA9PT0gQXR0cmlidXRlLk5PX1FVT1RFKSB7XG4gICAgICAgICAgLy8gcGljayBhIHF1b3RlIG1hcmsgdGhhdCBpc24ndCBub25lIGFuZCBzZWUgaWYgaXQncyBzbWFsbGVyXG4gICAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5xdW90ZU1hcmsgfHwgb3B0aW9ucy5xdW90ZU1hcmsgfHwgQXR0cmlidXRlLkRPVUJMRV9RVU9URTtcbiAgICAgICAgICB2YXIgb3B0cyA9IENTU0VTQ19RVU9URV9PUFRJT05TW3F1b3RlXTtcbiAgICAgICAgICB2YXIgcXVvdGVWYWx1ZSA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkodiwgb3B0cyk7XG5cbiAgICAgICAgICBpZiAocXVvdGVWYWx1ZS5sZW5ndGggPCBlc2NhcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmVmO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnVtRG91YmxlUXVvdGVzID09PSBudW1TaW5nbGVRdW90ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWZlcnJlZFF1b3RlTWFyayhvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKG51bURvdWJsZVF1b3RlcyA8IG51bVNpbmdsZVF1b3Rlcykge1xuICAgICAgcmV0dXJuIEF0dHJpYnV0ZS5ET1VCTEVfUVVPVEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBBdHRyaWJ1dGUuU0lOR0xFX1FVT1RFO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgcHJlZmVycmVkIHF1b3RlIG1hcmsgYmFzZWQgb24gdGhlIG9wdGlvbnMgYW5kIHRoZSBjdXJyZW50IHF1b3RlIG1hcmsgdmFsdWUuXG4gICAqIElmIHlvdSB3YW50IHRoZSBxdW90ZSBtYXJrIHRvIGRlcGVuZCBvbiB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIGBzbWFydFF1b3RlTWFyayhvcHRzKWBcbiAgICogaW5zdGVhZC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHJlZmVycmVkUXVvdGVNYXJrID0gZnVuY3Rpb24gcHJlZmVycmVkUXVvdGVNYXJrKG9wdGlvbnMpIHtcbiAgICB2YXIgcXVvdGVNYXJrID0gb3B0aW9ucy5wcmVmZXJDdXJyZW50UXVvdGVNYXJrID8gdGhpcy5xdW90ZU1hcmsgOiBvcHRpb25zLnF1b3RlTWFyaztcblxuICAgIGlmIChxdW90ZU1hcmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcXVvdGVNYXJrID0gb3B0aW9ucy5wcmVmZXJDdXJyZW50UXVvdGVNYXJrID8gb3B0aW9ucy5xdW90ZU1hcmsgOiB0aGlzLnF1b3RlTWFyaztcbiAgICB9XG5cbiAgICBpZiAocXVvdGVNYXJrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHF1b3RlTWFyayA9IEF0dHJpYnV0ZS5ET1VCTEVfUVVPVEU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1b3RlTWFyaztcbiAgfTtcblxuICBfcHJvdG8uX3N5bmNSYXdWYWx1ZSA9IGZ1bmN0aW9uIF9zeW5jUmF3VmFsdWUoKSB7XG4gICAgdmFyIHJhd1ZhbHVlID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKSh0aGlzLl92YWx1ZSwgQ1NTRVNDX1FVT1RFX09QVElPTlNbdGhpcy5xdW90ZU1hcmtdKTtcblxuICAgIGlmIChyYXdWYWx1ZSA9PT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnJhd3MpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3cy52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYXdzLnZhbHVlID0gcmF3VmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRXNjYXBlcyA9IGZ1bmN0aW9uIF9oYW5kbGVFc2NhcGVzKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2NvbnN0cnVjdGVkKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkodmFsdWUsIHtcbiAgICAgICAgaXNJZGVudGlmaWVyOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGVzY2FwZWQgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3c1twcm9wXSA9IGVzY2FwZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5yYXdzW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3NwYWNlc0ZvciA9IGZ1bmN0aW9uIF9zcGFjZXNGb3IobmFtZSkge1xuICAgIHZhciBhdHRyU3BhY2VzID0ge1xuICAgICAgYmVmb3JlOiAnJyxcbiAgICAgIGFmdGVyOiAnJ1xuICAgIH07XG4gICAgdmFyIHNwYWNlcyA9IHRoaXMuc3BhY2VzW25hbWVdIHx8IHt9O1xuICAgIHZhciByYXdTcGFjZXMgPSB0aGlzLnJhd3Muc3BhY2VzICYmIHRoaXMucmF3cy5zcGFjZXNbbmFtZV0gfHwge307XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYXR0clNwYWNlcywgc3BhY2VzLCByYXdTcGFjZXMpO1xuICB9O1xuXG4gIF9wcm90by5fc3RyaW5nRm9yID0gZnVuY3Rpb24gX3N0cmluZ0ZvcihuYW1lLCBzcGFjZU5hbWUsIGNvbmNhdCkge1xuICAgIGlmIChzcGFjZU5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgc3BhY2VOYW1lID0gbmFtZTtcbiAgICB9XG5cbiAgICBpZiAoY29uY2F0ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbmNhdCA9IGRlZmF1bHRBdHRyQ29uY2F0O1xuICAgIH1cblxuICAgIHZhciBhdHRyU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKHNwYWNlTmFtZSk7XG5cbiAgICByZXR1cm4gY29uY2F0KHRoaXMuc3RyaW5naWZ5UHJvcGVydHkobmFtZSksIGF0dHJTcGFjZXMpO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBvZmZzZXQgb2YgdGhlIGF0dHJpYnV0ZSBwYXJ0IHNwZWNpZmllZCByZWxhdGl2ZSB0byB0aGVcbiAgICogc3RhcnQgb2YgdGhlIG5vZGUgb2YgdGhlIG91dHB1dCBzdHJpbmcuXG4gICAqXG4gICAqICogXCJuc1wiIC0gYWxpYXMgZm9yIFwibmFtZXNwYWNlXCJcbiAgICogKiBcIm5hbWVzcGFjZVwiIC0gdGhlIG5hbWVzcGFjZSBpZiBpdCBleGlzdHMuXG4gICAqICogXCJhdHRyaWJ1dGVcIiAtIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgKiAqIFwiYXR0cmlidXRlTlNcIiAtIHRoZSBzdGFydCBvZiB0aGUgYXR0cmlidXRlIG9yIGl0cyBuYW1lc3BhY2VcbiAgICogKiBcIm9wZXJhdG9yXCIgLSB0aGUgbWF0Y2ggb3BlcmF0b3Igb2YgdGhlIGF0dHJpYnV0ZVxuICAgKiAqIFwidmFsdWVcIiAtIFRoZSB2YWx1ZSAoc3RyaW5nIG9yIGlkZW50aWZpZXIpXG4gICAqICogXCJpbnNlbnNpdGl2ZVwiIC0gdGhlIGNhc2UgaW5zZW5zaXRpdml0eSBmbGFnO1xuICAgKiBAcGFyYW0gcGFydCBPbmUgb2YgdGhlIHBvc3NpYmxlIHZhbHVlcyBpbnNpZGUgYW4gYXR0cmlidXRlLlxuICAgKiBAcmV0dXJucyAtMSBpZiB0aGUgbmFtZSBpcyBpbnZhbGlkIG9yIHRoZSB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoaXMgYXR0cmlidXRlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vZmZzZXRPZiA9IGZ1bmN0aW9uIG9mZnNldE9mKG5hbWUpIHtcbiAgICB2YXIgY291bnQgPSAxO1xuXG4gICAgdmFyIGF0dHJpYnV0ZVNwYWNlcyA9IHRoaXMuX3NwYWNlc0ZvcihcImF0dHJpYnV0ZVwiKTtcblxuICAgIGNvdW50ICs9IGF0dHJpYnV0ZVNwYWNlcy5iZWZvcmUubGVuZ3RoO1xuXG4gICAgaWYgKG5hbWUgPT09IFwibmFtZXNwYWNlXCIgfHwgbmFtZSA9PT0gXCJuc1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2UgPyBjb3VudCA6IC0xO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBcImF0dHJpYnV0ZU5TXCIpIHtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICBjb3VudCArPSB0aGlzLm5hbWVzcGFjZVN0cmluZy5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5uYW1lc3BhY2UpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IFwiYXR0cmlidXRlXCIpIHtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICBjb3VudCArPSB0aGlzLnN0cmluZ2lmeVByb3BlcnR5KFwiYXR0cmlidXRlXCIpLmxlbmd0aDtcbiAgICBjb3VudCArPSBhdHRyaWJ1dGVTcGFjZXMuYWZ0ZXIubGVuZ3RoO1xuXG4gICAgdmFyIG9wZXJhdG9yU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKFwib3BlcmF0b3JcIik7XG5cbiAgICBjb3VudCArPSBvcGVyYXRvclNwYWNlcy5iZWZvcmUubGVuZ3RoO1xuICAgIHZhciBvcGVyYXRvciA9IHRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJvcGVyYXRvclwiKTtcblxuICAgIGlmIChuYW1lID09PSBcIm9wZXJhdG9yXCIpIHtcbiAgICAgIHJldHVybiBvcGVyYXRvciA/IGNvdW50IDogLTE7XG4gICAgfVxuXG4gICAgY291bnQgKz0gb3BlcmF0b3IubGVuZ3RoO1xuICAgIGNvdW50ICs9IG9wZXJhdG9yU3BhY2VzLmFmdGVyLmxlbmd0aDtcblxuICAgIHZhciB2YWx1ZVNwYWNlcyA9IHRoaXMuX3NwYWNlc0ZvcihcInZhbHVlXCIpO1xuXG4gICAgY291bnQgKz0gdmFsdWVTcGFjZXMuYmVmb3JlLmxlbmd0aDtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnN0cmluZ2lmeVByb3BlcnR5KFwidmFsdWVcIik7XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBjb3VudCA6IC0xO1xuICAgIH1cblxuICAgIGNvdW50ICs9IHZhbHVlLmxlbmd0aDtcbiAgICBjb3VudCArPSB2YWx1ZVNwYWNlcy5hZnRlci5sZW5ndGg7XG5cbiAgICB2YXIgaW5zZW5zaXRpdmVTcGFjZXMgPSB0aGlzLl9zcGFjZXNGb3IoXCJpbnNlbnNpdGl2ZVwiKTtcblxuICAgIGNvdW50ICs9IGluc2Vuc2l0aXZlU3BhY2VzLmJlZm9yZS5sZW5ndGg7XG5cbiAgICBpZiAobmFtZSA9PT0gXCJpbnNlbnNpdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlbnNpdGl2ZSA/IGNvdW50IDogLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHNlbGVjdG9yID0gW3RoaXMucmF3U3BhY2VCZWZvcmUsICdbJ107XG4gICAgc2VsZWN0b3IucHVzaCh0aGlzLl9zdHJpbmdGb3IoJ3F1YWxpZmllZEF0dHJpYnV0ZScsICdhdHRyaWJ1dGUnKSk7XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciAmJiAodGhpcy52YWx1ZSB8fCB0aGlzLnZhbHVlID09PSAnJykpIHtcbiAgICAgIHNlbGVjdG9yLnB1c2godGhpcy5fc3RyaW5nRm9yKCdvcGVyYXRvcicpKTtcbiAgICAgIHNlbGVjdG9yLnB1c2godGhpcy5fc3RyaW5nRm9yKCd2YWx1ZScpKTtcbiAgICAgIHNlbGVjdG9yLnB1c2godGhpcy5fc3RyaW5nRm9yKCdpbnNlbnNpdGl2ZUZsYWcnLCAnaW5zZW5zaXRpdmUnLCBmdW5jdGlvbiAoYXR0clZhbHVlLCBhdHRyU3BhY2VzKSB7XG4gICAgICAgIGlmIChhdHRyVmFsdWUubGVuZ3RoID4gMCAmJiAhX3RoaXMyLnF1b3RlZCAmJiBhdHRyU3BhY2VzLmJlZm9yZS5sZW5ndGggPT09IDAgJiYgIShfdGhpczIuc3BhY2VzLnZhbHVlICYmIF90aGlzMi5zcGFjZXMudmFsdWUuYWZ0ZXIpKSB7XG4gICAgICAgICAgYXR0clNwYWNlcy5iZWZvcmUgPSBcIiBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0QXR0ckNvbmNhdChhdHRyVmFsdWUsIGF0dHJTcGFjZXMpO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHNlbGVjdG9yLnB1c2goJ10nKTtcbiAgICBzZWxlY3Rvci5wdXNoKHRoaXMucmF3U3BhY2VBZnRlcik7XG4gICAgcmV0dXJuIHNlbGVjdG9yLmpvaW4oJycpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhBdHRyaWJ1dGUsIFt7XG4gICAga2V5OiBcInF1b3RlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHFtID0gdGhpcy5xdW90ZU1hcms7XG4gICAgICByZXR1cm4gcW0gPT09IFwiJ1wiIHx8IHFtID09PSAnXCInO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHdhcm5PZkRlcHJlY2F0ZWRRdW90ZWRBc3NpZ25tZW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBzaW5nbGUgKGAnYCkgb3IgZG91YmxlIChgXCJgKSBxdW90ZSBjaGFyYWN0ZXIgaWYgdGhlIHZhbHVlIGlzIHF1b3RlZC5cbiAgICAgKiByZXR1cm5zIGBudWxsYCBpZiB0aGUgdmFsdWUgaXMgbm90IHF1b3RlZC5cbiAgICAgKiByZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBxdW90YXRpb24gc3RhdGUgaXMgdW5rbm93biAodGhpcyBjYW4gaGFwcGVuIHdoZW5cbiAgICAgKiB0aGUgYXR0cmlidXRlIGlzIGNvbnN0cnVjdGVkIHdpdGhvdXQgc3BlY2lmeWluZyBhIHF1b3RlIG1hcmsuKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicXVvdGVNYXJrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcXVvdGVNYXJrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHF1b3RlIG1hcmsgdG8gYmUgdXNlZCBieSB0aGlzIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICAgICAqIElmIHRoZSBxdW90ZSBtYXJrIGNoYW5nZXMsIHRoZSByYXcgKGVzY2FwZWQpIHZhbHVlIGF0IGBhdHRyLnJhd3MudmFsdWVgIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKiB2YWx1ZSBpcyB1cGRhdGVkIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtcIidcIiB8ICdcIicgfCBudWxsfSBxdW90ZU1hcmsgVGhlIHF1b3RlIG1hcmsgb3IgYG51bGxgIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgdW5xdW90ZWQuXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHF1b3RlTWFyaykge1xuICAgICAgaWYgKCF0aGlzLl9jb25zdHJ1Y3RlZCkge1xuICAgICAgICB0aGlzLl9xdW90ZU1hcmsgPSBxdW90ZU1hcms7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3F1b3RlTWFyayAhPT0gcXVvdGVNYXJrKSB7XG4gICAgICAgIHRoaXMuX3F1b3RlTWFyayA9IHF1b3RlTWFyaztcblxuICAgICAgICB0aGlzLl9zeW5jUmF3VmFsdWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVhbGlmaWVkQXR0cmlidXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWFsaWZpZWROYW1lKHRoaXMucmF3cy5hdHRyaWJ1dGUgfHwgdGhpcy5hdHRyaWJ1dGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlbnNpdGl2ZUZsYWdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2Vuc2l0aXZlID8gJ2knIDogJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZm9yZSAzLjAsIHRoZSB2YWx1ZSBoYWQgdG8gYmUgc2V0IHRvIGFuIGVzY2FwZWQgdmFsdWUgaW5jbHVkaW5nIGFueSB3cmFwcGVkXG4gICAgICogcXVvdGUgbWFya3MuIEluIDMuMCwgdGhlIHNlbWFudGljcyBvZiBgQXR0cmlidXRlLnZhbHVlYCBjaGFuZ2VkIHNvIHRoYXQgdGhlIHZhbHVlXG4gICAgICogaXMgdW5lc2NhcGVkIGR1cmluZyBwYXJzaW5nIGFuZCBhbnkgcXVvdGUgbWFya3MgYXJlIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIHRoZSBhbWJpZ3VpdHkgb2YgdGhpcyBzZW1hbnRpYyBjaGFuZ2UsIGlmIHlvdSBzZXQgYGF0dHIudmFsdWUgPSBuZXdWYWx1ZWAsXG4gICAgICogYSBkZXByZWNhdGlvbiB3YXJuaW5nIGlzIHJhaXNlZCB3aGVuIHRoZSBuZXcgdmFsdWUgY29udGFpbnMgYW55IGNoYXJhY3RlcnMgdGhhdCB3b3VsZFxuICAgICAqIHJlcXVpcmUgZXNjYXBpbmcgKGluY2x1ZGluZyBpZiBpdCBjb250YWlucyB3cmFwcGVkIHF1b3RlcykuXG4gICAgICpcbiAgICAgKiBJbnN0ZWFkLCB5b3Ugc2hvdWxkIGNhbGwgYGF0dHIuc2V0VmFsdWUobmV3VmFsdWUsIG9wdHMpYCBhbmQgcGFzcyBvcHRpb25zIHRoYXQgZGVzY3JpYmVcbiAgICAgKiBob3cgdGhlIG5ldyB2YWx1ZSBpcyBxdW90ZWQuXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcbiAgICAgIGlmICh0aGlzLl9jb25zdHJ1Y3RlZCkge1xuICAgICAgICB2YXIgX3VuZXNjYXBlVmFsdWUyID0gdW5lc2NhcGVWYWx1ZSh2KSxcbiAgICAgICAgICAgIGRlcHJlY2F0ZWRVc2FnZSA9IF91bmVzY2FwZVZhbHVlMi5kZXByZWNhdGVkVXNhZ2UsXG4gICAgICAgICAgICB1bmVzY2FwZWQgPSBfdW5lc2NhcGVWYWx1ZTIudW5lc2NhcGVkLFxuICAgICAgICAgICAgcXVvdGVNYXJrID0gX3VuZXNjYXBlVmFsdWUyLnF1b3RlTWFyaztcblxuICAgICAgICBpZiAoZGVwcmVjYXRlZFVzYWdlKSB7XG4gICAgICAgICAgd2Fybk9mRGVwcmVjYXRlZFZhbHVlQXNzaWdubWVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gdGhpcy5fdmFsdWUgJiYgcXVvdGVNYXJrID09PSB0aGlzLl9xdW90ZU1hcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92YWx1ZSA9IHVuZXNjYXBlZDtcbiAgICAgICAgdGhpcy5fcXVvdGVNYXJrID0gcXVvdGVNYXJrO1xuXG4gICAgICAgIHRoaXMuX3N5bmNSYXdWYWx1ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lKSB7XG4gICAgICB0aGlzLl9oYW5kbGVFc2NhcGVzKFwiYXR0cmlidXRlXCIsIG5hbWUpO1xuXG4gICAgICB0aGlzLl9hdHRyaWJ1dGUgPSBuYW1lO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBdHRyaWJ1dGU7XG59KF9uYW1lc3BhY2VbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBBdHRyaWJ1dGU7XG5BdHRyaWJ1dGUuTk9fUVVPVEUgPSBudWxsO1xuQXR0cmlidXRlLlNJTkdMRV9RVU9URSA9IFwiJ1wiO1xuQXR0cmlidXRlLkRPVUJMRV9RVU9URSA9ICdcIic7XG52YXIgQ1NTRVNDX1FVT1RFX09QVElPTlMgPSAoX0NTU0VTQ19RVU9URV9PUFRJT05TID0ge1xuICBcIidcIjoge1xuICAgIHF1b3RlczogJ3NpbmdsZScsXG4gICAgd3JhcDogdHJ1ZVxuICB9LFxuICAnXCInOiB7XG4gICAgcXVvdGVzOiAnZG91YmxlJyxcbiAgICB3cmFwOiB0cnVlXG4gIH1cbn0sIF9DU1NFU0NfUVVPVEVfT1BUSU9OU1tudWxsXSA9IHtcbiAgaXNJZGVudGlmaWVyOiB0cnVlXG59LCBfQ1NTRVNDX1FVT1RFX09QVElPTlMpO1xuXG5mdW5jdGlvbiBkZWZhdWx0QXR0ckNvbmNhdChhdHRyVmFsdWUsIGF0dHJTcGFjZXMpIHtcbiAgcmV0dXJuIFwiXCIgKyBhdHRyU3BhY2VzLmJlZm9yZSArIGF0dHJWYWx1ZSArIGF0dHJTcGFjZXMuYWZ0ZXI7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jc3Nlc2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjc3Nlc2NcIikpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxudmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ub2RlXCIpKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIENsYXNzTmFtZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2xhc3NOYW1lLCBfTm9kZSk7XG5cbiAgZnVuY3Rpb24gQ2xhc3NOYW1lKG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gX3R5cGVzLkNMQVNTO1xuICAgIF90aGlzLl9jb25zdHJ1Y3RlZCA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENsYXNzTmFtZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnZhbHVlVG9TdHJpbmcgPSBmdW5jdGlvbiB2YWx1ZVRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnLicgKyBfTm9kZS5wcm90b3R5cGUudmFsdWVUb1N0cmluZy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhDbGFzc05hbWUsIFt7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2KSB7XG4gICAgICBpZiAodGhpcy5fY29uc3RydWN0ZWQpIHtcbiAgICAgICAgdmFyIGVzY2FwZWQgPSAoMCwgX2Nzc2VzY1tcImRlZmF1bHRcIl0pKHYsIHtcbiAgICAgICAgICBpc0lkZW50aWZpZXI6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVzY2FwZWQgIT09IHYpIHtcbiAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KSh0aGlzLCBcInJhd3NcIik7XG4gICAgICAgICAgdGhpcy5yYXdzLnZhbHVlID0gZXNjYXBlZDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJhd3MpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5yYXdzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2xhc3NOYW1lO1xufShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENsYXNzTmFtZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZVwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgQ29tYmluYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ29tYmluYXRvciwgX05vZGUpO1xuXG4gIGZ1bmN0aW9uIENvbWJpbmF0b3Iob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX05vZGUuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuQ09NQklOQVRPUjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gQ29tYmluYXRvcjtcbn0oX25vZGVbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb21iaW5hdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ub2RlXCIpKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBDb21tZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHNMb29zZShDb21tZW50LCBfTm9kZSk7XG5cbiAgZnVuY3Rpb24gQ29tbWVudChvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IF90eXBlcy5DT01NRU5UO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBDb21tZW50O1xufShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5pdmVyc2FsID0gZXhwb3J0cy50YWcgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuc2VsZWN0b3IgPSBleHBvcnRzLnJvb3QgPSBleHBvcnRzLnBzZXVkbyA9IGV4cG9ydHMubmVzdGluZyA9IGV4cG9ydHMuaWQgPSBleHBvcnRzLmNvbW1lbnQgPSBleHBvcnRzLmNvbWJpbmF0b3IgPSBleHBvcnRzLmNsYXNzTmFtZSA9IGV4cG9ydHMuYXR0cmlidXRlID0gdm9pZCAwO1xuXG52YXIgX2F0dHJpYnV0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYXR0cmlidXRlXCIpKTtcblxudmFyIF9jbGFzc05hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NsYXNzTmFtZVwiKSk7XG5cbnZhciBfY29tYmluYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tYmluYXRvclwiKSk7XG5cbnZhciBfY29tbWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tbWVudFwiKSk7XG5cbnZhciBfaWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lkXCIpKTtcblxudmFyIF9uZXN0aW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9uZXN0aW5nXCIpKTtcblxudmFyIF9wc2V1ZG8gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BzZXVkb1wiKSk7XG5cbnZhciBfcm9vdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm9vdFwiKSk7XG5cbnZhciBfc2VsZWN0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NlbGVjdG9yXCIpKTtcblxudmFyIF9zdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ1wiKSk7XG5cbnZhciBfdGFnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90YWdcIikpO1xuXG52YXIgX3VuaXZlcnNhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdW5pdmVyc2FsXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBhdHRyaWJ1dGUgPSBmdW5jdGlvbiBhdHRyaWJ1dGUob3B0cykge1xuICByZXR1cm4gbmV3IF9hdHRyaWJ1dGVbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG5cbnZhciBjbGFzc05hbWUgPSBmdW5jdGlvbiBjbGFzc05hbWUob3B0cykge1xuICByZXR1cm4gbmV3IF9jbGFzc05hbWVbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cbnZhciBjb21iaW5hdG9yID0gZnVuY3Rpb24gY29tYmluYXRvcihvcHRzKSB7XG4gIHJldHVybiBuZXcgX2NvbWJpbmF0b3JbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy5jb21iaW5hdG9yID0gY29tYmluYXRvcjtcblxudmFyIGNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfY29tbWVudFtcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuXG5leHBvcnRzLmNvbW1lbnQgPSBjb21tZW50O1xuXG52YXIgaWQgPSBmdW5jdGlvbiBpZChvcHRzKSB7XG4gIHJldHVybiBuZXcgX2lkW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmV4cG9ydHMuaWQgPSBpZDtcblxudmFyIG5lc3RpbmcgPSBmdW5jdGlvbiBuZXN0aW5nKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfbmVzdGluZ1tcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuXG5leHBvcnRzLm5lc3RpbmcgPSBuZXN0aW5nO1xuXG52YXIgcHNldWRvID0gZnVuY3Rpb24gcHNldWRvKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfcHNldWRvW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmV4cG9ydHMucHNldWRvID0gcHNldWRvO1xuXG52YXIgcm9vdCA9IGZ1bmN0aW9uIHJvb3Qob3B0cykge1xuICByZXR1cm4gbmV3IF9yb290W1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmV4cG9ydHMucm9vdCA9IHJvb3Q7XG5cbnZhciBzZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdG9yKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfc2VsZWN0b3JbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gc3RyaW5nKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfc3RyaW5nW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuXG52YXIgdGFnID0gZnVuY3Rpb24gdGFnKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfdGFnW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmV4cG9ydHMudGFnID0gdGFnO1xuXG52YXIgdW5pdmVyc2FsID0gZnVuY3Rpb24gdW5pdmVyc2FsKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfdW5pdmVyc2FsW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmV4cG9ydHMudW5pdmVyc2FsID0gdW5pdmVyc2FsOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZVwiKSk7XG5cbnZhciB0eXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3R5cGVzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyByZXR1cm4gZnVuY3Rpb24gKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBDb250YWluZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0c0xvb3NlKENvbnRhaW5lciwgX05vZGUpO1xuXG4gIGZ1bmN0aW9uIENvbnRhaW5lcihvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cbiAgICBpZiAoIV90aGlzLm5vZGVzKSB7XG4gICAgICBfdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb250YWluZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoc2VsZWN0b3IpIHtcbiAgICBzZWxlY3Rvci5wYXJlbnQgPSB0aGlzO1xuICAgIHRoaXMubm9kZXMucHVzaChzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKHNlbGVjdG9yKSB7XG4gICAgc2VsZWN0b3IucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLm5vZGVzLnVuc2hpZnQoc2VsZWN0b3IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5hdCA9IGZ1bmN0aW9uIGF0KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNbaW5kZXhdO1xuICB9O1xuXG4gIF9wcm90by5pbmRleCA9IGZ1bmN0aW9uIGluZGV4KGNoaWxkKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgIGNoaWxkID0gdGhpcy5pbmRleChjaGlsZCk7XG4gICAgdGhpcy5hdChjaGlsZCkucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubm9kZXMuc3BsaWNlKGNoaWxkLCAxKTtcbiAgICB2YXIgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXTtcblxuICAgICAgaWYgKGluZGV4ID49IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleCAtIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRoaXMubm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIG5vZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgIG5vZGUucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGwoKTtcbiAgfTtcblxuICBfcHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiBpbnNlcnRBZnRlcihvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgIHZhciBvbGRJbmRleCA9IHRoaXMuaW5kZXgob2xkTm9kZSk7XG4gICAgdGhpcy5ub2Rlcy5zcGxpY2Uob2xkSW5kZXggKyAxLCAwLCBuZXdOb2RlKTtcbiAgICBuZXdOb2RlLnBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGluZGV4O1xuXG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF07XG5cbiAgICAgIGlmIChvbGRJbmRleCA8PSBpbmRleCkge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXggKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUob2xkTm9kZSwgbmV3Tm9kZSkge1xuICAgIG5ld05vZGUucGFyZW50ID0gdGhpcztcbiAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmluZGV4KG9sZE5vZGUpO1xuICAgIHRoaXMubm9kZXMuc3BsaWNlKG9sZEluZGV4LCAwLCBuZXdOb2RlKTtcbiAgICBuZXdOb2RlLnBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGluZGV4O1xuXG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF07XG5cbiAgICAgIGlmIChpbmRleCA8PSBvbGRJbmRleCkge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXggKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5fZmluZENoaWxkQXRQb3NpdGlvbiA9IGZ1bmN0aW9uIF9maW5kQ2hpbGRBdFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuICAgIHZhciBmb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmF0UG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGZvdW5kQ2hpbGQgPSBub2RlLmF0UG9zaXRpb24obGluZSwgY29sKTtcblxuICAgICAgICBpZiAoZm91bmRDaGlsZCkge1xuICAgICAgICAgIGZvdW5kID0gZm91bmRDaGlsZDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5pc0F0UG9zaXRpb24obGluZSwgY29sKSkge1xuICAgICAgICBmb3VuZCA9IG5vZGU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbW9zdCBzcGVjaWZpYyBub2RlIGF0IHRoZSBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyIGdpdmVuLlxuICAgKiBUaGUgc291cmNlIGxvY2F0aW9uIGlzIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBwYXJzZWQgbG9jYXRpb24sIGxvY2F0aW9ucyBhcmVuJ3RcbiAgICogdXBkYXRlZCBhcyBzZWxlY3RvciBub2RlcyBhcmUgbXV0YXRlZC5cbiAgICogXG4gICAqIE5vdGUgdGhhdCB0aGlzIGxvY2F0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAqIG9mIHRoZSBzZWxlY3RvciwgYW5kIG5vdCB0aGUgbG9jYXRpb24gb2YgdGhlIHNlbGVjdG9yIGluIHRoZSBvdmVyYWxsIGRvY3VtZW50XG4gICAqIHdoZW4gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHBvc3Rjc3MuXG4gICAqXG4gICAqIElmIG5vdCBmb3VuZCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lIFRoZSBsaW5lIG51bWJlciBvZiB0aGUgbm9kZSB0byBmaW5kLiAoMS1iYXNlZCBpbmRleClcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCAgVGhlIGNvbHVtbiBudW1iZXIgb2YgdGhlIG5vZGUgdG8gZmluZC4gKDEtYmFzZWQgaW5kZXgpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmF0UG9zaXRpb24gPSBmdW5jdGlvbiBhdFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuICAgIGlmICh0aGlzLmlzQXRQb3NpdGlvbihsaW5lLCBjb2wpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZENoaWxkQXRQb3NpdGlvbihsaW5lLCBjb2wpIHx8IHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5faW5mZXJFbmRQb3NpdGlvbiA9IGZ1bmN0aW9uIF9pbmZlckVuZFBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLmxhc3QgJiYgdGhpcy5sYXN0LnNvdXJjZSAmJiB0aGlzLmxhc3Quc291cmNlLmVuZCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLnNvdXJjZSB8fCB7fTtcbiAgICAgIHRoaXMuc291cmNlLmVuZCA9IHRoaXMuc291cmNlLmVuZCB8fCB7fTtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5zb3VyY2UuZW5kLCB0aGlzLmxhc3Quc291cmNlLmVuZCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5lYWNoID0gZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5sYXN0RWFjaCkge1xuICAgICAgdGhpcy5sYXN0RWFjaCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmluZGV4ZXMpIHtcbiAgICAgIHRoaXMuaW5kZXhlcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMubGFzdEVhY2grKztcbiAgICB2YXIgaWQgPSB0aGlzLmxhc3RFYWNoO1xuICAgIHRoaXMuaW5kZXhlc1tpZF0gPSAwO1xuXG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXgsIHJlc3VsdDtcblxuICAgIHdoaWxlICh0aGlzLmluZGV4ZXNbaWRdIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHRoaXMuYXQoaW5kZXgpLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluZGV4ZXNbaWRdICs9IDE7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuaW5kZXhlc1tpZF07XG5cbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ud2FsayA9IGZ1bmN0aW9uIHdhbGsoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2sobm9kZSwgaSk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlICYmIG5vZGUubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IG5vZGUud2FsayhjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ud2Fsa0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiB3YWxrQXR0cmlidXRlcyhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcy5BVFRSSUJVVEUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMyLCBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLndhbGtDbGFzc2VzID0gZnVuY3Rpb24gd2Fsa0NsYXNzZXMoY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gdHlwZXMuQ0xBU1MpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMzLCBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLndhbGtDb21iaW5hdG9ycyA9IGZ1bmN0aW9uIHdhbGtDb21iaW5hdG9ycyhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcy5DT01CSU5BVE9SKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKF90aGlzNCwgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by53YWxrQ29tbWVudHMgPSBmdW5jdGlvbiB3YWxrQ29tbWVudHMoY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gdHlwZXMuQ09NTUVOVCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczUsIHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ud2Fsa0lkcyA9IGZ1bmN0aW9uIHdhbGtJZHMoY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gdHlwZXMuSUQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXM2LCBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLndhbGtOZXN0aW5nID0gZnVuY3Rpb24gd2Fsa05lc3RpbmcoY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gdHlwZXMuTkVTVElORykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczcsIHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ud2Fsa1BzZXVkb3MgPSBmdW5jdGlvbiB3YWxrUHNldWRvcyhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcy5QU0VVRE8pIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXM4LCBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLndhbGtUYWdzID0gZnVuY3Rpb24gd2Fsa1RhZ3MoY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gdHlwZXMuVEFHKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKF90aGlzOSwgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by53YWxrVW5pdmVyc2FscyA9IGZ1bmN0aW9uIHdhbGtVbml2ZXJzYWxzKGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcy5VTklWRVJTQUwpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMxMCwgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgdmFyIGN1cnJlbnQgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIG5vZGUsIGluZGV4KSB7XG4gICAgICB2YXIgc3BsaXQgPSBjYWxsYmFjay5jYWxsKF90aGlzMTEsIG5vZGUpO1xuICAgICAgY3VycmVudC5wdXNoKG5vZGUpO1xuXG4gICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgbWVtby5wdXNoKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gW107XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBfdGhpczExLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbWVtby5wdXNoKGN1cnJlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCBbXSk7XG4gIH07XG5cbiAgX3Byb3RvLm1hcCA9IGZ1bmN0aW9uIG1hcChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLm1hcChjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLnJlZHVjZSA9IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFjaywgbWVtbykge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZShjYWxsYmFjaywgbWVtbyk7XG4gIH07XG5cbiAgX3Byb3RvLmV2ZXJ5ID0gZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5ldmVyeShjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLnNvbWUgPSBmdW5jdGlvbiBzb21lKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuc29tZShjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmZpbHRlcihjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLnNvcnQgPSBmdW5jdGlvbiBzb3J0KGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuc29ydChjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKFN0cmluZykuam9pbignJyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKENvbnRhaW5lciwgW3tcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0KDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsYXN0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udGFpbmVyO1xufShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbnRhaW5lcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5pc05vZGUgPSBpc05vZGU7XG5leHBvcnRzLmlzUHNldWRvRWxlbWVudCA9IGlzUHNldWRvRWxlbWVudDtcbmV4cG9ydHMuaXNQc2V1ZG9DbGFzcyA9IGlzUHNldWRvQ2xhc3M7XG5leHBvcnRzLmlzQ29udGFpbmVyID0gaXNDb250YWluZXI7XG5leHBvcnRzLmlzTmFtZXNwYWNlID0gaXNOYW1lc3BhY2U7XG5leHBvcnRzLmlzVW5pdmVyc2FsID0gZXhwb3J0cy5pc1RhZyA9IGV4cG9ydHMuaXNTdHJpbmcgPSBleHBvcnRzLmlzU2VsZWN0b3IgPSBleHBvcnRzLmlzUm9vdCA9IGV4cG9ydHMuaXNQc2V1ZG8gPSBleHBvcnRzLmlzTmVzdGluZyA9IGV4cG9ydHMuaXNJZGVudGlmaWVyID0gZXhwb3J0cy5pc0NvbW1lbnQgPSBleHBvcnRzLmlzQ29tYmluYXRvciA9IGV4cG9ydHMuaXNDbGFzc05hbWUgPSBleHBvcnRzLmlzQXR0cmlidXRlID0gdm9pZCAwO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbnZhciBfSVNfVFlQRTtcblxudmFyIElTX1RZUEUgPSAoX0lTX1RZUEUgPSB7fSwgX0lTX1RZUEVbX3R5cGVzLkFUVFJJQlVURV0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuQ0xBU1NdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLkNPTUJJTkFUT1JdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLkNPTU1FTlRdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLklEXSA9IHRydWUsIF9JU19UWVBFW190eXBlcy5ORVNUSU5HXSA9IHRydWUsIF9JU19UWVBFW190eXBlcy5QU0VVRE9dID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLlJPT1RdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLlNFTEVDVE9SXSA9IHRydWUsIF9JU19UWVBFW190eXBlcy5TVFJJTkddID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLlRBR10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuVU5JVkVSU0FMXSA9IHRydWUsIF9JU19UWVBFKTtcblxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBub2RlID09PSBcIm9iamVjdFwiICYmIElTX1RZUEVbbm9kZS50eXBlXTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlVHlwZSh0eXBlLCBub2RlKSB7XG4gIHJldHVybiBpc05vZGUobm9kZSkgJiYgbm9kZS50eXBlID09PSB0eXBlO1xufVxuXG52YXIgaXNBdHRyaWJ1dGUgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLkFUVFJJQlVURSk7XG5leHBvcnRzLmlzQXR0cmlidXRlID0gaXNBdHRyaWJ1dGU7XG52YXIgaXNDbGFzc05hbWUgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLkNMQVNTKTtcbmV4cG9ydHMuaXNDbGFzc05hbWUgPSBpc0NsYXNzTmFtZTtcbnZhciBpc0NvbWJpbmF0b3IgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLkNPTUJJTkFUT1IpO1xuZXhwb3J0cy5pc0NvbWJpbmF0b3IgPSBpc0NvbWJpbmF0b3I7XG52YXIgaXNDb21tZW50ID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5DT01NRU5UKTtcbmV4cG9ydHMuaXNDb21tZW50ID0gaXNDb21tZW50O1xudmFyIGlzSWRlbnRpZmllciA9IGlzTm9kZVR5cGUuYmluZChudWxsLCBfdHlwZXMuSUQpO1xuZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG52YXIgaXNOZXN0aW5nID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5ORVNUSU5HKTtcbmV4cG9ydHMuaXNOZXN0aW5nID0gaXNOZXN0aW5nO1xudmFyIGlzUHNldWRvID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5QU0VVRE8pO1xuZXhwb3J0cy5pc1BzZXVkbyA9IGlzUHNldWRvO1xudmFyIGlzUm9vdCA9IGlzTm9kZVR5cGUuYmluZChudWxsLCBfdHlwZXMuUk9PVCk7XG5leHBvcnRzLmlzUm9vdCA9IGlzUm9vdDtcbnZhciBpc1NlbGVjdG9yID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5TRUxFQ1RPUik7XG5leHBvcnRzLmlzU2VsZWN0b3IgPSBpc1NlbGVjdG9yO1xudmFyIGlzU3RyaW5nID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5TVFJJTkcpO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xudmFyIGlzVGFnID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5UQUcpO1xuZXhwb3J0cy5pc1RhZyA9IGlzVGFnO1xudmFyIGlzVW5pdmVyc2FsID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5VTklWRVJTQUwpO1xuZXhwb3J0cy5pc1VuaXZlcnNhbCA9IGlzVW5pdmVyc2FsO1xuXG5mdW5jdGlvbiBpc1BzZXVkb0VsZW1lbnQobm9kZSkge1xuICByZXR1cm4gaXNQc2V1ZG8obm9kZSkgJiYgbm9kZS52YWx1ZSAmJiAobm9kZS52YWx1ZS5zdGFydHNXaXRoKFwiOjpcIikgfHwgbm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBcIjpiZWZvcmVcIiB8fCBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwiOmFmdGVyXCIgfHwgbm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBcIjpmaXJzdC1sZXR0ZXJcIiB8fCBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwiOmZpcnN0LWxpbmVcIik7XG59XG5cbmZ1bmN0aW9uIGlzUHNldWRvQ2xhc3Mobm9kZSkge1xuICByZXR1cm4gaXNQc2V1ZG8obm9kZSkgJiYgIWlzUHNldWRvRWxlbWVudChub2RlKTtcbn1cblxuZnVuY3Rpb24gaXNDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEoaXNOb2RlKG5vZGUpICYmIG5vZGUud2Fsayk7XG59XG5cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlKG5vZGUpIHtcbiAgcmV0dXJuIGlzQXR0cmlidXRlKG5vZGUpIHx8IGlzVGFnKG5vZGUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZVwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgSUQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0c0xvb3NlKElELCBfTm9kZSk7XG5cbiAgZnVuY3Rpb24gSUQob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX05vZGUuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuSUQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElELnByb3RvdHlwZTtcblxuICBfcHJvdG8udmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uIHZhbHVlVG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICcjJyArIF9Ob2RlLnByb3RvdHlwZS52YWx1ZVRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIElEO1xufShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IElEO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdHlwZXNba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfdHlwZXNba2V5XTtcbn0pO1xuXG52YXIgX2NvbnN0cnVjdG9ycyA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdG9yc1wiKTtcblxuT2JqZWN0LmtleXMoX2NvbnN0cnVjdG9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2NvbnN0cnVjdG9yc1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9jb25zdHJ1Y3RvcnNba2V5XTtcbn0pO1xuXG52YXIgX2d1YXJkcyA9IHJlcXVpcmUoXCIuL2d1YXJkc1wiKTtcblxuT2JqZWN0LmtleXMoX2d1YXJkcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2d1YXJkc1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9ndWFyZHNba2V5XTtcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY3NzZXNjID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY3NzZXNjXCIpKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbnZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgTmFtZXNwYWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHNMb29zZShOYW1lc3BhY2UsIF9Ob2RlKTtcblxuICBmdW5jdGlvbiBOYW1lc3BhY2UoKSB7XG4gICAgcmV0dXJuIF9Ob2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBOYW1lc3BhY2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5xdWFsaWZpZWROYW1lID0gZnVuY3Rpb24gcXVhbGlmaWVkTmFtZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm5hbWVzcGFjZSkge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlU3RyaW5nICsgXCJ8XCIgKyB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uIHZhbHVlVG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVhbGlmaWVkTmFtZShfTm9kZS5wcm90b3R5cGUudmFsdWVUb1N0cmluZy5jYWxsKHRoaXMpKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoTmFtZXNwYWNlLCBbe1xuICAgIGtleTogXCJuYW1lc3BhY2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uYW1lc3BhY2U7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lc3BhY2UpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRydWUgfHwgbmFtZXNwYWNlID09PSBcIipcIiB8fCBuYW1lc3BhY2UgPT09IFwiJlwiKSB7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICAgICAgICBpZiAodGhpcy5yYXdzKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5uYW1lc3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBlc2NhcGVkID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKShuYW1lc3BhY2UsIHtcbiAgICAgICAgaXNJZGVudGlmaWVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX25hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICAgICAgaWYgKGVzY2FwZWQgIT09IG5hbWVzcGFjZSkge1xuICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KSh0aGlzLCBcInJhd3NcIik7XG4gICAgICAgIHRoaXMucmF3cy5uYW1lc3BhY2UgPSBlc2NhcGVkO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJhd3MpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5uYW1lc3BhY2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZXNwYWNlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmFtZXNwYWNlKSB7XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmFtZXNwYWNlU3RyaW5nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5uYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG5zID0gdGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcIm5hbWVzcGFjZVwiKTtcblxuICAgICAgICBpZiAobnMgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5hbWVzcGFjZTtcbn0oX25vZGVbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBOYW1lc3BhY2U7XG47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX25vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVcIikpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIE5lc3RpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0c0xvb3NlKE5lc3RpbmcsIF9Ob2RlKTtcblxuICBmdW5jdGlvbiBOZXN0aW5nKG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gX3R5cGVzLk5FU1RJTkc7XG4gICAgX3RoaXMudmFsdWUgPSAnJic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIE5lc3Rpbmc7XG59KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTmVzdGluZztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBjbG9uZU5vZGUgPSBmdW5jdGlvbiBjbG9uZU5vZGUob2JqLCBwYXJlbnQpIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgY2xvbmVkID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpO1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IG9ialtpXTtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmIChpID09PSAncGFyZW50JyAmJiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBjbG9uZWRbaV0gPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjbG9uZWRbaV0gPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKGopIHtcbiAgICAgICAgcmV0dXJuIGNsb25lTm9kZShqLCBjbG9uZWQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb25lZFtpXSA9IGNsb25lTm9kZSh2YWx1ZSwgY2xvbmVkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvbmVkO1xufTtcblxudmFyIE5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlKG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRzKTtcbiAgICB0aGlzLnNwYWNlcyA9IHRoaXMuc3BhY2VzIHx8IHt9O1xuICAgIHRoaXMuc3BhY2VzLmJlZm9yZSA9IHRoaXMuc3BhY2VzLmJlZm9yZSB8fCAnJztcbiAgICB0aGlzLnNwYWNlcy5hZnRlciA9IHRoaXMuc3BhY2VzLmFmdGVyIHx8ICcnO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE5vZGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVwbGFjZVdpdGggPSBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGZvciAodmFyIGluZGV4IGluIGFyZ3VtZW50cykge1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgYXJndW1lbnRzW2luZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hdCh0aGlzLnBhcmVudC5pbmRleCh0aGlzKSArIDEpO1xuICB9O1xuXG4gIF9wcm90by5wcmV2ID0gZnVuY3Rpb24gcHJldigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXQodGhpcy5wYXJlbnQuaW5kZXgodGhpcykgLSAxKTtcbiAgfTtcblxuICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvdmVycmlkZXMpIHtcbiAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIHtcbiAgICAgIG92ZXJyaWRlcyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBjbG9uZWQgPSBjbG9uZU5vZGUodGhpcyk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIG92ZXJyaWRlcykge1xuICAgICAgY2xvbmVkW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFNvbWUgbm9uLXN0YW5kYXJkIHN5bnRheCBkb2Vzbid0IGZvbGxvdyBub3JtYWwgZXNjYXBpbmcgcnVsZXMgZm9yIGNzcy5cbiAgICogVGhpcyBhbGxvd3Mgbm9uIHN0YW5kYXJkIHN5bnRheCB0byBiZSBhcHBlbmRlZCB0byBhbiBleGlzdGluZyBwcm9wZXJ0eVxuICAgKiBieSBzcGVjaWZ5aW5nIHRoZSBlc2NhcGVkIHZhbHVlLiBCeSBzcGVjaWZ5aW5nIHRoZSBlc2NhcGVkIHZhbHVlLFxuICAgKiBpbGxlZ2FsIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQgdG8gYmUgZGlyZWN0bHkgaW5zZXJ0ZWQgaW50byBjc3Mgb3V0cHV0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcHJvcGVydHkgdG8gc2V0XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSB0aGUgdW5lc2NhcGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVFc2NhcGVkIG9wdGlvbmFsLiB0aGUgZXNjYXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFwcGVuZFRvUHJvcGVydHlBbmRFc2NhcGUgPSBmdW5jdGlvbiBhcHBlbmRUb1Byb3BlcnR5QW5kRXNjYXBlKG5hbWUsIHZhbHVlLCB2YWx1ZUVzY2FwZWQpIHtcbiAgICBpZiAoIXRoaXMucmF3cykge1xuICAgICAgdGhpcy5yYXdzID0ge307XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSB0aGlzW25hbWVdO1xuICAgIHZhciBvcmlnaW5hbEVzY2FwZWQgPSB0aGlzLnJhd3NbbmFtZV07XG4gICAgdGhpc1tuYW1lXSA9IG9yaWdpbmFsVmFsdWUgKyB2YWx1ZTsgLy8gdGhpcyBtYXkgdHJpZ2dlciBhIHNldHRlciB0aGF0IHVwZGF0ZXMgcmF3cywgc28gaXQgaGFzIHRvIGJlIHNldCBmaXJzdC5cblxuICAgIGlmIChvcmlnaW5hbEVzY2FwZWQgfHwgdmFsdWVFc2NhcGVkICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5yYXdzW25hbWVdID0gKG9yaWdpbmFsRXNjYXBlZCB8fCBvcmlnaW5hbFZhbHVlKSArIHZhbHVlRXNjYXBlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMucmF3c1tuYW1lXTsgLy8gZGVsZXRlIGFueSBlc2NhcGVkIHZhbHVlIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIHNldHRlci5cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNvbWUgbm9uLXN0YW5kYXJkIHN5bnRheCBkb2Vzbid0IGZvbGxvdyBub3JtYWwgZXNjYXBpbmcgcnVsZXMgZm9yIGNzcy5cbiAgICogVGhpcyBhbGxvd3MgdGhlIGVzY2FwZWQgdmFsdWUgdG8gYmUgc3BlY2lmaWVkIGRpcmVjdGx5LCBhbGxvd2luZyBpbGxlZ2FsXG4gICAqIGNoYXJhY3RlcnMgdG8gYmUgZGlyZWN0bHkgaW5zZXJ0ZWQgaW50byBjc3Mgb3V0cHV0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcHJvcGVydHkgdG8gc2V0XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSB0aGUgdW5lc2NhcGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVFc2NhcGVkIHRoZSBlc2NhcGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0UHJvcGVydHlBbmRFc2NhcGUgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eUFuZEVzY2FwZShuYW1lLCB2YWx1ZSwgdmFsdWVFc2NhcGVkKSB7XG4gICAgaWYgKCF0aGlzLnJhd3MpIHtcbiAgICAgIHRoaXMucmF3cyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTsgLy8gdGhpcyBtYXkgdHJpZ2dlciBhIHNldHRlciB0aGF0IHVwZGF0ZXMgcmF3cywgc28gaXQgaGFzIHRvIGJlIHNldCBmaXJzdC5cblxuICAgIHRoaXMucmF3c1tuYW1lXSA9IHZhbHVlRXNjYXBlZDtcbiAgfVxuICAvKipcbiAgICogV2hlbiB5b3Ugd2FudCBhIHZhbHVlIHRvIHBhc3NlZCB0aHJvdWdoIHRvIENTUyBkaXJlY3RseS4gVGhpcyBtZXRob2RcbiAgICogZGVsZXRlcyB0aGUgY29ycmVzcG9uZGluZyByYXcgdmFsdWUgY2F1c2luZyB0aGUgc3RyaW5naWZpZXIgdG8gZmFsbGJhY2tcbiAgICogdG8gdGhlIHVuZXNjYXBlZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IGlzIGJvdGggZXNjYXBlZCBhbmQgdW5lc2NhcGVkLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRQcm9wZXJ0eVdpdGhvdXRFc2NhcGUgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eVdpdGhvdXRFc2NhcGUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7IC8vIHRoaXMgbWF5IHRyaWdnZXIgYSBzZXR0ZXIgdGhhdCB1cGRhdGVzIHJhd3MsIHNvIGl0IGhhcyB0byBiZSBzZXQgZmlyc3QuXG5cbiAgICBpZiAodGhpcy5yYXdzKSB7XG4gICAgICBkZWxldGUgdGhpcy5yYXdzW25hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmUgVGhlIG51bWJlciAoc3RhcnRpbmcgd2l0aCAxKVxuICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIFRoZSBjb2x1bW4gbnVtYmVyIChzdGFydGluZyB3aXRoIDEpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmlzQXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGlzQXRQb3NpdGlvbihsaW5lLCBjb2x1bW4pIHtcbiAgICBpZiAodGhpcy5zb3VyY2UgJiYgdGhpcy5zb3VyY2Uuc3RhcnQgJiYgdGhpcy5zb3VyY2UuZW5kKSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2Uuc3RhcnQubGluZSA+IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2UuZW5kLmxpbmUgPCBsaW5lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlLnN0YXJ0LmxpbmUgPT09IGxpbmUgJiYgdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uID4gY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlLmVuZC5saW5lID09PSBsaW5lICYmIHRoaXMuc291cmNlLmVuZC5jb2x1bW4gPCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIF9wcm90by5zdHJpbmdpZnlQcm9wZXJ0eSA9IGZ1bmN0aW9uIHN0cmluZ2lmeVByb3BlcnR5KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5yYXdzICYmIHRoaXMucmF3c1tuYW1lXSB8fCB0aGlzW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by52YWx1ZVRvU3RyaW5nID0gZnVuY3Rpb24gdmFsdWVUb1N0cmluZygpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJ2YWx1ZVwiKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnJhd1NwYWNlQmVmb3JlLCB0aGlzLnZhbHVlVG9TdHJpbmcoKSwgdGhpcy5yYXdTcGFjZUFmdGVyXS5qb2luKCcnKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoTm9kZSwgW3tcbiAgICBrZXk6IFwicmF3U3BhY2VCZWZvcmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByYXdTcGFjZSA9IHRoaXMucmF3cyAmJiB0aGlzLnJhd3Muc3BhY2VzICYmIHRoaXMucmF3cy5zcGFjZXMuYmVmb3JlO1xuXG4gICAgICBpZiAocmF3U3BhY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByYXdTcGFjZSA9IHRoaXMuc3BhY2VzICYmIHRoaXMuc3BhY2VzLmJlZm9yZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhd1NwYWNlIHx8IFwiXCI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChyYXcpIHtcbiAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKHRoaXMsIFwicmF3c1wiLCBcInNwYWNlc1wiKTtcbiAgICAgIHRoaXMucmF3cy5zcGFjZXMuYmVmb3JlID0gcmF3O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYXdTcGFjZUFmdGVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcmF3U3BhY2UgPSB0aGlzLnJhd3MgJiYgdGhpcy5yYXdzLnNwYWNlcyAmJiB0aGlzLnJhd3Muc3BhY2VzLmFmdGVyO1xuXG4gICAgICBpZiAocmF3U3BhY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByYXdTcGFjZSA9IHRoaXMuc3BhY2VzLmFmdGVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3U3BhY2UgfHwgXCJcIjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHJhdykge1xuICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkodGhpcywgXCJyYXdzXCIsIFwic3BhY2VzXCIpO1xuICAgICAgdGhpcy5yYXdzLnNwYWNlcy5hZnRlciA9IHJhdztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZTtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBOb2RlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jb250YWluZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnRhaW5lclwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgUHNldWRvID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29udGFpbmVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBzZXVkbywgX0NvbnRhaW5lcik7XG5cbiAgZnVuY3Rpb24gUHNldWRvKG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db250YWluZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuUFNFVURPO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQc2V1ZG8ucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmxlbmd0aCA/ICcoJyArIHRoaXMubWFwKFN0cmluZykuam9pbignLCcpICsgJyknIDogJyc7XG4gICAgcmV0dXJuIFt0aGlzLnJhd1NwYWNlQmVmb3JlLCB0aGlzLnN0cmluZ2lmeVByb3BlcnR5KFwidmFsdWVcIiksIHBhcmFtcywgdGhpcy5yYXdTcGFjZUFmdGVyXS5qb2luKCcnKTtcbiAgfTtcblxuICByZXR1cm4gUHNldWRvO1xufShfY29udGFpbmVyW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUHNldWRvO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jb250YWluZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnRhaW5lclwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBSb290ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29udGFpbmVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJvb3QsIF9Db250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIFJvb3Qob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NvbnRhaW5lci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IF90eXBlcy5ST09UO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSb290LnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gdGhpcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHNlbGVjdG9yKSB7XG4gICAgICBtZW1vLnB1c2goU3RyaW5nKHNlbGVjdG9yKSk7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCBbXSkuam9pbignLCcpO1xuICAgIHJldHVybiB0aGlzLnRyYWlsaW5nQ29tbWEgPyBzdHIgKyAnLCcgOiBzdHI7XG4gIH07XG5cbiAgX3Byb3RvLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoUm9vdCwgW3tcbiAgICBrZXk6IFwiZXJyb3JHZW5lcmF0b3JcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChoYW5kbGVyKSB7XG4gICAgICB0aGlzLl9lcnJvciA9IGhhbmRsZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJvb3Q7XG59KF9jb250YWluZXJbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSb290O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jb250YWluZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnRhaW5lclwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgU2VsZWN0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoU2VsZWN0b3IsIF9Db250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIFNlbGVjdG9yKG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db250YWluZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuU0VMRUNUT1I7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFNlbGVjdG9yO1xufShfY29udGFpbmVyW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2VsZWN0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX25vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVcIikpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFN0cmluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3RyaW5nLCBfTm9kZSk7XG5cbiAgZnVuY3Rpb24gU3RyaW5nKG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gX3R5cGVzLlNUUklORztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nO1xufShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFN0cmluZztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfbmFtZXNwYWNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9uYW1lc3BhY2VcIikpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05hbWVzcGFjZSkge1xuICBfaW5oZXJpdHNMb29zZShUYWcsIF9OYW1lc3BhY2UpO1xuXG4gIGZ1bmN0aW9uIFRhZyhvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfTmFtZXNwYWNlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gX3R5cGVzLlRBRztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gVGFnO1xufShfbmFtZXNwYWNlW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVGFnO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLlVOSVZFUlNBTCA9IGV4cG9ydHMuQVRUUklCVVRFID0gZXhwb3J0cy5DTEFTUyA9IGV4cG9ydHMuQ09NQklOQVRPUiA9IGV4cG9ydHMuQ09NTUVOVCA9IGV4cG9ydHMuSUQgPSBleHBvcnRzLk5FU1RJTkcgPSBleHBvcnRzLlBTRVVETyA9IGV4cG9ydHMuUk9PVCA9IGV4cG9ydHMuU0VMRUNUT1IgPSBleHBvcnRzLlNUUklORyA9IGV4cG9ydHMuVEFHID0gdm9pZCAwO1xudmFyIFRBRyA9ICd0YWcnO1xuZXhwb3J0cy5UQUcgPSBUQUc7XG52YXIgU1RSSU5HID0gJ3N0cmluZyc7XG5leHBvcnRzLlNUUklORyA9IFNUUklORztcbnZhciBTRUxFQ1RPUiA9ICdzZWxlY3Rvcic7XG5leHBvcnRzLlNFTEVDVE9SID0gU0VMRUNUT1I7XG52YXIgUk9PVCA9ICdyb290JztcbmV4cG9ydHMuUk9PVCA9IFJPT1Q7XG52YXIgUFNFVURPID0gJ3BzZXVkbyc7XG5leHBvcnRzLlBTRVVETyA9IFBTRVVETztcbnZhciBORVNUSU5HID0gJ25lc3RpbmcnO1xuZXhwb3J0cy5ORVNUSU5HID0gTkVTVElORztcbnZhciBJRCA9ICdpZCc7XG5leHBvcnRzLklEID0gSUQ7XG52YXIgQ09NTUVOVCA9ICdjb21tZW50JztcbmV4cG9ydHMuQ09NTUVOVCA9IENPTU1FTlQ7XG52YXIgQ09NQklOQVRPUiA9ICdjb21iaW5hdG9yJztcbmV4cG9ydHMuQ09NQklOQVRPUiA9IENPTUJJTkFUT1I7XG52YXIgQ0xBU1MgPSAnY2xhc3MnO1xuZXhwb3J0cy5DTEFTUyA9IENMQVNTO1xudmFyIEFUVFJJQlVURSA9ICdhdHRyaWJ1dGUnO1xuZXhwb3J0cy5BVFRSSUJVVEUgPSBBVFRSSUJVVEU7XG52YXIgVU5JVkVSU0FMID0gJ3VuaXZlcnNhbCc7XG5leHBvcnRzLlVOSVZFUlNBTCA9IFVOSVZFUlNBTDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX25hbWVzcGFjZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBVbml2ZXJzYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9OYW1lc3BhY2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoVW5pdmVyc2FsLCBfTmFtZXNwYWNlKTtcblxuICBmdW5jdGlvbiBVbml2ZXJzYWwob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX05hbWVzcGFjZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IF90eXBlcy5VTklWRVJTQUw7XG4gICAgX3RoaXMudmFsdWUgPSAnKic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFVuaXZlcnNhbDtcbn0oX25hbWVzcGFjZVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFVuaXZlcnNhbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBzb3J0QXNjZW5kaW5nO1xuXG5mdW5jdGlvbiBzb3J0QXNjZW5kaW5nKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG59XG5cbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21iaW5hdG9yID0gZXhwb3J0cy53b3JkID0gZXhwb3J0cy5jb21tZW50ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLnRhYiA9IGV4cG9ydHMubmV3bGluZSA9IGV4cG9ydHMuZmVlZCA9IGV4cG9ydHMuY3IgPSBleHBvcnRzLmJhY2tzbGFzaCA9IGV4cG9ydHMuYmFuZyA9IGV4cG9ydHMuc2xhc2ggPSBleHBvcnRzLmRvdWJsZVF1b3RlID0gZXhwb3J0cy5zaW5nbGVRdW90ZSA9IGV4cG9ydHMuc3BhY2UgPSBleHBvcnRzLmdyZWF0ZXJUaGFuID0gZXhwb3J0cy5waXBlID0gZXhwb3J0cy5lcXVhbHMgPSBleHBvcnRzLnBsdXMgPSBleHBvcnRzLmNhcmV0ID0gZXhwb3J0cy50aWxkZSA9IGV4cG9ydHMuZG9sbGFyID0gZXhwb3J0cy5jbG9zZVNxdWFyZSA9IGV4cG9ydHMub3BlblNxdWFyZSA9IGV4cG9ydHMuY2xvc2VQYXJlbnRoZXNpcyA9IGV4cG9ydHMub3BlblBhcmVudGhlc2lzID0gZXhwb3J0cy5zZW1pY29sb24gPSBleHBvcnRzLmNvbG9uID0gZXhwb3J0cy5jb21tYSA9IGV4cG9ydHMuYXQgPSBleHBvcnRzLmFzdGVyaXNrID0gZXhwb3J0cy5hbXBlcnNhbmQgPSB2b2lkIDA7XG52YXIgYW1wZXJzYW5kID0gMzg7IC8vIGAmYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLmFtcGVyc2FuZCA9IGFtcGVyc2FuZDtcbnZhciBhc3RlcmlzayA9IDQyOyAvLyBgKmAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5hc3RlcmlzayA9IGFzdGVyaXNrO1xudmFyIGF0ID0gNjQ7IC8vIGBAYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLmF0ID0gYXQ7XG52YXIgY29tbWEgPSA0NDsgLy8gYCxgLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuY29tbWEgPSBjb21tYTtcbnZhciBjb2xvbiA9IDU4OyAvLyBgOmAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5jb2xvbiA9IGNvbG9uO1xudmFyIHNlbWljb2xvbiA9IDU5OyAvLyBgO2AuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5zZW1pY29sb24gPSBzZW1pY29sb247XG52YXIgb3BlblBhcmVudGhlc2lzID0gNDA7IC8vIGAoYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLm9wZW5QYXJlbnRoZXNpcyA9IG9wZW5QYXJlbnRoZXNpcztcbnZhciBjbG9zZVBhcmVudGhlc2lzID0gNDE7IC8vIGApYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLmNsb3NlUGFyZW50aGVzaXMgPSBjbG9zZVBhcmVudGhlc2lzO1xudmFyIG9wZW5TcXVhcmUgPSA5MTsgLy8gYFtgLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMub3BlblNxdWFyZSA9IG9wZW5TcXVhcmU7XG52YXIgY2xvc2VTcXVhcmUgPSA5MzsgLy8gYF1gLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuY2xvc2VTcXVhcmUgPSBjbG9zZVNxdWFyZTtcbnZhciBkb2xsYXIgPSAzNjsgLy8gYCRgLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuZG9sbGFyID0gZG9sbGFyO1xudmFyIHRpbGRlID0gMTI2OyAvLyBgfmAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy50aWxkZSA9IHRpbGRlO1xudmFyIGNhcmV0ID0gOTQ7IC8vIGBeYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLmNhcmV0ID0gY2FyZXQ7XG52YXIgcGx1cyA9IDQzOyAvLyBgK2AuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5wbHVzID0gcGx1cztcbnZhciBlcXVhbHMgPSA2MTsgLy8gYD1gLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xudmFyIHBpcGUgPSAxMjQ7IC8vIGB8YC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLnBpcGUgPSBwaXBlO1xudmFyIGdyZWF0ZXJUaGFuID0gNjI7IC8vIGA+YC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLmdyZWF0ZXJUaGFuID0gZ3JlYXRlclRoYW47XG52YXIgc3BhY2UgPSAzMjsgLy8gYCBgLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuc3BhY2UgPSBzcGFjZTtcbnZhciBzaW5nbGVRdW90ZSA9IDM5OyAvLyBgJ2AuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5zaW5nbGVRdW90ZSA9IHNpbmdsZVF1b3RlO1xudmFyIGRvdWJsZVF1b3RlID0gMzQ7IC8vIGBcImAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5kb3VibGVRdW90ZSA9IGRvdWJsZVF1b3RlO1xudmFyIHNsYXNoID0gNDc7IC8vIGAvYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLnNsYXNoID0gc2xhc2g7XG52YXIgYmFuZyA9IDMzOyAvLyBgIWAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5iYW5nID0gYmFuZztcbnZhciBiYWNrc2xhc2ggPSA5MjsgLy8gJ1xcXFwnLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuYmFja3NsYXNoID0gYmFja3NsYXNoO1xudmFyIGNyID0gMTM7IC8vICdcXHInLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuY3IgPSBjcjtcbnZhciBmZWVkID0gMTI7IC8vICdcXGYnLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuZmVlZCA9IGZlZWQ7XG52YXIgbmV3bGluZSA9IDEwOyAvLyAnXFxuJy5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLm5ld2xpbmUgPSBuZXdsaW5lO1xudmFyIHRhYiA9IDk7IC8vICdcXHQnLmNoYXJDb2RlQXQoMCk7XG4vLyBFeHBvc2UgYWxpYXNlcyBwcmltYXJpbHkgZm9yIHJlYWRhYmlsaXR5LlxuXG5leHBvcnRzLnRhYiA9IHRhYjtcbnZhciBzdHIgPSBzaW5nbGVRdW90ZTsgLy8gTm8gZ29vZCBzaW5nbGUgY2hhcmFjdGVyIHJlcHJlc2VudGF0aW9uIVxuXG5leHBvcnRzLnN0ciA9IHN0cjtcbnZhciBjb21tZW50ID0gLTE7XG5leHBvcnRzLmNvbW1lbnQgPSBjb21tZW50O1xudmFyIHdvcmQgPSAtMjtcbmV4cG9ydHMud29yZCA9IHdvcmQ7XG52YXIgY29tYmluYXRvciA9IC0zO1xuZXhwb3J0cy5jb21iaW5hdG9yID0gY29tYmluYXRvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdG9rZW5pemU7XG5leHBvcnRzLkZJRUxEUyA9IHZvaWQgMDtcblxudmFyIHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi90b2tlblR5cGVzXCIpKTtcblxudmFyIF91bmVzY2FwYWJsZSwgX3dvcmREZWxpbWl0ZXJzO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxudmFyIHVuZXNjYXBhYmxlID0gKF91bmVzY2FwYWJsZSA9IHt9LCBfdW5lc2NhcGFibGVbdC50YWJdID0gdHJ1ZSwgX3VuZXNjYXBhYmxlW3QubmV3bGluZV0gPSB0cnVlLCBfdW5lc2NhcGFibGVbdC5jcl0gPSB0cnVlLCBfdW5lc2NhcGFibGVbdC5mZWVkXSA9IHRydWUsIF91bmVzY2FwYWJsZSk7XG52YXIgd29yZERlbGltaXRlcnMgPSAoX3dvcmREZWxpbWl0ZXJzID0ge30sIF93b3JkRGVsaW1pdGVyc1t0LnNwYWNlXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LnRhYl0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5uZXdsaW5lXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmNyXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmZlZWRdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuYW1wZXJzYW5kXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmFzdGVyaXNrXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmJhbmddID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY29tbWFdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY29sb25dID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Quc2VtaWNvbG9uXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0Lm9wZW5QYXJlbnRoZXNpc10gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jbG9zZVBhcmVudGhlc2lzXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0Lm9wZW5TcXVhcmVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY2xvc2VTcXVhcmVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Quc2luZ2xlUXVvdGVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuZG91YmxlUXVvdGVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QucGx1c10gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5waXBlXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LnRpbGRlXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmdyZWF0ZXJUaGFuXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmVxdWFsc10gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5kb2xsYXJdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY2FyZXRdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Quc2xhc2hdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzKTtcbnZhciBoZXggPSB7fTtcbnZhciBoZXhDaGFycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRlwiO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IGhleENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gIGhleFtoZXhDaGFycy5jaGFyQ29kZUF0KGkpXSA9IHRydWU7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IG9mIHRoZSBiYXIgY3NzIHdvcmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3MgVGhlIHN0cmluZyBpbiB3aGljaCB0aGUgd29yZCBiZWdpbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggaW50byB0aGUgc3RyaW5nIHdoZXJlIHdvcmQncyBmaXJzdCBsZXR0ZXIgb2NjdXJzXG4gKi9cblxuXG5mdW5jdGlvbiBjb25zdW1lV29yZChjc3MsIHN0YXJ0KSB7XG4gIHZhciBuZXh0ID0gc3RhcnQ7XG4gIHZhciBjb2RlO1xuXG4gIGRvIHtcbiAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCk7XG5cbiAgICBpZiAod29yZERlbGltaXRlcnNbY29kZV0pIHtcbiAgICAgIHJldHVybiBuZXh0IC0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IHQuYmFja3NsYXNoKSB7XG4gICAgICBuZXh0ID0gY29uc3VtZUVzY2FwZShjc3MsIG5leHQpICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWxsIG90aGVyIGNoYXJhY3RlcnMgYXJlIHBhcnQgb2YgdGhlIHdvcmRcbiAgICAgIG5leHQrKztcbiAgICB9XG4gIH0gd2hpbGUgKG5leHQgPCBjc3MubGVuZ3RoKTtcblxuICByZXR1cm4gbmV4dCAtIDE7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IG9mIHRoZSBlc2NhcGUgc2VxdWVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3MgVGhlIHN0cmluZyBpbiB3aGljaCB0aGUgc2VxdWVuY2UgYmVnaW5zXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IGludG8gdGhlIHN0cmluZyB3aGVyZSBlc2NhcGUgY2hhcmFjdGVyIChgXFxgKSBvY2N1cnMuXG4gKi9cblxuXG5mdW5jdGlvbiBjb25zdW1lRXNjYXBlKGNzcywgc3RhcnQpIHtcbiAgdmFyIG5leHQgPSBzdGFydDtcbiAgdmFyIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0ICsgMSk7XG5cbiAgaWYgKHVuZXNjYXBhYmxlW2NvZGVdKSB7Ly8ganVzdCBjb25zdW1lIHRoZSBlc2NhcGUgY2hhclxuICB9IGVsc2UgaWYgKGhleFtjb2RlXSkge1xuICAgIHZhciBoZXhEaWdpdHMgPSAwOyAvLyBjb25zdW1lIHVwIHRvIDYgaGV4IGNoYXJzXG5cbiAgICBkbyB7XG4gICAgICBuZXh0Kys7XG4gICAgICBoZXhEaWdpdHMrKztcbiAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0ICsgMSk7XG4gICAgfSB3aGlsZSAoaGV4W2NvZGVdICYmIGhleERpZ2l0cyA8IDYpOyAvLyBpZiBmZXdlciB0aGFuIDYgaGV4IGNoYXJzLCBhIHRyYWlsaW5nIHNwYWNlIGVuZHMgdGhlIGVzY2FwZVxuXG5cbiAgICBpZiAoaGV4RGlnaXRzIDwgNiAmJiBjb2RlID09PSB0LnNwYWNlKSB7XG4gICAgICBuZXh0Kys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBuZXh0IGNoYXIgaXMgcGFydCBvZiB0aGUgY3VycmVudCB3b3JkXG4gICAgbmV4dCsrO1xuICB9XG5cbiAgcmV0dXJuIG5leHQ7XG59XG5cbnZhciBGSUVMRFMgPSB7XG4gIFRZUEU6IDAsXG4gIFNUQVJUX0xJTkU6IDEsXG4gIFNUQVJUX0NPTDogMixcbiAgRU5EX0xJTkU6IDMsXG4gIEVORF9DT0w6IDQsXG4gIFNUQVJUX1BPUzogNSxcbiAgRU5EX1BPUzogNlxufTtcbmV4cG9ydHMuRklFTERTID0gRklFTERTO1xuXG5mdW5jdGlvbiB0b2tlbml6ZShpbnB1dCkge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBjc3MgPSBpbnB1dC5jc3MudmFsdWVPZigpO1xuICB2YXIgX2NzcyA9IGNzcyxcbiAgICAgIGxlbmd0aCA9IF9jc3MubGVuZ3RoO1xuICB2YXIgb2Zmc2V0ID0gLTE7XG4gIHZhciBsaW5lID0gMTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IDA7XG4gIHZhciBjb2RlLCBjb250ZW50LCBlbmRDb2x1bW4sIGVuZExpbmUsIGVzY2FwZWQsIGVzY2FwZVBvcywgbGFzdCwgbGluZXMsIG5leHQsIG5leHRMaW5lLCBuZXh0T2Zmc2V0LCBxdW90ZSwgdG9rZW5UeXBlO1xuXG4gIGZ1bmN0aW9uIHVuY2xvc2VkKHdoYXQsIGZpeCkge1xuICAgIGlmIChpbnB1dC5zYWZlKSB7XG4gICAgICAvLyBmeWk6IHRoaXMgaXMgbmV2ZXIgc2V0IHRvIHRydWUuXG4gICAgICBjc3MgKz0gZml4O1xuICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBpbnB1dC5lcnJvcignVW5jbG9zZWQgJyArIHdoYXQsIGxpbmUsIHN0YXJ0IC0gb2Zmc2V0LCBzdGFydCk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHN0YXJ0IDwgbGVuZ3RoKSB7XG4gICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICAgIGlmIChjb2RlID09PSB0Lm5ld2xpbmUpIHtcbiAgICAgIG9mZnNldCA9IHN0YXJ0O1xuICAgICAgbGluZSArPSAxO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSB0LnNwYWNlOlxuICAgICAgY2FzZSB0LnRhYjpcbiAgICAgIGNhc2UgdC5uZXdsaW5lOlxuICAgICAgY2FzZSB0LmNyOlxuICAgICAgY2FzZSB0LmZlZWQ6XG4gICAgICAgIG5leHQgPSBzdGFydDtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KTtcblxuICAgICAgICAgIGlmIChjb2RlID09PSB0Lm5ld2xpbmUpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG5leHQ7XG4gICAgICAgICAgICBsaW5lICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChjb2RlID09PSB0LnNwYWNlIHx8IGNvZGUgPT09IHQubmV3bGluZSB8fCBjb2RlID09PSB0LnRhYiB8fCBjb2RlID09PSB0LmNyIHx8IGNvZGUgPT09IHQuZmVlZCk7XG5cbiAgICAgICAgdG9rZW5UeXBlID0gdC5zcGFjZTtcbiAgICAgICAgZW5kTGluZSA9IGxpbmU7XG4gICAgICAgIGVuZENvbHVtbiA9IG5leHQgLSBvZmZzZXQgLSAxO1xuICAgICAgICBlbmQgPSBuZXh0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0LnBsdXM6XG4gICAgICBjYXNlIHQuZ3JlYXRlclRoYW46XG4gICAgICBjYXNlIHQudGlsZGU6XG4gICAgICBjYXNlIHQucGlwZTpcbiAgICAgICAgbmV4dCA9IHN0YXJ0O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICB9IHdoaWxlIChjb2RlID09PSB0LnBsdXMgfHwgY29kZSA9PT0gdC5ncmVhdGVyVGhhbiB8fCBjb2RlID09PSB0LnRpbGRlIHx8IGNvZGUgPT09IHQucGlwZSk7XG5cbiAgICAgICAgdG9rZW5UeXBlID0gdC5jb21iaW5hdG9yO1xuICAgICAgICBlbmRMaW5lID0gbGluZTtcbiAgICAgICAgZW5kQ29sdW1uID0gc3RhcnQgLSBvZmZzZXQ7XG4gICAgICAgIGVuZCA9IG5leHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gQ29uc3VtZSB0aGVzZSBjaGFyYWN0ZXJzIGFzIHNpbmdsZSB0b2tlbnMuXG5cbiAgICAgIGNhc2UgdC5hc3RlcmlzazpcbiAgICAgIGNhc2UgdC5hbXBlcnNhbmQ6XG4gICAgICBjYXNlIHQuYmFuZzpcbiAgICAgIGNhc2UgdC5jb21tYTpcbiAgICAgIGNhc2UgdC5lcXVhbHM6XG4gICAgICBjYXNlIHQuZG9sbGFyOlxuICAgICAgY2FzZSB0LmNhcmV0OlxuICAgICAgY2FzZSB0Lm9wZW5TcXVhcmU6XG4gICAgICBjYXNlIHQuY2xvc2VTcXVhcmU6XG4gICAgICBjYXNlIHQuY29sb246XG4gICAgICBjYXNlIHQuc2VtaWNvbG9uOlxuICAgICAgY2FzZSB0Lm9wZW5QYXJlbnRoZXNpczpcbiAgICAgIGNhc2UgdC5jbG9zZVBhcmVudGhlc2lzOlxuICAgICAgICBuZXh0ID0gc3RhcnQ7XG4gICAgICAgIHRva2VuVHlwZSA9IGNvZGU7XG4gICAgICAgIGVuZExpbmUgPSBsaW5lO1xuICAgICAgICBlbmRDb2x1bW4gPSBzdGFydCAtIG9mZnNldDtcbiAgICAgICAgZW5kID0gbmV4dCArIDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHQuc2luZ2xlUXVvdGU6XG4gICAgICBjYXNlIHQuZG91YmxlUXVvdGU6XG4gICAgICAgIHF1b3RlID0gY29kZSA9PT0gdC5zaW5nbGVRdW90ZSA/IFwiJ1wiIDogJ1wiJztcbiAgICAgICAgbmV4dCA9IHN0YXJ0O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKHF1b3RlLCBuZXh0ICsgMSk7XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHVuY2xvc2VkKCdxdW90ZScsIHF1b3RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuXG4gICAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSB0LmJhY2tzbGFzaCkge1xuICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChlc2NhcGVkKTtcblxuICAgICAgICB0b2tlblR5cGUgPSB0LnN0cjtcbiAgICAgICAgZW5kTGluZSA9IGxpbmU7XG4gICAgICAgIGVuZENvbHVtbiA9IHN0YXJ0IC0gb2Zmc2V0O1xuICAgICAgICBlbmQgPSBuZXh0ICsgMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjb2RlID09PSB0LnNsYXNoICYmIGNzcy5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgPT09IHQuYXN0ZXJpc2spIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoJyovJywgc3RhcnQgKyAyKSArIDE7XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gMCkge1xuICAgICAgICAgICAgdW5jbG9zZWQoJ2NvbW1lbnQnLCAnKi8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHN0YXJ0LCBuZXh0ICsgMSk7XG4gICAgICAgICAgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBsYXN0ID0gbGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgIGlmIChsYXN0ID4gMCkge1xuICAgICAgICAgICAgbmV4dExpbmUgPSBsaW5lICsgbGFzdDtcbiAgICAgICAgICAgIG5leHRPZmZzZXQgPSBuZXh0IC0gbGluZXNbbGFzdF0ubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0TGluZSA9IGxpbmU7XG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuVHlwZSA9IHQuY29tbWVudDtcbiAgICAgICAgICBsaW5lID0gbmV4dExpbmU7XG4gICAgICAgICAgZW5kTGluZSA9IG5leHRMaW5lO1xuICAgICAgICAgIGVuZENvbHVtbiA9IG5leHQgLSBuZXh0T2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IHQuc2xhc2gpIHtcbiAgICAgICAgICBuZXh0ID0gc3RhcnQ7XG4gICAgICAgICAgdG9rZW5UeXBlID0gY29kZTtcbiAgICAgICAgICBlbmRMaW5lID0gbGluZTtcbiAgICAgICAgICBlbmRDb2x1bW4gPSBzdGFydCAtIG9mZnNldDtcbiAgICAgICAgICBlbmQgPSBuZXh0ICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gY29uc3VtZVdvcmQoY3NzLCBzdGFydCk7XG4gICAgICAgICAgdG9rZW5UeXBlID0gdC53b3JkO1xuICAgICAgICAgIGVuZExpbmUgPSBsaW5lO1xuICAgICAgICAgIGVuZENvbHVtbiA9IG5leHQgLSBvZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBlbmQgPSBuZXh0ICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyBFbnN1cmUgdGhhdCB0aGUgdG9rZW4gc3RydWN0dXJlIHJlbWFpbnMgY29uc2lzdGVudFxuXG5cbiAgICB0b2tlbnMucHVzaChbdG9rZW5UeXBlLCAvLyBbMF0gVG9rZW4gdHlwZVxuICAgIGxpbmUsIC8vIFsxXSBTdGFydGluZyBsaW5lXG4gICAgc3RhcnQgLSBvZmZzZXQsIC8vIFsyXSBTdGFydGluZyBjb2x1bW5cbiAgICBlbmRMaW5lLCAvLyBbM10gRW5kaW5nIGxpbmVcbiAgICBlbmRDb2x1bW4sIC8vIFs0XSBFbmRpbmcgY29sdW1uXG4gICAgc3RhcnQsIC8vIFs1XSBTdGFydCBwb3NpdGlvbiAvIFNvdXJjZSBpbmRleFxuICAgIGVuZCAvLyBbNl0gRW5kIHBvc2l0aW9uXG4gICAgXSk7IC8vIFJlc2V0IG9mZnNldCBmb3IgdGhlIG5leHQgdG9rZW5cblxuICAgIGlmIChuZXh0T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0O1xuICAgICAgbmV4dE9mZnNldCA9IG51bGw7XG4gICAgfVxuXG4gICAgc3RhcnQgPSBlbmQ7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBlbnN1cmVPYmplY3Q7XG5cbmZ1bmN0aW9uIGVuc3VyZU9iamVjdChvYmopIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwcm9wc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB3aGlsZSAocHJvcHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBwcm9wID0gcHJvcHMuc2hpZnQoKTtcblxuICAgIGlmICghb2JqW3Byb3BdKSB7XG4gICAgICBvYmpbcHJvcF0gPSB7fTtcbiAgICB9XG5cbiAgICBvYmogPSBvYmpbcHJvcF07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGdldFByb3A7XG5cbmZ1bmN0aW9uIGdldFByb3Aob2JqKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHJvcHNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgd2hpbGUgKHByb3BzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzLnNoaWZ0KCk7XG5cbiAgICBpZiAoIW9ialtwcm9wXSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBvYmogPSBvYmpbcHJvcF07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc3RyaXBDb21tZW50cyA9IGV4cG9ydHMuZW5zdXJlT2JqZWN0ID0gZXhwb3J0cy5nZXRQcm9wID0gZXhwb3J0cy51bmVzYyA9IHZvaWQgMDtcblxudmFyIF91bmVzYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdW5lc2NcIikpO1xuXG5leHBvcnRzLnVuZXNjID0gX3VuZXNjW1wiZGVmYXVsdFwiXTtcblxudmFyIF9nZXRQcm9wID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9nZXRQcm9wXCIpKTtcblxuZXhwb3J0cy5nZXRQcm9wID0gX2dldFByb3BbXCJkZWZhdWx0XCJdO1xuXG52YXIgX2Vuc3VyZU9iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZW5zdXJlT2JqZWN0XCIpKTtcblxuZXhwb3J0cy5lbnN1cmVPYmplY3QgPSBfZW5zdXJlT2JqZWN0W1wiZGVmYXVsdFwiXTtcblxudmFyIF9zdHJpcENvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpcENvbW1lbnRzXCIpKTtcblxuZXhwb3J0cy5zdHJpcENvbW1lbnRzID0gX3N0cmlwQ29tbWVudHNbXCJkZWZhdWx0XCJdO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc3RyaXBDb21tZW50cztcblxuZnVuY3Rpb24gc3RyaXBDb21tZW50cyhzdHIpIHtcbiAgdmFyIHMgPSBcIlwiO1xuICB2YXIgY29tbWVudFN0YXJ0ID0gc3RyLmluZGV4T2YoXCIvKlwiKTtcbiAgdmFyIGxhc3RFbmQgPSAwO1xuXG4gIHdoaWxlIChjb21tZW50U3RhcnQgPj0gMCkge1xuICAgIHMgPSBzICsgc3RyLnNsaWNlKGxhc3RFbmQsIGNvbW1lbnRTdGFydCk7XG4gICAgdmFyIGNvbW1lbnRFbmQgPSBzdHIuaW5kZXhPZihcIiovXCIsIGNvbW1lbnRTdGFydCArIDIpO1xuXG4gICAgaWYgKGNvbW1lbnRFbmQgPCAwKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBsYXN0RW5kID0gY29tbWVudEVuZCArIDI7XG4gICAgY29tbWVudFN0YXJ0ID0gc3RyLmluZGV4T2YoXCIvKlwiLCBsYXN0RW5kKTtcbiAgfVxuXG4gIHMgPSBzICsgc3RyLnNsaWNlKGxhc3RFbmQpO1xuICByZXR1cm4gcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHVuZXNjO1xuXG4vLyBNYW55IHRoYW5rcyBmb3IgdGhpcyBwb3N0IHdoaWNoIG1hZGUgdGhpcyBtaWdyYXRpb24gbXVjaCBlYXNpZXIuXG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvY3NzLWVzY2FwZXNcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgXG4gKiBAcmV0dXJucyB7W3N0cmluZywgbnVtYmVyXXx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdvYmJsZUhleChzdHIpIHtcbiAgdmFyIGxvd2VyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBoZXggPSAnJztcbiAgdmFyIHNwYWNlVGVybWluYXRlZCA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNiAmJiBsb3dlcltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICB2YXIgY29kZSA9IGxvd2VyLmNoYXJDb2RlQXQoaSk7IC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgdmFsaWQgaGV4IGNoYXIgW2EtZnwwLTldXG5cbiAgICB2YXIgdmFsaWQgPSBjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyIHx8IGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NzsgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1zeW50YXgvI2NvbnN1bWUtZXNjYXBlZC1jb2RlLXBvaW50XG5cbiAgICBzcGFjZVRlcm1pbmF0ZWQgPSBjb2RlID09PSAzMjtcblxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhleCArPSBsb3dlcltpXTtcbiAgfVxuXG4gIGlmIChoZXgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgdmFyIGlzU3Vycm9nYXRlID0gY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGOyAvLyBBZGQgc3BlY2lhbCBjYXNlIGZvclxuICAvLyBcIklmIHRoaXMgbnVtYmVyIGlzIHplcm8sIG9yIGlzIGZvciBhIHN1cnJvZ2F0ZSwgb3IgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgY29kZSBwb2ludFwiXG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtc3ludGF4LyNtYXhpbXVtLWFsbG93ZWQtY29kZS1wb2ludFxuXG4gIGlmIChpc1N1cnJvZ2F0ZSB8fCBjb2RlUG9pbnQgPT09IDB4MDAwMCB8fCBjb2RlUG9pbnQgPiAweDEwRkZGRikge1xuICAgIHJldHVybiBbXCJcXHVGRkZEXCIsIGhleC5sZW5ndGggKyAoc3BhY2VUZXJtaW5hdGVkID8gMSA6IDApXTtcbiAgfVxuXG4gIHJldHVybiBbU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KSwgaGV4Lmxlbmd0aCArIChzcGFjZVRlcm1pbmF0ZWQgPyAxIDogMCldO1xufVxuXG52YXIgQ09OVEFJTlNfRVNDQVBFID0gL1xcXFwvO1xuXG5mdW5jdGlvbiB1bmVzYyhzdHIpIHtcbiAgdmFyIG5lZWRUb1Byb2Nlc3MgPSBDT05UQUlOU19FU0NBUEUudGVzdChzdHIpO1xuXG4gIGlmICghbmVlZFRvUHJvY2Vzcykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgcmV0ID0gXCJcIjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IFwiXFxcXFwiKSB7XG4gICAgICB2YXIgZ29iYmxlZCA9IGdvYmJsZUhleChzdHIuc2xpY2UoaSArIDEsIGkgKyA3KSk7XG5cbiAgICAgIGlmIChnb2JibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ICs9IGdvYmJsZWRbMF07XG4gICAgICAgIGkgKz0gZ29iYmxlZFsxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIFJldGFpbiBhIHBhaXIgb2YgXFxcXCBpZiBkb3VibGUgZXNjYXBlZCBgXFxcXFxcXFxgXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9zdGNzcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9jb21taXQvMjY4YzlhNzY1NmZiNTNmNTQzZGM2MjBhYTViNzNhMzBlYzNmZjIwZVxuXG5cbiAgICAgIGlmIChzdHJbaSArIDFdID09PSBcIlxcXFxcIikge1xuICAgICAgICByZXQgKz0gXCJcXFxcXCI7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGlmIFxcXFwgaXMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIHJldGFpbiBpdFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bvc3Rjc3MvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvY29tbWl0LzAxYTZiMzQ2ZTM2MTJjZTFhYjIwMjE5YWNjMjZhYmRjMjU5Y2NlZmJcblxuXG4gICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gaSArIDEpIHtcbiAgICAgICAgcmV0ICs9IHN0cltpXTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0ICs9IHN0cltpXTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuXG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuXG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG5cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuXG4gIGNzcyArPSBvYmouY3NzO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJcbmxldCBjb250YWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5jb250YWN0LnRleHRDb250ZW50ID0gXCJDb250YWN0XCI7XG5jb250YWN0LmNsYXNzTGlzdC5hZGQoJ2hlYWRlci1idXR0b24nKTtcblxubGV0IHNjcmVlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtaWRkbGUtd2luZG93Jyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250YWN0OyIsIlxubGV0IHNjcmVlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtaWRkbGUtd2luZG93Jyk7XG5cbmxldCBob21lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5ob21lLnRleHRDb250ZW50ID0gJ0hvbWUnO1xuaG9tZS5jbGFzc0xpc3QuYWRkKCdoZWFkZXItYnV0dG9uJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGhvbWU7XG4iLCJpbXBvcnQgaG9tZSBmcm9tICcuL2hvbWUuanMnXG5pbXBvcnQgbWVudSBmcm9tICcuL21lbnUuanMnXG5pbXBvcnQgY29udGFjdCBmcm9tICcuL2NvbnRhY3QuanMnXG5cbmltcG9ydCAnLi9zdHlsZS5jc3MnXG5pbXBvcnQgeyBpc0NvbnRhaW5lciB9IGZyb20gJ3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyJztcblxubGV0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmNvbnRlbnQuc2V0QXR0cmlidXRlKCdpZCcsJ2NvbnRlbnQnKTtcblxubGV0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG50aXRsZS5zZXRBdHRyaWJ1dGUoJ2lkJywndGl0bGUnKTtcbnRpdGxlLnRleHRDb250ZW50ID0gXCJUd2lzdGVkIENvbmVzXCI7XG5jb250ZW50LmFwcGVuZENoaWxkKHRpdGxlKTtcblxubGV0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuaGVhZGVyLnNldEF0dHJpYnV0ZSgnaWQnLCdoZWFkZXInKTtcbmhlYWRlci5hcHBlbmRDaGlsZChob21lKTtcbmhlYWRlci5hcHBlbmRDaGlsZChtZW51KTtcbmhlYWRlci5hcHBlbmRDaGlsZChjb250YWN0KTtcblxuY29udGVudC5hcHBlbmRDaGlsZChoZWFkZXIpO1xuXG5sZXQgbWlkZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5taWRkbGUuc2V0QXR0cmlidXRlKCdpZCcsJ21pZGRsZScpO1xubGV0IHNjcmVlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xud3JpdGVfaG9tZSgpO1xuc2NyZWVuLnNldEF0dHJpYnV0ZSgnaWQnLCdtaWRkbGUtd2luZG93Jyk7XG5taWRkbGUuYXBwZW5kQ2hpbGQoc2NyZWVuKTtcbmNvbnRlbnQuYXBwZW5kQ2hpbGQobWlkZGxlKTtcblxuaG9tZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsd3JpdGVfaG9tZSk7XG5cbmZ1bmN0aW9uIHdyaXRlX2hvbWUoKXtcbiAgICBzY3JlZW4uaW5uZXJIVE1MID0gJyc7XG4gICAgc2NyZWVuLnN0eWxlLmNzc1RleHQgPSBcImRpc3BheTpmbGV4OyBmbGV4LWRpcmVjdGlvbjpjb2x1bW47IGJveC1zaXppbmc6Ym9yZGVyLWJveDsgcGFkZGluZzo1MHB4OyBcIjtcbiAgICBsZXQgdGV4dDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xuICAgIHRleHQxLnNldEF0dHJpYnV0ZSgnaWQnLCAndGV4dDEnKTtcbiAgICB0ZXh0MS50ZXh0Q29udGVudCA9IFwiVGhlIGJlc3QgSWNlIENyZWFtIGNoYWluIGFyb3VuZC5cIjtcblxuICAgIGxldCB0ZXh0MiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgdGV4dDIuc2V0QXR0cmlidXRlKCdpZCcsICd0ZXh0MicpO1xuICAgIHRleHQyLnRleHRDb250ZW50ID0gXCJJY2UgQ3JlYW1zIGFyZSBwZXJzb25hbC4gU28gY3JlYXRlIHlvdXIgb3duIGZsYXZvdXIgYW5kIG1ha2UgeW91ciBjb25lIHlvdXIgb3duLiBUaGUgcG9zc2liaWxpdGVzIGFyZSBsaW1pdGxlc3MuXCI7XG5cblxuICAgIHNjcmVlbi5hcHBlbmRDaGlsZCh0ZXh0MSk7XG4gICAgc2NyZWVuLmFwcGVuZENoaWxkKHRleHQyKTtcblxufVxuXG5tZW51LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgd3JpdGVfbWVudSlcblxuZnVuY3Rpb24gd3JpdGVfbWVudSgpe1xuICAgIHNjcmVlbi5pbm5lckhUTUwgPSAnJztcbiAgICBzY3JlZW4uc3R5bGUuY3NzVGV4dCA9IFwiZGlzcGxheTogZ3JpZDsgYm94LXNpemluZzogYm9yZGVyLWJveDsgZ3JpZC10ZW1wbGF0ZTogMWZyIDFmci8gMWZyIDFmcjsgZ2FwOjIwcHg7IHBhZGRpbmc6NDBweDtcIjtcblxuICAgIGxldCBjYXJkMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNhcmQxLmNsYXNzTGlzdC5hZGQoJ2NhcmQnKTtcbiAgICBjYXJkMS50ZXh0Q29udGVudCA9IFwiQ2hvY29sYXRlXCI7XG4gICAgY2FyZDEuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJicm93blwiO1xuICAgIGNhcmQxLnN0eWxlLmNvbG9yID0gJ3doaXRlJztcblxuICAgIGxldCBjYXJkMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNhcmQyLmNsYXNzTGlzdC5hZGQoJ2NhcmQnKTtcbiAgICBjYXJkMi50ZXh0Q29udGVudCA9IFwiU3RyYXdiZXJyeVwiO1xuICAgIGNhcmQyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicGlua1wiO1xuICAgIGNhcmQyLnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcblxuICAgIGxldCBjYXJkMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNhcmQzLmNsYXNzTGlzdC5hZGQoJ2NhcmQnKTtcbiAgICBjYXJkMy50ZXh0Q29udGVudCA9IFwiUGlzdGFcIjtcbiAgICBjYXJkMy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImxpZ2h0Z3JlZW5cIjtcbiAgICBjYXJkMy5zdHlsZS5jb2xvciA9ICdibGFjayc7XG5cbiAgICBsZXQgY2FyZDQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjYXJkNC5jbGFzc0xpc3QuYWRkKCdjYXJkJyk7XG4gICAgY2FyZDQudGV4dENvbnRlbnQgPSBcIkJsYWNrIEN1cnJhbnRcIjtcbiAgICBjYXJkNC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImdyYXlcIjtcbiAgICBjYXJkNC5zdHlsZS5jb2xvciA9ICd3aGl0ZSc7XG5cbiAgICBzY3JlZW4uYXBwZW5kQ2hpbGQoY2FyZDEpO1xuICAgIHNjcmVlbi5hcHBlbmRDaGlsZChjYXJkMik7XG4gICAgc2NyZWVuLmFwcGVuZENoaWxkKGNhcmQzKTtcbiAgICBzY3JlZW4uYXBwZW5kQ2hpbGQoY2FyZDQpO1xuXG59XG5cbmNvbnRhY3QuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB3cml0ZV9jb250YWN0KVxuXG5mdW5jdGlvbiB3cml0ZV9jb250YWN0KCl7XG4gICAgc2NyZWVuLmlubmVySFRNTCA9ICcnO1xuICAgIHNjcmVlbi5zdHlsZS5jc3NUZXh0ID0gXCJcIjtcblxuICAgIGxldCBjMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBwMTEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgcDExLnRleHRDb250ZW50ID0gXCJSb2NreSBCaGFpXCJcbiAgICBwMTEuc3R5bGUuZm9udFNpemUgPSBcIjMwcHhcIjtcblxuICAgIGxldCBwMTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgcDEyLnRleHRDb250ZW50ID0gXCJDRU8gb2YgSW5kaWFcIjtcblxuICAgIGxldCBwMTMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgcDEzLnRleHRDb250ZW50ID0gXCJyb2NreWFzaEBuYXJhY2hpLmNvLmluXCI7XG4gICAgYzEuYXBwZW5kQ2hpbGQocDExKTtcbiAgICBjMS5hcHBlbmRDaGlsZChwMTIpO1xuICAgIGMxLmFwcGVuZENoaWxkKHAxMyk7XG5cbiAgICBzY3JlZW4uYXBwZW5kQ2hpbGQoYzEpO1xuXG4gICAgXG5lYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgXG5cblxufVxuXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuIiwibGV0IHNjcmVlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtaWRkbGUtd2luZG93Jyk7XG5cbmxldCBtZW51ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5tZW51LnRleHRDb250ZW50ID0gXCJNZW51XCI7XG5tZW51LmNsYXNzTGlzdC5hZGQoJ2hlYWRlci1idXR0b24nKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IG1lbnU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9