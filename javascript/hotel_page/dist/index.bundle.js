(self["webpackChunkhotel_page"] = self["webpackChunkhotel_page"] || []).push([["index"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! icon.svg */ "./src/icon.svg"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "*{\n    caret-color: transparent;\n}\n\nbody{\n    margin: 0;\n}\n\n#title{\n    \n    height: 10vh;\n    background-color: rgba(209, 155, 55, 0.863);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    font-size: 30px;\n    font-family: 'Lobster', sans-serif;\n}\n\n\n#header{\n    display: flex;\n    height: 10vh;\n    justify-content: center;\n    align-items: center;\n    gap:30px;\n    background-color: grey;\n    font-family: 'Josefin Sans', sans-serif;\n    font-size: 25px;\n    font-weight: 400;\n}\n\n#middle{\n    display:flex;\n    background-color: rgb(88, 83, 33);\n    height: 90vh;\n    justify-content: center;\n    align-items: center;\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n    font-family: 'Josefin Sans', sans-serif;\n}\n\n#middle-window{\n    background-color: rgba(0, 0, 0, 0.7);\n    color:white;\n    height: 70%;\n    width: 50%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: 10px;\n}\n\n.header-button{\n    caret-color: transparent;\n    /* background-color: turquoise; */\n    height: 50px;\n    width: 150px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n}\n\n.header-button:hover{\n    border-bottom: 3px solid white;\n}\n\n.card{\n    height:100%;\n    width:100%;\n    display: flex;    \n    justify-content: center;\n    align-items: center;\n    border-radius: 10px;\n    font-size: 20px;\n}", "",{"version":3,"sources":["webpack://./src/style.css"],"names":[],"mappings":"AAAA;IACI,wBAAwB;AAC5B;;AAEA;IACI,SAAS;AACb;;AAEA;;IAEI,YAAY;IACZ,2CAA2C;IAC3C,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,eAAe;IACf,kCAAkC;AACtC;;;AAGA;IACI,aAAa;IACb,YAAY;IACZ,uBAAuB;IACvB,mBAAmB;IACnB,QAAQ;IACR,sBAAsB;IACtB,uCAAuC;IACvC,eAAe;IACf,gBAAgB;AACpB;;AAEA;IACI,YAAY;IACZ,iCAAiC;IACjC,YAAY;IACZ,uBAAuB;IACvB,mBAAmB;IACnB,mDAA2B;IAC3B,uCAAuC;AAC3C;;AAEA;IACI,oCAAoC;IACpC,WAAW;IACX,WAAW;IACX,UAAU;IACV,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,mBAAmB;AACvB;;AAEA;IACI,wBAAwB;IACxB,iCAAiC;IACjC,YAAY;IACZ,YAAY;IACZ,aAAa;IACb,uBAAuB;IACvB,mBAAmB;;AAEvB;;AAEA;IACI,8BAA8B;AAClC;;AAEA;IACI,WAAW;IACX,UAAU;IACV,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,mBAAmB;IACnB,eAAe;AACnB","sourcesContent":["*{\n    caret-color: transparent;\n}\n\nbody{\n    margin: 0;\n}\n\n#title{\n    \n    height: 10vh;\n    background-color: rgba(209, 155, 55, 0.863);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    font-size: 30px;\n    font-family: 'Lobster', sans-serif;\n}\n\n\n#header{\n    display: flex;\n    height: 10vh;\n    justify-content: center;\n    align-items: center;\n    gap:30px;\n    background-color: grey;\n    font-family: 'Josefin Sans', sans-serif;\n    font-size: 25px;\n    font-weight: 400;\n}\n\n#middle{\n    display:flex;\n    background-color: rgb(88, 83, 33);\n    height: 90vh;\n    justify-content: center;\n    align-items: center;\n    background: url('icon.svg');\n    font-family: 'Josefin Sans', sans-serif;\n}\n\n#middle-window{\n    background-color: rgba(0, 0, 0, 0.7);\n    color:white;\n    height: 70%;\n    width: 50%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: 10px;\n}\n\n.header-button{\n    caret-color: transparent;\n    /* background-color: turquoise; */\n    height: 50px;\n    width: 150px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n}\n\n.header-button:hover{\n    border-bottom: 3px solid white;\n}\n\n.card{\n    height:100%;\n    width:100%;\n    display: flex;    \n    justify-content: center;\n    align-items: center;\n    border-radius: 10px;\n    font-size: 20px;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }

  if (!url) {
    return url;
  }

  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them

  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }

  if (options.hash) {
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/cssesc/cssesc.js":
/*!***************************************!*\
  !*** ./node_modules/cssesc/cssesc.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
/*! https://mths.be/cssesc v3.0.0 by @mathias */


var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge = function merge(options, defaults) {
	if (!options) {
		return defaults;
	}
	var result = {};
	for (var key in defaults) {
		// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
		// only recognized option names are used.
		result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
	}
	return result;
};

var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexAlwaysEscape = /['"\\]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
	options = merge(options, cssesc.options);
	if (options.quotes != 'single' && options.quotes != 'double') {
		options.quotes = 'single';
	}
	var quote = options.quotes == 'double' ? '"' : '\'';
	var isIdentifier = options.isIdentifier;

	var firstChar = string.charAt(0);
	var output = '';
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var character = string.charAt(counter++);
		var codePoint = character.charCodeAt();
		var value = void 0;
		// If it’s not a printable ASCII character…
		if (codePoint < 0x20 || codePoint > 0x7E) {
			if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
				// It’s a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// next character is low surrogate
					codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
				} else {
					// It’s an unmatched surrogate; only append this code unit, in case
					// the next code unit is the high surrogate of a surrogate pair.
					counter--;
				}
			}
			value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
		} else {
			if (options.escapeEverything) {
				if (regexAnySingleEscape.test(character)) {
					value = '\\' + character;
				} else {
					value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
				}
			} else if (/[\t\n\f\r\x0B]/.test(character)) {
				value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
			} else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
				value = '\\' + character;
			} else {
				value = character;
			}
		}
		output += value;
	}

	if (isIdentifier) {
		if (/^-[-\d]/.test(output)) {
			output = '\\-' + output.slice(1);
		} else if (/\d/.test(firstChar)) {
			output = '\\3' + firstChar + ' ' + output.slice(1);
		}
	}

	// Remove spaces after `\HEX` escapes that are not followed by a hex digit,
	// since they’re redundant. Note that this is only possible if the escape
	// sequence isn’t preceded by an odd number of backslashes.
	output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
		if ($1 && $1.length % 2) {
			// It’s not safe to remove the space, so don’t.
			return $0;
		}
		// Strip the space.
		return ($1 || '') + $2;
	});

	if (!isIdentifier && options.wrap) {
		return quote + output + quote;
	}
	return output;
};

// Expose default options (so they can be overridden globally).
cssesc.options = {
	'escapeEverything': false,
	'isIdentifier': false,
	'quotes': 'single',
	'wrap': false
};

cssesc.version = '3.0.0';

module.exports = cssesc;


/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/index.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _processor = _interopRequireDefault(__webpack_require__(/*! ./processor */ "./node_modules/postcss-selector-parser/dist/processor.js"));

var selectors = _interopRequireWildcard(__webpack_require__(/*! ./selectors */ "./node_modules/postcss-selector-parser/dist/selectors/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var parser = function parser(processor) {
  return new _processor["default"](processor);
};

Object.assign(parser, selectors);
delete parser.__esModule;
var _default = parser;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/parser.js":
/*!*************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/parser.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _root = _interopRequireDefault(__webpack_require__(/*! ./selectors/root */ "./node_modules/postcss-selector-parser/dist/selectors/root.js"));

var _selector = _interopRequireDefault(__webpack_require__(/*! ./selectors/selector */ "./node_modules/postcss-selector-parser/dist/selectors/selector.js"));

var _className = _interopRequireDefault(__webpack_require__(/*! ./selectors/className */ "./node_modules/postcss-selector-parser/dist/selectors/className.js"));

var _comment = _interopRequireDefault(__webpack_require__(/*! ./selectors/comment */ "./node_modules/postcss-selector-parser/dist/selectors/comment.js"));

var _id = _interopRequireDefault(__webpack_require__(/*! ./selectors/id */ "./node_modules/postcss-selector-parser/dist/selectors/id.js"));

var _tag = _interopRequireDefault(__webpack_require__(/*! ./selectors/tag */ "./node_modules/postcss-selector-parser/dist/selectors/tag.js"));

var _string = _interopRequireDefault(__webpack_require__(/*! ./selectors/string */ "./node_modules/postcss-selector-parser/dist/selectors/string.js"));

var _pseudo = _interopRequireDefault(__webpack_require__(/*! ./selectors/pseudo */ "./node_modules/postcss-selector-parser/dist/selectors/pseudo.js"));

var _attribute = _interopRequireWildcard(__webpack_require__(/*! ./selectors/attribute */ "./node_modules/postcss-selector-parser/dist/selectors/attribute.js"));

var _universal = _interopRequireDefault(__webpack_require__(/*! ./selectors/universal */ "./node_modules/postcss-selector-parser/dist/selectors/universal.js"));

var _combinator = _interopRequireDefault(__webpack_require__(/*! ./selectors/combinator */ "./node_modules/postcss-selector-parser/dist/selectors/combinator.js"));

var _nesting = _interopRequireDefault(__webpack_require__(/*! ./selectors/nesting */ "./node_modules/postcss-selector-parser/dist/selectors/nesting.js"));

var _sortAscending = _interopRequireDefault(__webpack_require__(/*! ./sortAscending */ "./node_modules/postcss-selector-parser/dist/sortAscending.js"));

var _tokenize = _interopRequireWildcard(__webpack_require__(/*! ./tokenize */ "./node_modules/postcss-selector-parser/dist/tokenize.js"));

var tokens = _interopRequireWildcard(__webpack_require__(/*! ./tokenTypes */ "./node_modules/postcss-selector-parser/dist/tokenTypes.js"));

var types = _interopRequireWildcard(__webpack_require__(/*! ./selectors/types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js"));

var _util = __webpack_require__(/*! ./util */ "./node_modules/postcss-selector-parser/dist/util/index.js");

var _WHITESPACE_TOKENS, _Object$assign;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));

function tokenStart(token) {
  return {
    line: token[_tokenize.FIELDS.START_LINE],
    column: token[_tokenize.FIELDS.START_COL]
  };
}

function tokenEnd(token) {
  return {
    line: token[_tokenize.FIELDS.END_LINE],
    column: token[_tokenize.FIELDS.END_COL]
  };
}

function getSource(startLine, startColumn, endLine, endColumn) {
  return {
    start: {
      line: startLine,
      column: startColumn
    },
    end: {
      line: endLine,
      column: endColumn
    }
  };
}

function getTokenSource(token) {
  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
}

function getTokenSourceSpan(startToken, endToken) {
  if (!startToken) {
    return undefined;
  }

  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
}

function unescapeProp(node, prop) {
  var value = node[prop];

  if (typeof value !== "string") {
    return;
  }

  if (value.indexOf("\\") !== -1) {
    (0, _util.ensureObject)(node, 'raws');
    node[prop] = (0, _util.unesc)(value);

    if (node.raws[prop] === undefined) {
      node.raws[prop] = value;
    }
  }

  return node;
}

function indexesOf(array, item) {
  var i = -1;
  var indexes = [];

  while ((i = array.indexOf(item, i + 1)) !== -1) {
    indexes.push(i);
  }

  return indexes;
}

function uniqs() {
  var list = Array.prototype.concat.apply([], arguments);
  return list.filter(function (item, i) {
    return i === list.indexOf(item);
  });
}

var Parser = /*#__PURE__*/function () {
  function Parser(rule, options) {
    if (options === void 0) {
      options = {};
    }

    this.rule = rule;
    this.options = Object.assign({
      lossy: false,
      safe: false
    }, options);
    this.position = 0;
    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
    this.tokens = (0, _tokenize["default"])({
      css: this.css,
      error: this._errorGenerator(),
      safe: this.options.safe
    });
    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
    this.root = new _root["default"]({
      source: rootSource
    });
    this.root.errorGenerator = this._errorGenerator();
    var selector = new _selector["default"]({
      source: {
        start: {
          line: 1,
          column: 1
        }
      }
    });
    this.root.append(selector);
    this.current = selector;
    this.loop();
  }

  var _proto = Parser.prototype;

  _proto._errorGenerator = function _errorGenerator() {
    var _this = this;

    return function (message, errorOptions) {
      if (typeof _this.rule === 'string') {
        return new Error(message);
      }

      return _this.rule.error(message, errorOptions);
    };
  };

  _proto.attribute = function attribute() {
    var attr = [];
    var startingToken = this.currToken;
    this.position++;

    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      attr.push(this.currToken);
      this.position++;
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
    }

    var len = attr.length;
    var node = {
      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
    };

    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
    }

    var pos = 0;
    var spaceBefore = '';
    var commentBefore = '';
    var lastAdded = null;
    var spaceAfterMeaningfulToken = false;

    while (pos < len) {
      var token = attr[pos];
      var content = this.content(token);
      var next = attr[pos + 1];

      switch (token[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          // if (
          //     len === 1 ||
          //     pos === 0 && this.content(next) === '|'
          // ) {
          //     return this.expected('attribute', token[TOKEN.START_POS], content);
          // }
          spaceAfterMeaningfulToken = true;

          if (this.options.lossy) {
            break;
          }

          if (lastAdded) {
            (0, _util.ensureObject)(node, 'spaces', lastAdded);
            var prevContent = node.spaces[lastAdded].after || '';
            node.spaces[lastAdded].after = prevContent + content;
            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

            if (existingComment) {
              node.raws.spaces[lastAdded].after = existingComment + content;
            }
          } else {
            spaceBefore = spaceBefore + content;
            commentBefore = commentBefore + content;
          }

          break;

        case tokens.asterisk:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = spaceBefore;
              commentBefore = '';
            }

            node.namespace = (node.namespace || "") + content;
            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;

            if (rawValue) {
              node.raws.namespace += content;
            }

            lastAdded = 'namespace';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.dollar:
          if (lastAdded === "value") {
            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
            node.value += "$";

            if (oldRawValue) {
              node.raws.value = oldRawValue + "$";
            }

            break;
          }

        // Falls through

        case tokens.caret:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.combinator:
          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          if (content !== '|') {
            spaceAfterMeaningfulToken = false;
            break;
          }

          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if (!node.namespace && !node.attribute) {
            node.namespace = true;
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.word:
          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
          !node.operator && !node.namespace) {
            node.namespace = content;
            lastAdded = 'namespace';
          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = commentBefore;
              commentBefore = '';
            }

            node.attribute = (node.attribute || "") + content;

            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;

            if (_rawValue) {
              node.raws.attribute += content;
            }

            lastAdded = 'attribute';
          } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
            var _unescaped = (0, _util.unesc)(content);

            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';

            var oldValue = node.value || '';
            node.value = oldValue + _unescaped;
            node.quoteMark = null;

            if (_unescaped !== content || _oldRawValue) {
              (0, _util.ensureObject)(node, 'raws');
              node.raws.value = (_oldRawValue || oldValue) + content;
            }

            lastAdded = 'value';
          } else {
            var insensitive = content === 'i' || content === "I";

            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
              node.insensitive = insensitive;

              if (!insensitive || content === "I") {
                (0, _util.ensureObject)(node, 'raws');
                node.raws.insensitiveFlag = content;
              }

              lastAdded = 'insensitive';

              if (spaceBefore) {
                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                node.spaces.insensitive.before = spaceBefore;
                spaceBefore = '';
              }

              if (commentBefore) {
                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                node.raws.spaces.insensitive.before = commentBefore;
                commentBefore = '';
              }
            } else if (node.value || node.value === '') {
              lastAdded = 'value';
              node.value += content;

              if (node.raws.value) {
                node.raws.value += content;
              }
            }
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.str:
          if (!node.attribute || !node.operator) {
            return this.error("Expected an attribute followed by an operator preceding the string.", {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          var _unescapeValue = (0, _attribute.unescapeValue)(content),
              unescaped = _unescapeValue.unescaped,
              quoteMark = _unescapeValue.quoteMark;

          node.value = unescaped;
          node.quoteMark = quoteMark;
          lastAdded = 'value';
          (0, _util.ensureObject)(node, 'raws');
          node.raws.value = content;
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.equals:
          if (!node.attribute) {
            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
          }

          if (node.value) {
            return this.error('Unexpected "=" found; an operator was already defined.', {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          node.operator = node.operator ? node.operator + content : content;
          lastAdded = 'operator';
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.comment:
          if (lastAdded) {
            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
              node.raws.spaces[lastAdded].after = rawLastComment + content;
            } else {
              var lastValue = node[lastAdded] || '';
              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
              (0, _util.ensureObject)(node, 'raws');
              node.raws[lastAdded] = rawLastValue + content;
            }
          } else {
            commentBefore = commentBefore + content;
          }

          break;

        default:
          return this.error("Unexpected \"" + content + "\" found.", {
            index: token[_tokenize.FIELDS.START_POS]
          });
      }

      pos++;
    }

    unescapeProp(node, "attribute");
    unescapeProp(node, "namespace");
    this.newNode(new _attribute["default"](node));
    this.position++;
  }
  /**
   * return a node containing meaningless garbage up to (but not including) the specified token position.
   * if the token position is negative, all remaining tokens are consumed.
   *
   * This returns an array containing a single string node if all whitespace,
   * otherwise an array of comment nodes with space before and after.
   *
   * These tokens are not added to the current selector, the caller can add them or use them to amend
   * a previous node's space metadata.
   *
   * In lossy mode, this returns only comments.
   */
  ;

  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
    if (stopPosition < 0) {
      stopPosition = this.tokens.length;
    }

    var startPosition = this.position;
    var nodes = [];
    var space = "";
    var lastComment = undefined;

    do {
      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        if (!this.options.lossy) {
          space += this.content();
        }
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
        var spaces = {};

        if (space) {
          spaces.before = space;
          space = "";
        }

        lastComment = new _comment["default"]({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          spaces: spaces
        });
        nodes.push(lastComment);
      }
    } while (++this.position < stopPosition);

    if (space) {
      if (lastComment) {
        lastComment.spaces.after = space;
      } else if (!this.options.lossy) {
        var firstToken = this.tokens[startPosition];
        var lastToken = this.tokens[this.position - 1];
        nodes.push(new _string["default"]({
          value: '',
          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces: {
            before: space,
            after: ''
          }
        }));
      }
    }

    return nodes;
  }
  /**
   * 
   * @param {*} nodes 
   */
  ;

  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
    var _this2 = this;

    if (requiredSpace === void 0) {
      requiredSpace = false;
    }

    var space = "";
    var rawSpace = "";
    nodes.forEach(function (n) {
      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);

      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);

      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
    });

    if (rawSpace === space) {
      rawSpace = undefined;
    }

    var result = {
      space: space,
      rawSpace: rawSpace
    };
    return result;
  };

  _proto.isNamedCombinator = function isNamedCombinator(position) {
    if (position === void 0) {
      position = this.position;
    }

    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
  };

  _proto.namedCombinator = function namedCombinator() {
    if (this.isNamedCombinator()) {
      var nameRaw = this.content(this.tokens[this.position + 1]);
      var name = (0, _util.unesc)(nameRaw).toLowerCase();
      var raws = {};

      if (name !== nameRaw) {
        raws.value = "/" + nameRaw + "/";
      }

      var node = new _combinator["default"]({
        value: "/" + name + "/",
        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
        raws: raws
      });
      this.position = this.position + 3;
      return node;
    } else {
      this.unexpected();
    }
  };

  _proto.combinator = function combinator() {
    var _this3 = this;

    if (this.content() === '|') {
      return this.namespace();
    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.


    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);

      if (nodes.length > 0) {
        var last = this.current.last;

        if (last) {
          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
              space = _this$convertWhitespa.space,
              rawSpace = _this$convertWhitespa.rawSpace;

          if (rawSpace !== undefined) {
            last.rawSpaceAfter += rawSpace;
          }

          last.spaces.after += space;
        } else {
          nodes.forEach(function (n) {
            return _this3.newNode(n);
          });
        }
      }

      return;
    }

    var firstToken = this.currToken;
    var spaceOrDescendantSelectorNodes = undefined;

    if (nextSigTokenPos > this.position) {
      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
    }

    var node;

    if (this.isNamedCombinator()) {
      node = this.namedCombinator();
    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
      node = new _combinator["default"]({
        value: this.content(),
        source: getTokenSource(this.currToken),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
      });
      this.position++;
    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass
    } else if (!spaceOrDescendantSelectorNodes) {
      this.unexpected();
    }

    if (node) {
      if (spaceOrDescendantSelectorNodes) {
        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
            _space = _this$convertWhitespa2.space,
            _rawSpace = _this$convertWhitespa2.rawSpace;

        node.spaces.before = _space;
        node.rawSpaceBefore = _rawSpace;
      }
    } else {
      // descendant combinator
      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
          _space2 = _this$convertWhitespa3.space,
          _rawSpace2 = _this$convertWhitespa3.rawSpace;

      if (!_rawSpace2) {
        _rawSpace2 = _space2;
      }

      var spaces = {};
      var raws = {
        spaces: {}
      };

      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
        spaces.before = _space2.slice(0, _space2.length - 1);
        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
        spaces.after = _space2.slice(1);
        raws.spaces.after = _rawSpace2.slice(1);
      } else {
        raws.value = _rawSpace2;
      }

      node = new _combinator["default"]({
        value: ' ',
        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
        spaces: spaces,
        raws: raws
      });
    }

    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
      node.spaces.after = this.optionalSpace(this.content());
      this.position++;
    }

    return this.newNode(node);
  };

  _proto.comma = function comma() {
    if (this.position === this.tokens.length - 1) {
      this.root.trailingComma = true;
      this.position++;
      return;
    }

    this.current._inferEndPosition();

    var selector = new _selector["default"]({
      source: {
        start: tokenStart(this.tokens[this.position + 1])
      }
    });
    this.current.parent.append(selector);
    this.current = selector;
    this.position++;
  };

  _proto.comment = function comment() {
    var current = this.currToken;
    this.newNode(new _comment["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.error = function error(message, opts) {
    throw this.root.error(message, opts);
  };

  _proto.missingBackslash = function missingBackslash() {
    return this.error('Expected a backslash preceding the semicolon.', {
      index: this.currToken[_tokenize.FIELDS.START_POS]
    });
  };

  _proto.missingParenthesis = function missingParenthesis() {
    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.missingSquareBracket = function missingSquareBracket() {
    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.unexpected = function unexpected() {
    return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.namespace = function namespace() {
    var before = this.prevToken && this.content(this.prevToken) || true;

    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.position++;
      return this.word(before);
    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
      this.position++;
      return this.universal(before);
    }
  };

  _proto.nesting = function nesting() {
    if (this.nextToken) {
      var nextContent = this.content(this.nextToken);

      if (nextContent === "|") {
        this.position++;
        return;
      }
    }

    var current = this.currToken;
    this.newNode(new _nesting["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.parentheses = function parentheses() {
    var last = this.current.last;
    var unbalanced = 1;
    this.position++;

    if (last && last.type === types.PSEUDO) {
      var selector = new _selector["default"]({
        source: {
          start: tokenStart(this.tokens[this.position - 1])
        }
      });
      var cache = this.current;
      last.append(selector);
      this.current = selector;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        if (unbalanced) {
          this.parse();
        } else {
          this.current.source.end = tokenEnd(this.currToken);
          this.current.parent.source.end = tokenEnd(this.currToken);
          this.position++;
        }
      }

      this.current = cache;
    } else {
      // I think this case should be an error. It's used to implement a basic parse of media queries
      // but I don't think it's a good idea.
      var parenStart = this.currToken;
      var parenValue = "(";
      var parenEnd;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        parenEnd = this.currToken;
        parenValue += this.parseParenthesisToken(this.currToken);
        this.position++;
      }

      if (last) {
        last.appendToPropertyAndEscape("value", parenValue, parenValue);
      } else {
        this.newNode(new _string["default"]({
          value: parenValue,
          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
        }));
      }
    }

    if (unbalanced) {
      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.pseudo = function pseudo() {
    var _this4 = this;

    var pseudoStr = '';
    var startingToken = this.currToken;

    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
      pseudoStr += this.content();
      this.position++;
    }

    if (!this.currToken) {
      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.splitWord(false, function (first, length) {
        pseudoStr += first;

        _this4.newNode(new _pseudo["default"]({
          value: pseudoStr,
          source: getTokenSourceSpan(startingToken, _this4.currToken),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        }));

        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          _this4.error('Misplaced parenthesis.', {
            index: _this4.nextToken[_tokenize.FIELDS.START_POS]
          });
        }
      });
    } else {
      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.space = function space() {
    var content = this.content(); // Handle space before and after the selector

    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
      return node.type === 'comment';
    })) {
      this.spaces = this.optionalSpace(content);
      this.position++;
    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
      this.current.last.spaces.after = this.optionalSpace(content);
      this.position++;
    } else {
      this.combinator();
    }
  };

  _proto.string = function string() {
    var current = this.currToken;
    this.newNode(new _string["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.universal = function universal(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    var current = this.currToken;
    this.newNode(new _universal["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }), namespace);
    this.position++;
  };

  _proto.splitWord = function splitWord(namespace, firstCallback) {
    var _this5 = this;

    var nextToken = this.nextToken;
    var word = this.content();

    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
      this.position++;
      var current = this.content();
      word += current;

      if (current.lastIndexOf('\\') === current.length - 1) {
        var next = this.nextToken;

        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
          word += this.requiredSpace(this.content(next));
          this.position++;
        }
      }

      nextToken = this.nextToken;
    }

    var hasClass = indexesOf(word, '.').filter(function (i) {
      // Allow escaped dot within class name
      var escapedDot = word[i - 1] === '\\'; // Allow decimal numbers percent in @keyframes

      var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
      return !escapedDot && !isKeyframesPercent;
    });
    var hasId = indexesOf(word, '#').filter(function (i) {
      return word[i - 1] !== '\\';
    }); // Eliminate Sass interpolations from the list of id indexes

    var interpolations = indexesOf(word, '#{');

    if (interpolations.length) {
      hasId = hasId.filter(function (hashIndex) {
        return !~interpolations.indexOf(hashIndex);
      });
    }

    var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
    indices.forEach(function (ind, i) {
      var index = indices[i + 1] || word.length;
      var value = word.slice(ind, index);

      if (i === 0 && firstCallback) {
        return firstCallback.call(_this5, value, indices.length);
      }

      var node;
      var current = _this5.currToken;
      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

      if (~hasClass.indexOf(ind)) {
        var classNameOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _className["default"](unescapeProp(classNameOpts, "value"));
      } else if (~hasId.indexOf(ind)) {
        var idOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _id["default"](unescapeProp(idOpts, "value"));
      } else {
        var tagOpts = {
          value: value,
          source: source,
          sourceIndex: sourceIndex
        };
        unescapeProp(tagOpts, "value");
        node = new _tag["default"](tagOpts);
      }

      _this5.newNode(node, namespace); // Ensure that the namespace is used only once


      namespace = null;
    });
    this.position++;
  };

  _proto.word = function word(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    return this.splitWord(namespace);
  };

  _proto.loop = function loop() {
    while (this.position < this.tokens.length) {
      this.parse(true);
    }

    this.current._inferEndPosition();

    return this.root;
  };

  _proto.parse = function parse(throwOnParenthesis) {
    switch (this.currToken[_tokenize.FIELDS.TYPE]) {
      case tokens.space:
        this.space();
        break;

      case tokens.comment:
        this.comment();
        break;

      case tokens.openParenthesis:
        this.parentheses();
        break;

      case tokens.closeParenthesis:
        if (throwOnParenthesis) {
          this.missingParenthesis();
        }

        break;

      case tokens.openSquare:
        this.attribute();
        break;

      case tokens.dollar:
      case tokens.caret:
      case tokens.equals:
      case tokens.word:
        this.word();
        break;

      case tokens.colon:
        this.pseudo();
        break;

      case tokens.comma:
        this.comma();
        break;

      case tokens.asterisk:
        this.universal();
        break;

      case tokens.ampersand:
        this.nesting();
        break;

      case tokens.slash:
      case tokens.combinator:
        this.combinator();
        break;

      case tokens.str:
        this.string();
        break;
      // These cases throw; no break needed.

      case tokens.closeSquare:
        this.missingSquareBracket();

      case tokens.semicolon:
        this.missingBackslash();

      default:
        this.unexpected();
    }
  }
  /**
   * Helpers
   */
  ;

  _proto.expected = function expected(description, index, found) {
    if (Array.isArray(description)) {
      var last = description.pop();
      description = description.join(', ') + " or " + last;
    }

    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

    if (!found) {
      return this.error("Expected " + an + " " + description + ".", {
        index: index
      });
    }

    return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
      index: index
    });
  };

  _proto.requiredSpace = function requiredSpace(space) {
    return this.options.lossy ? ' ' : space;
  };

  _proto.optionalSpace = function optionalSpace(space) {
    return this.options.lossy ? '' : space;
  };

  _proto.lossySpace = function lossySpace(space, required) {
    if (this.options.lossy) {
      return required ? ' ' : '';
    } else {
      return space;
    }
  };

  _proto.parseParenthesisToken = function parseParenthesisToken(token) {
    var content = this.content(token);

    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
      return this.requiredSpace(content);
    } else {
      return content;
    }
  };

  _proto.newNode = function newNode(node, namespace) {
    if (namespace) {
      if (/^ +$/.test(namespace)) {
        if (!this.options.lossy) {
          this.spaces = (this.spaces || '') + namespace;
        }

        namespace = true;
      }

      node.namespace = namespace;
      unescapeProp(node, "namespace");
    }

    if (this.spaces) {
      node.spaces.before = this.spaces;
      this.spaces = '';
    }

    return this.current.append(node);
  };

  _proto.content = function content(token) {
    if (token === void 0) {
      token = this.currToken;
    }

    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
  };

  /**
   * returns the index of the next non-whitespace, non-comment token.
   * returns -1 if no meaningful token is found.
   */
  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
    if (startPosition === void 0) {
      startPosition = this.position + 1;
    }

    var searchPosition = startPosition;

    while (searchPosition < this.tokens.length) {
      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
        searchPosition++;
        continue;
      } else {
        return searchPosition;
      }
    }

    return -1;
  };

  _createClass(Parser, [{
    key: "currToken",
    get: function get() {
      return this.tokens[this.position];
    }
  }, {
    key: "nextToken",
    get: function get() {
      return this.tokens[this.position + 1];
    }
  }, {
    key: "prevToken",
    get: function get() {
      return this.tokens[this.position - 1];
    }
  }]);

  return Parser;
}();

exports["default"] = Parser;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/processor.js":
/*!****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/processor.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _parser = _interopRequireDefault(__webpack_require__(/*! ./parser */ "./node_modules/postcss-selector-parser/dist/parser.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Processor = /*#__PURE__*/function () {
  function Processor(func, options) {
    this.func = func || function noop() {};

    this.funcRes = null;
    this.options = options;
  }

  var _proto = Processor.prototype;

  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.updateSelector === false) {
      return false;
    } else {
      return typeof rule !== "string";
    }
  };

  _proto._isLossy = function _isLossy(options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.lossless === false) {
      return true;
    } else {
      return false;
    }
  };

  _proto._root = function _root(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var parser = new _parser["default"](rule, this._parseOptions(options));
    return parser.root;
  };

  _proto._parseOptions = function _parseOptions(options) {
    return {
      lossy: this._isLossy(options)
    };
  };

  _proto._run = function _run(rule, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    return new Promise(function (resolve, reject) {
      try {
        var root = _this._root(rule, options);

        Promise.resolve(_this.func(root)).then(function (transform) {
          var string = undefined;

          if (_this._shouldUpdateSelector(rule, options)) {
            string = root.toString();
            rule.selector = string;
          }

          return {
            transform: transform,
            root: root,
            string: string
          };
        }).then(resolve, reject);
      } catch (e) {
        reject(e);
        return;
      }
    });
  };

  _proto._runSync = function _runSync(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var root = this._root(rule, options);

    var transform = this.func(root);

    if (transform && typeof transform.then === "function") {
      throw new Error("Selector processor returned a promise to a synchronous call.");
    }

    var string = undefined;

    if (options.updateSelector && typeof rule !== "string") {
      string = root.toString();
      rule.selector = string;
    }

    return {
      transform: transform,
      root: root,
      string: string
    };
  }
  /**
   * Process rule into a selector AST.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<parser.Root>} The AST of the selector after processing it.
   */
  ;

  _proto.ast = function ast(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.root;
    });
  }
  /**
   * Process rule into a selector AST synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {parser.Root} The AST of the selector after processing it.
   */
  ;

  _proto.astSync = function astSync(rule, options) {
    return this._runSync(rule, options).root;
  }
  /**
   * Process a selector into a transformed value asynchronously
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<any>} The value returned by the processor.
   */
  ;

  _proto.transform = function transform(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.transform;
    });
  }
  /**
   * Process a selector into a transformed value synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {any} The value returned by the processor.
   */
  ;

  _proto.transformSync = function transformSync(rule, options) {
    return this._runSync(rule, options).transform;
  }
  /**
   * Process a selector into a new selector string asynchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.process = function process(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.string || result.root.toString();
    });
  }
  /**
   * Process a selector into a new selector string synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.processSync = function processSync(rule, options) {
    var result = this._runSync(rule, options);

    return result.string || result.root.toString();
  };

  return Processor;
}();

exports["default"] = Processor;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/attribute.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/attribute.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.unescapeValue = unescapeValue;
exports["default"] = void 0;

var _cssesc = _interopRequireDefault(__webpack_require__(/*! cssesc */ "./node_modules/cssesc/cssesc.js"));

var _unesc = _interopRequireDefault(__webpack_require__(/*! ../util/unesc */ "./node_modules/postcss-selector-parser/dist/util/unesc.js"));

var _namespace = _interopRequireDefault(__webpack_require__(/*! ./namespace */ "./node_modules/postcss-selector-parser/dist/selectors/namespace.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

var _CSSESC_QUOTE_OPTIONS;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var deprecate = __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js");

var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

function unescapeValue(value) {
  var deprecatedUsage = false;
  var quoteMark = null;
  var unescaped = value;
  var m = unescaped.match(WRAPPED_IN_QUOTES);

  if (m) {
    quoteMark = m[1];
    unescaped = m[2];
  }

  unescaped = (0, _unesc["default"])(unescaped);

  if (unescaped !== value) {
    deprecatedUsage = true;
  }

  return {
    deprecatedUsage: deprecatedUsage,
    unescaped: unescaped,
    quoteMark: quoteMark
  };
}

function handleDeprecatedContructorOpts(opts) {
  if (opts.quoteMark !== undefined) {
    return opts;
  }

  if (opts.value === undefined) {
    return opts;
  }

  warnOfDeprecatedConstructor();

  var _unescapeValue = unescapeValue(opts.value),
      quoteMark = _unescapeValue.quoteMark,
      unescaped = _unescapeValue.unescaped;

  if (!opts.raws) {
    opts.raws = {};
  }

  if (opts.raws.value === undefined) {
    opts.raws.value = opts.value;
  }

  opts.value = unescaped;
  opts.quoteMark = quoteMark;
  return opts;
}

var Attribute = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Attribute, _Namespace);

  function Attribute(opts) {
    var _this;

    if (opts === void 0) {
      opts = {};
    }

    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
    _this.type = _types.ATTRIBUTE;
    _this.raws = _this.raws || {};
    Object.defineProperty(_this.raws, 'unquoted', {
      get: deprecate(function () {
        return _this.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
      set: deprecate(function () {
        return _this.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
    });
    _this._constructed = true;
    return _this;
  }
  /**
   * Returns the Attribute's value quoted such that it would be legal to use
   * in the value of a css file. The original value's quotation setting
   * used for stringification is left unchanged. See `setValue(value, options)`
   * if you want to control the quote settings of a new value for the attribute.
   *
   * You can also change the quotation used for the current value by setting quoteMark.
   *
   * Options:
   *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
   *     option is not set, the original value for quoteMark will be used. If
   *     indeterminate, a double quote is used. The legal values are:
   *     * `null` - the value will be unquoted and characters will be escaped as necessary.
   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
   *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
   *     over the quoteMark option value.
   *   * smart {boolean} - if true, will select a quote mark based on the value
   *     and the other options specified here. See the `smartQuoteMark()`
   *     method.
   **/


  var _proto = Attribute.prototype;

  _proto.getQuotedValue = function getQuotedValue(options) {
    if (options === void 0) {
      options = {};
    }

    var quoteMark = this._determineQuoteMark(options);

    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
    var escaped = (0, _cssesc["default"])(this._value, cssescopts);
    return escaped;
  };

  _proto._determineQuoteMark = function _determineQuoteMark(options) {
    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
  }
  /**
   * Set the unescaped value with the specified quotation options. The value
   * provided must not include any wrapping quote marks -- those quotes will
   * be interpreted as part of the value and escaped accordingly.
   */
  ;

  _proto.setValue = function setValue(value, options) {
    if (options === void 0) {
      options = {};
    }

    this._value = value;
    this._quoteMark = this._determineQuoteMark(options);

    this._syncRawValue();
  }
  /**
   * Intelligently select a quoteMark value based on the value's contents. If
   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
   * mark will be picked that minimizes the number of escapes.
   *
   * If there's no clear winner, the quote mark from these options is used,
   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
   * true). If the quoteMark is unspecified, a double quote is used.
   *
   * @param options This takes the quoteMark and preferCurrentQuoteMark options
   * from the quoteValue method.
   */
  ;

  _proto.smartQuoteMark = function smartQuoteMark(options) {
    var v = this.value;
    var numSingleQuotes = v.replace(/[^']/g, '').length;
    var numDoubleQuotes = v.replace(/[^"]/g, '').length;

    if (numSingleQuotes + numDoubleQuotes === 0) {
      var escaped = (0, _cssesc["default"])(v, {
        isIdentifier: true
      });

      if (escaped === v) {
        return Attribute.NO_QUOTE;
      } else {
        var pref = this.preferredQuoteMark(options);

        if (pref === Attribute.NO_QUOTE) {
          // pick a quote mark that isn't none and see if it's smaller
          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
          var opts = CSSESC_QUOTE_OPTIONS[quote];
          var quoteValue = (0, _cssesc["default"])(v, opts);

          if (quoteValue.length < escaped.length) {
            return quote;
          }
        }

        return pref;
      }
    } else if (numDoubleQuotes === numSingleQuotes) {
      return this.preferredQuoteMark(options);
    } else if (numDoubleQuotes < numSingleQuotes) {
      return Attribute.DOUBLE_QUOTE;
    } else {
      return Attribute.SINGLE_QUOTE;
    }
  }
  /**
   * Selects the preferred quote mark based on the options and the current quote mark value.
   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
   * instead.
   */
  ;

  _proto.preferredQuoteMark = function preferredQuoteMark(options) {
    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

    if (quoteMark === undefined) {
      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
    }

    if (quoteMark === undefined) {
      quoteMark = Attribute.DOUBLE_QUOTE;
    }

    return quoteMark;
  };

  _proto._syncRawValue = function _syncRawValue() {
    var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

    if (rawValue === this._value) {
      if (this.raws) {
        delete this.raws.value;
      }
    } else {
      this.raws.value = rawValue;
    }
  };

  _proto._handleEscapes = function _handleEscapes(prop, value) {
    if (this._constructed) {
      var escaped = (0, _cssesc["default"])(value, {
        isIdentifier: true
      });

      if (escaped !== value) {
        this.raws[prop] = escaped;
      } else {
        delete this.raws[prop];
      }
    }
  };

  _proto._spacesFor = function _spacesFor(name) {
    var attrSpaces = {
      before: '',
      after: ''
    };
    var spaces = this.spaces[name] || {};
    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
    return Object.assign(attrSpaces, spaces, rawSpaces);
  };

  _proto._stringFor = function _stringFor(name, spaceName, concat) {
    if (spaceName === void 0) {
      spaceName = name;
    }

    if (concat === void 0) {
      concat = defaultAttrConcat;
    }

    var attrSpaces = this._spacesFor(spaceName);

    return concat(this.stringifyProperty(name), attrSpaces);
  }
  /**
   * returns the offset of the attribute part specified relative to the
   * start of the node of the output string.
   *
   * * "ns" - alias for "namespace"
   * * "namespace" - the namespace if it exists.
   * * "attribute" - the attribute name
   * * "attributeNS" - the start of the attribute or its namespace
   * * "operator" - the match operator of the attribute
   * * "value" - The value (string or identifier)
   * * "insensitive" - the case insensitivity flag;
   * @param part One of the possible values inside an attribute.
   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
   */
  ;

  _proto.offsetOf = function offsetOf(name) {
    var count = 1;

    var attributeSpaces = this._spacesFor("attribute");

    count += attributeSpaces.before.length;

    if (name === "namespace" || name === "ns") {
      return this.namespace ? count : -1;
    }

    if (name === "attributeNS") {
      return count;
    }

    count += this.namespaceString.length;

    if (this.namespace) {
      count += 1;
    }

    if (name === "attribute") {
      return count;
    }

    count += this.stringifyProperty("attribute").length;
    count += attributeSpaces.after.length;

    var operatorSpaces = this._spacesFor("operator");

    count += operatorSpaces.before.length;
    var operator = this.stringifyProperty("operator");

    if (name === "operator") {
      return operator ? count : -1;
    }

    count += operator.length;
    count += operatorSpaces.after.length;

    var valueSpaces = this._spacesFor("value");

    count += valueSpaces.before.length;
    var value = this.stringifyProperty("value");

    if (name === "value") {
      return value ? count : -1;
    }

    count += value.length;
    count += valueSpaces.after.length;

    var insensitiveSpaces = this._spacesFor("insensitive");

    count += insensitiveSpaces.before.length;

    if (name === "insensitive") {
      return this.insensitive ? count : -1;
    }

    return -1;
  };

  _proto.toString = function toString() {
    var _this2 = this;

    var selector = [this.rawSpaceBefore, '['];
    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

    if (this.operator && (this.value || this.value === '')) {
      selector.push(this._stringFor('operator'));
      selector.push(this._stringFor('value'));
      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
          attrSpaces.before = " ";
        }

        return defaultAttrConcat(attrValue, attrSpaces);
      }));
    }

    selector.push(']');
    selector.push(this.rawSpaceAfter);
    return selector.join('');
  };

  _createClass(Attribute, [{
    key: "quoted",
    get: function get() {
      var qm = this.quoteMark;
      return qm === "'" || qm === '"';
    },
    set: function set(value) {
      warnOfDeprecatedQuotedAssignment();
    }
    /**
     * returns a single (`'`) or double (`"`) quote character if the value is quoted.
     * returns `null` if the value is not quoted.
     * returns `undefined` if the quotation state is unknown (this can happen when
     * the attribute is constructed without specifying a quote mark.)
     */

  }, {
    key: "quoteMark",
    get: function get() {
      return this._quoteMark;
    }
    /**
     * Set the quote mark to be used by this attribute's value.
     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
     * value is updated accordingly.
     *
     * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
     */
    ,
    set: function set(quoteMark) {
      if (!this._constructed) {
        this._quoteMark = quoteMark;
        return;
      }

      if (this._quoteMark !== quoteMark) {
        this._quoteMark = quoteMark;

        this._syncRawValue();
      }
    }
  }, {
    key: "qualifiedAttribute",
    get: function get() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    }
  }, {
    key: "insensitiveFlag",
    get: function get() {
      return this.insensitive ? 'i' : '';
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Before 3.0, the value had to be set to an escaped value including any wrapped
     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
     * is unescaped during parsing and any quote marks are removed.
     *
     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
     * a deprecation warning is raised when the new value contains any characters that would
     * require escaping (including if it contains wrapped quotes).
     *
     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
     * how the new value is quoted.
     */
    ,
    set: function set(v) {
      if (this._constructed) {
        var _unescapeValue2 = unescapeValue(v),
            deprecatedUsage = _unescapeValue2.deprecatedUsage,
            unescaped = _unescapeValue2.unescaped,
            quoteMark = _unescapeValue2.quoteMark;

        if (deprecatedUsage) {
          warnOfDeprecatedValueAssignment();
        }

        if (unescaped === this._value && quoteMark === this._quoteMark) {
          return;
        }

        this._value = unescaped;
        this._quoteMark = quoteMark;

        this._syncRawValue();
      } else {
        this._value = v;
      }
    }
  }, {
    key: "attribute",
    get: function get() {
      return this._attribute;
    },
    set: function set(name) {
      this._handleEscapes("attribute", name);

      this._attribute = name;
    }
  }]);

  return Attribute;
}(_namespace["default"]);

exports["default"] = Attribute;
Attribute.NO_QUOTE = null;
Attribute.SINGLE_QUOTE = "'";
Attribute.DOUBLE_QUOTE = '"';
var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
  "'": {
    quotes: 'single',
    wrap: true
  },
  '"': {
    quotes: 'double',
    wrap: true
  }
}, _CSSESC_QUOTE_OPTIONS[null] = {
  isIdentifier: true
}, _CSSESC_QUOTE_OPTIONS);

function defaultAttrConcat(attrValue, attrSpaces) {
  return "" + attrSpaces.before + attrValue + attrSpaces.after;
}

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/className.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/className.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _cssesc = _interopRequireDefault(__webpack_require__(/*! cssesc */ "./node_modules/cssesc/cssesc.js"));

var _util = __webpack_require__(/*! ../util */ "./node_modules/postcss-selector-parser/dist/util/index.js");

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ClassName = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ClassName, _Node);

  function ClassName(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.CLASS;
    _this._constructed = true;
    return _this;
  }

  var _proto = ClassName.prototype;

  _proto.valueToString = function valueToString() {
    return '.' + _Node.prototype.valueToString.call(this);
  };

  _createClass(ClassName, [{
    key: "value",
    get: function get() {
      return this._value;
    },
    set: function set(v) {
      if (this._constructed) {
        var escaped = (0, _cssesc["default"])(v, {
          isIdentifier: true
        });

        if (escaped !== v) {
          (0, _util.ensureObject)(this, "raws");
          this.raws.value = escaped;
        } else if (this.raws) {
          delete this.raws.value;
        }
      }

      this._value = v;
    }
  }]);

  return ClassName;
}(_node["default"]);

exports["default"] = ClassName;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/combinator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/combinator.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Combinator = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Combinator, _Node);

  function Combinator(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMBINATOR;
    return _this;
  }

  return Combinator;
}(_node["default"]);

exports["default"] = Combinator;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/comment.js":
/*!************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/comment.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Comment = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Comment, _Node);

  function Comment(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMMENT;
    return _this;
  }

  return Comment;
}(_node["default"]);

exports["default"] = Comment;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/constructors.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/constructors.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;

var _attribute = _interopRequireDefault(__webpack_require__(/*! ./attribute */ "./node_modules/postcss-selector-parser/dist/selectors/attribute.js"));

var _className = _interopRequireDefault(__webpack_require__(/*! ./className */ "./node_modules/postcss-selector-parser/dist/selectors/className.js"));

var _combinator = _interopRequireDefault(__webpack_require__(/*! ./combinator */ "./node_modules/postcss-selector-parser/dist/selectors/combinator.js"));

var _comment = _interopRequireDefault(__webpack_require__(/*! ./comment */ "./node_modules/postcss-selector-parser/dist/selectors/comment.js"));

var _id = _interopRequireDefault(__webpack_require__(/*! ./id */ "./node_modules/postcss-selector-parser/dist/selectors/id.js"));

var _nesting = _interopRequireDefault(__webpack_require__(/*! ./nesting */ "./node_modules/postcss-selector-parser/dist/selectors/nesting.js"));

var _pseudo = _interopRequireDefault(__webpack_require__(/*! ./pseudo */ "./node_modules/postcss-selector-parser/dist/selectors/pseudo.js"));

var _root = _interopRequireDefault(__webpack_require__(/*! ./root */ "./node_modules/postcss-selector-parser/dist/selectors/root.js"));

var _selector = _interopRequireDefault(__webpack_require__(/*! ./selector */ "./node_modules/postcss-selector-parser/dist/selectors/selector.js"));

var _string = _interopRequireDefault(__webpack_require__(/*! ./string */ "./node_modules/postcss-selector-parser/dist/selectors/string.js"));

var _tag = _interopRequireDefault(__webpack_require__(/*! ./tag */ "./node_modules/postcss-selector-parser/dist/selectors/tag.js"));

var _universal = _interopRequireDefault(__webpack_require__(/*! ./universal */ "./node_modules/postcss-selector-parser/dist/selectors/universal.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var attribute = function attribute(opts) {
  return new _attribute["default"](opts);
};

exports.attribute = attribute;

var className = function className(opts) {
  return new _className["default"](opts);
};

exports.className = className;

var combinator = function combinator(opts) {
  return new _combinator["default"](opts);
};

exports.combinator = combinator;

var comment = function comment(opts) {
  return new _comment["default"](opts);
};

exports.comment = comment;

var id = function id(opts) {
  return new _id["default"](opts);
};

exports.id = id;

var nesting = function nesting(opts) {
  return new _nesting["default"](opts);
};

exports.nesting = nesting;

var pseudo = function pseudo(opts) {
  return new _pseudo["default"](opts);
};

exports.pseudo = pseudo;

var root = function root(opts) {
  return new _root["default"](opts);
};

exports.root = root;

var selector = function selector(opts) {
  return new _selector["default"](opts);
};

exports.selector = selector;

var string = function string(opts) {
  return new _string["default"](opts);
};

exports.string = string;

var tag = function tag(opts) {
  return new _tag["default"](opts);
};

exports.tag = tag;

var universal = function universal(opts) {
  return new _universal["default"](opts);
};

exports.universal = universal;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/container.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/container.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var types = _interopRequireWildcard(__webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Container = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Container, _Node);

  function Container(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;

    if (!_this.nodes) {
      _this.nodes = [];
    }

    return _this;
  }

  var _proto = Container.prototype;

  _proto.append = function append(selector) {
    selector.parent = this;
    this.nodes.push(selector);
    return this;
  };

  _proto.prepend = function prepend(selector) {
    selector.parent = this;
    this.nodes.unshift(selector);
    return this;
  };

  _proto.at = function at(index) {
    return this.nodes[index];
  };

  _proto.index = function index(child) {
    if (typeof child === 'number') {
      return child;
    }

    return this.nodes.indexOf(child);
  };

  _proto.removeChild = function removeChild(child) {
    child = this.index(child);
    this.at(child).parent = undefined;
    this.nodes.splice(child, 1);
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  };

  _proto.removeAll = function removeAll() {
    for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
      var node = _step.value;
      node.parent = undefined;
    }

    this.nodes = [];
    return this;
  };

  _proto.empty = function empty() {
    return this.removeAll();
  };

  _proto.insertAfter = function insertAfter(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex + 1, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (oldIndex <= index) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto.insertBefore = function insertBefore(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index <= oldIndex) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
    var found = undefined;
    this.each(function (node) {
      if (node.atPosition) {
        var foundChild = node.atPosition(line, col);

        if (foundChild) {
          found = foundChild;
          return false;
        }
      } else if (node.isAtPosition(line, col)) {
        found = node;
        return false;
      }
    });
    return found;
  }
  /**
   * Return the most specific node at the line and column number given.
   * The source location is based on the original parsed location, locations aren't
   * updated as selector nodes are mutated.
   * 
   * Note that this location is relative to the location of the first character
   * of the selector, and not the location of the selector in the overall document
   * when used in conjunction with postcss.
   *
   * If not found, returns undefined.
   * @param {number} line The line number of the node to find. (1-based index)
   * @param {number} col  The column number of the node to find. (1-based index)
   */
  ;

  _proto.atPosition = function atPosition(line, col) {
    if (this.isAtPosition(line, col)) {
      return this._findChildAtPosition(line, col) || this;
    } else {
      return undefined;
    }
  };

  _proto._inferEndPosition = function _inferEndPosition() {
    if (this.last && this.last.source && this.last.source.end) {
      this.source = this.source || {};
      this.source.end = this.source.end || {};
      Object.assign(this.source.end, this.last.source.end);
    }
  };

  _proto.each = function each(callback) {
    if (!this.lastEach) {
      this.lastEach = 0;
    }

    if (!this.indexes) {
      this.indexes = {};
    }

    this.lastEach++;
    var id = this.lastEach;
    this.indexes[id] = 0;

    if (!this.length) {
      return undefined;
    }

    var index, result;

    while (this.indexes[id] < this.length) {
      index = this.indexes[id];
      result = callback(this.at(index), index);

      if (result === false) {
        break;
      }

      this.indexes[id] += 1;
    }

    delete this.indexes[id];

    if (result === false) {
      return false;
    }
  };

  _proto.walk = function walk(callback) {
    return this.each(function (node, i) {
      var result = callback(node, i);

      if (result !== false && node.length) {
        result = node.walk(callback);
      }

      if (result === false) {
        return false;
      }
    });
  };

  _proto.walkAttributes = function walkAttributes(callback) {
    var _this2 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ATTRIBUTE) {
        return callback.call(_this2, selector);
      }
    });
  };

  _proto.walkClasses = function walkClasses(callback) {
    var _this3 = this;

    return this.walk(function (selector) {
      if (selector.type === types.CLASS) {
        return callback.call(_this3, selector);
      }
    });
  };

  _proto.walkCombinators = function walkCombinators(callback) {
    var _this4 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMBINATOR) {
        return callback.call(_this4, selector);
      }
    });
  };

  _proto.walkComments = function walkComments(callback) {
    var _this5 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMMENT) {
        return callback.call(_this5, selector);
      }
    });
  };

  _proto.walkIds = function walkIds(callback) {
    var _this6 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ID) {
        return callback.call(_this6, selector);
      }
    });
  };

  _proto.walkNesting = function walkNesting(callback) {
    var _this7 = this;

    return this.walk(function (selector) {
      if (selector.type === types.NESTING) {
        return callback.call(_this7, selector);
      }
    });
  };

  _proto.walkPseudos = function walkPseudos(callback) {
    var _this8 = this;

    return this.walk(function (selector) {
      if (selector.type === types.PSEUDO) {
        return callback.call(_this8, selector);
      }
    });
  };

  _proto.walkTags = function walkTags(callback) {
    var _this9 = this;

    return this.walk(function (selector) {
      if (selector.type === types.TAG) {
        return callback.call(_this9, selector);
      }
    });
  };

  _proto.walkUniversals = function walkUniversals(callback) {
    var _this10 = this;

    return this.walk(function (selector) {
      if (selector.type === types.UNIVERSAL) {
        return callback.call(_this10, selector);
      }
    });
  };

  _proto.split = function split(callback) {
    var _this11 = this;

    var current = [];
    return this.reduce(function (memo, node, index) {
      var split = callback.call(_this11, node);
      current.push(node);

      if (split) {
        memo.push(current);
        current = [];
      } else if (index === _this11.length - 1) {
        memo.push(current);
      }

      return memo;
    }, []);
  };

  _proto.map = function map(callback) {
    return this.nodes.map(callback);
  };

  _proto.reduce = function reduce(callback, memo) {
    return this.nodes.reduce(callback, memo);
  };

  _proto.every = function every(callback) {
    return this.nodes.every(callback);
  };

  _proto.some = function some(callback) {
    return this.nodes.some(callback);
  };

  _proto.filter = function filter(callback) {
    return this.nodes.filter(callback);
  };

  _proto.sort = function sort(callback) {
    return this.nodes.sort(callback);
  };

  _proto.toString = function toString() {
    return this.map(String).join('');
  };

  _createClass(Container, [{
    key: "first",
    get: function get() {
      return this.at(0);
    }
  }, {
    key: "last",
    get: function get() {
      return this.at(this.length - 1);
    }
  }, {
    key: "length",
    get: function get() {
      return this.nodes.length;
    }
  }]);

  return Container;
}(_node["default"]);

exports["default"] = Container;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/guards.js":
/*!***********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/guards.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.isNode = isNode;
exports.isPseudoElement = isPseudoElement;
exports.isPseudoClass = isPseudoClass;
exports.isContainer = isContainer;
exports.isNamespace = isNamespace;
exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

var _IS_TYPE;

var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

function isNode(node) {
  return typeof node === "object" && IS_TYPE[node.type];
}

function isNodeType(type, node) {
  return isNode(node) && node.type === type;
}

var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
exports.isAttribute = isAttribute;
var isClassName = isNodeType.bind(null, _types.CLASS);
exports.isClassName = isClassName;
var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
exports.isCombinator = isCombinator;
var isComment = isNodeType.bind(null, _types.COMMENT);
exports.isComment = isComment;
var isIdentifier = isNodeType.bind(null, _types.ID);
exports.isIdentifier = isIdentifier;
var isNesting = isNodeType.bind(null, _types.NESTING);
exports.isNesting = isNesting;
var isPseudo = isNodeType.bind(null, _types.PSEUDO);
exports.isPseudo = isPseudo;
var isRoot = isNodeType.bind(null, _types.ROOT);
exports.isRoot = isRoot;
var isSelector = isNodeType.bind(null, _types.SELECTOR);
exports.isSelector = isSelector;
var isString = isNodeType.bind(null, _types.STRING);
exports.isString = isString;
var isTag = isNodeType.bind(null, _types.TAG);
exports.isTag = isTag;
var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
exports.isUniversal = isUniversal;

function isPseudoElement(node) {
  return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
}

function isPseudoClass(node) {
  return isPseudo(node) && !isPseudoElement(node);
}

function isContainer(node) {
  return !!(isNode(node) && node.walk);
}

function isNamespace(node) {
  return isAttribute(node) || isTag(node);
}

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/id.js":
/*!*******************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/id.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ID = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ID, _Node);

  function ID(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.ID;
    return _this;
  }

  var _proto = ID.prototype;

  _proto.valueToString = function valueToString() {
    return '#' + _Node.prototype.valueToString.call(this);
  };

  return ID;
}(_node["default"]);

exports["default"] = ID;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _types[key]) return;
  exports[key] = _types[key];
});

var _constructors = __webpack_require__(/*! ./constructors */ "./node_modules/postcss-selector-parser/dist/selectors/constructors.js");

Object.keys(_constructors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constructors[key]) return;
  exports[key] = _constructors[key];
});

var _guards = __webpack_require__(/*! ./guards */ "./node_modules/postcss-selector-parser/dist/selectors/guards.js");

Object.keys(_guards).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _guards[key]) return;
  exports[key] = _guards[key];
});

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/namespace.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/namespace.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _cssesc = _interopRequireDefault(__webpack_require__(/*! cssesc */ "./node_modules/cssesc/cssesc.js"));

var _util = __webpack_require__(/*! ../util */ "./node_modules/postcss-selector-parser/dist/util/index.js");

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Namespace = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Namespace, _Node);

  function Namespace() {
    return _Node.apply(this, arguments) || this;
  }

  var _proto = Namespace.prototype;

  _proto.qualifiedName = function qualifiedName(value) {
    if (this.namespace) {
      return this.namespaceString + "|" + value;
    } else {
      return value;
    }
  };

  _proto.valueToString = function valueToString() {
    return this.qualifiedName(_Node.prototype.valueToString.call(this));
  };

  _createClass(Namespace, [{
    key: "namespace",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      if (namespace === true || namespace === "*" || namespace === "&") {
        this._namespace = namespace;

        if (this.raws) {
          delete this.raws.namespace;
        }

        return;
      }

      var escaped = (0, _cssesc["default"])(namespace, {
        isIdentifier: true
      });
      this._namespace = namespace;

      if (escaped !== namespace) {
        (0, _util.ensureObject)(this, "raws");
        this.raws.namespace = escaped;
      } else if (this.raws) {
        delete this.raws.namespace;
      }
    }
  }, {
    key: "ns",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      this.namespace = namespace;
    }
  }, {
    key: "namespaceString",
    get: function get() {
      if (this.namespace) {
        var ns = this.stringifyProperty("namespace");

        if (ns === true) {
          return '';
        } else {
          return ns;
        }
      } else {
        return '';
      }
    }
  }]);

  return Namespace;
}(_node["default"]);

exports["default"] = Namespace;
;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/nesting.js":
/*!************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/nesting.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Nesting = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Nesting, _Node);

  function Nesting(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.NESTING;
    _this.value = '&';
    return _this;
  }

  return Nesting;
}(_node["default"]);

exports["default"] = Nesting;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/node.js":
/*!*********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/node.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _util = __webpack_require__(/*! ../util */ "./node_modules/postcss-selector-parser/dist/util/index.js");

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var cloneNode = function cloneNode(obj, parent) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) {
      continue;
    }

    var value = obj[i];
    var type = typeof value;

    if (i === 'parent' && type === 'object') {
      if (parent) {
        cloned[i] = parent;
      }
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      cloned[i] = cloneNode(value, cloned);
    }
  }

  return cloned;
};

var Node = /*#__PURE__*/function () {
  function Node(opts) {
    if (opts === void 0) {
      opts = {};
    }

    Object.assign(this, opts);
    this.spaces = this.spaces || {};
    this.spaces.before = this.spaces.before || '';
    this.spaces.after = this.spaces.after || '';
  }

  var _proto = Node.prototype;

  _proto.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    this.parent = undefined;
    return this;
  };

  _proto.replaceWith = function replaceWith() {
    if (this.parent) {
      for (var index in arguments) {
        this.parent.insertBefore(this, arguments[index]);
      }

      this.remove();
    }

    return this;
  };

  _proto.next = function next() {
    return this.parent.at(this.parent.index(this) + 1);
  };

  _proto.prev = function prev() {
    return this.parent.at(this.parent.index(this) - 1);
  };

  _proto.clone = function clone(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = cloneNode(this);

    for (var name in overrides) {
      cloned[name] = overrides[name];
    }

    return cloned;
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows non standard syntax to be appended to an existing property
   * by specifying the escaped value. By specifying the escaped value,
   * illegal characters are allowed to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped optional. the escaped value of the property.
   */
  ;

  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    var originalValue = this[name];
    var originalEscaped = this.raws[name];
    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

    if (originalEscaped || valueEscaped !== value) {
      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
    } else {
      delete this.raws[name]; // delete any escaped value that was created by the setter.
    }
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows the escaped value to be specified directly, allowing illegal
   * characters to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped the escaped value of the property.
   */
  ;

  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    this.raws[name] = valueEscaped;
  }
  /**
   * When you want a value to passed through to CSS directly. This method
   * deletes the corresponding raw value causing the stringifier to fallback
   * to the unescaped value.
   * @param {string} name the property to set.
   * @param {any} value The value that is both escaped and unescaped.
   */
  ;

  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    if (this.raws) {
      delete this.raws[name];
    }
  }
  /**
   *
   * @param {number} line The number (starting with 1)
   * @param {number} column The column number (starting with 1)
   */
  ;

  _proto.isAtPosition = function isAtPosition(line, column) {
    if (this.source && this.source.start && this.source.end) {
      if (this.source.start.line > line) {
        return false;
      }

      if (this.source.end.line < line) {
        return false;
      }

      if (this.source.start.line === line && this.source.start.column > column) {
        return false;
      }

      if (this.source.end.line === line && this.source.end.column < column) {
        return false;
      }

      return true;
    }

    return undefined;
  };

  _proto.stringifyProperty = function stringifyProperty(name) {
    return this.raws && this.raws[name] || this[name];
  };

  _proto.valueToString = function valueToString() {
    return String(this.stringifyProperty("value"));
  };

  _proto.toString = function toString() {
    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
  };

  _createClass(Node, [{
    key: "rawSpaceBefore",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

      if (rawSpace === undefined) {
        rawSpace = this.spaces && this.spaces.before;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.before = raw;
    }
  }, {
    key: "rawSpaceAfter",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

      if (rawSpace === undefined) {
        rawSpace = this.spaces.after;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.after = raw;
    }
  }]);

  return Node;
}();

exports["default"] = Node;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/pseudo.js":
/*!***********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/pseudo.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _container = _interopRequireDefault(__webpack_require__(/*! ./container */ "./node_modules/postcss-selector-parser/dist/selectors/container.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Pseudo = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Pseudo, _Container);

  function Pseudo(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.PSEUDO;
    return _this;
  }

  var _proto = Pseudo.prototype;

  _proto.toString = function toString() {
    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
    return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
  };

  return Pseudo;
}(_container["default"]);

exports["default"] = Pseudo;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/root.js":
/*!*********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/root.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _container = _interopRequireDefault(__webpack_require__(/*! ./container */ "./node_modules/postcss-selector-parser/dist/selectors/container.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Root = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Root, _Container);

  function Root(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.ROOT;
    return _this;
  }

  var _proto = Root.prototype;

  _proto.toString = function toString() {
    var str = this.reduce(function (memo, selector) {
      memo.push(String(selector));
      return memo;
    }, []).join(',');
    return this.trailingComma ? str + ',' : str;
  };

  _proto.error = function error(message, options) {
    if (this._error) {
      return this._error(message, options);
    } else {
      return new Error(message);
    }
  };

  _createClass(Root, [{
    key: "errorGenerator",
    set: function set(handler) {
      this._error = handler;
    }
  }]);

  return Root;
}(_container["default"]);

exports["default"] = Root;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/selector.js":
/*!*************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/selector.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _container = _interopRequireDefault(__webpack_require__(/*! ./container */ "./node_modules/postcss-selector-parser/dist/selectors/container.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Selector = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Selector, _Container);

  function Selector(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.SELECTOR;
    return _this;
  }

  return Selector;
}(_container["default"]);

exports["default"] = Selector;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/string.js":
/*!***********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/string.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__webpack_require__(/*! ./node */ "./node_modules/postcss-selector-parser/dist/selectors/node.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var String = /*#__PURE__*/function (_Node) {
  _inheritsLoose(String, _Node);

  function String(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.STRING;
    return _this;
  }

  return String;
}(_node["default"]);

exports["default"] = String;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/tag.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _namespace = _interopRequireDefault(__webpack_require__(/*! ./namespace */ "./node_modules/postcss-selector-parser/dist/selectors/namespace.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Tag = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Tag, _Namespace);

  function Tag(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.TAG;
    return _this;
  }

  return Tag;
}(_namespace["default"]);

exports["default"] = Tag;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/types.js":
/*!**********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/types.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
var TAG = 'tag';
exports.TAG = TAG;
var STRING = 'string';
exports.STRING = STRING;
var SELECTOR = 'selector';
exports.SELECTOR = SELECTOR;
var ROOT = 'root';
exports.ROOT = ROOT;
var PSEUDO = 'pseudo';
exports.PSEUDO = PSEUDO;
var NESTING = 'nesting';
exports.NESTING = NESTING;
var ID = 'id';
exports.ID = ID;
var COMMENT = 'comment';
exports.COMMENT = COMMENT;
var COMBINATOR = 'combinator';
exports.COMBINATOR = COMBINATOR;
var CLASS = 'class';
exports.CLASS = CLASS;
var ATTRIBUTE = 'attribute';
exports.ATTRIBUTE = ATTRIBUTE;
var UNIVERSAL = 'universal';
exports.UNIVERSAL = UNIVERSAL;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/universal.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/universal.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _namespace = _interopRequireDefault(__webpack_require__(/*! ./namespace */ "./node_modules/postcss-selector-parser/dist/selectors/namespace.js"));

var _types = __webpack_require__(/*! ./types */ "./node_modules/postcss-selector-parser/dist/selectors/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Universal = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Universal, _Namespace);

  function Universal(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.UNIVERSAL;
    _this.value = '*';
    return _this;
  }

  return Universal;
}(_namespace["default"]);

exports["default"] = Universal;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/sortAscending.js":
/*!********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/sortAscending.js ***!
  \********************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = sortAscending;

function sortAscending(list) {
  return list.sort(function (a, b) {
    return a - b;
  });
}

;
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/tokenTypes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/tokenTypes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
var ampersand = 38; // `&`.charCodeAt(0);

exports.ampersand = ampersand;
var asterisk = 42; // `*`.charCodeAt(0);

exports.asterisk = asterisk;
var at = 64; // `@`.charCodeAt(0);

exports.at = at;
var comma = 44; // `,`.charCodeAt(0);

exports.comma = comma;
var colon = 58; // `:`.charCodeAt(0);

exports.colon = colon;
var semicolon = 59; // `;`.charCodeAt(0);

exports.semicolon = semicolon;
var openParenthesis = 40; // `(`.charCodeAt(0);

exports.openParenthesis = openParenthesis;
var closeParenthesis = 41; // `)`.charCodeAt(0);

exports.closeParenthesis = closeParenthesis;
var openSquare = 91; // `[`.charCodeAt(0);

exports.openSquare = openSquare;
var closeSquare = 93; // `]`.charCodeAt(0);

exports.closeSquare = closeSquare;
var dollar = 36; // `$`.charCodeAt(0);

exports.dollar = dollar;
var tilde = 126; // `~`.charCodeAt(0);

exports.tilde = tilde;
var caret = 94; // `^`.charCodeAt(0);

exports.caret = caret;
var plus = 43; // `+`.charCodeAt(0);

exports.plus = plus;
var equals = 61; // `=`.charCodeAt(0);

exports.equals = equals;
var pipe = 124; // `|`.charCodeAt(0);

exports.pipe = pipe;
var greaterThan = 62; // `>`.charCodeAt(0);

exports.greaterThan = greaterThan;
var space = 32; // ` `.charCodeAt(0);

exports.space = space;
var singleQuote = 39; // `'`.charCodeAt(0);

exports.singleQuote = singleQuote;
var doubleQuote = 34; // `"`.charCodeAt(0);

exports.doubleQuote = doubleQuote;
var slash = 47; // `/`.charCodeAt(0);

exports.slash = slash;
var bang = 33; // `!`.charCodeAt(0);

exports.bang = bang;
var backslash = 92; // '\\'.charCodeAt(0);

exports.backslash = backslash;
var cr = 13; // '\r'.charCodeAt(0);

exports.cr = cr;
var feed = 12; // '\f'.charCodeAt(0);

exports.feed = feed;
var newline = 10; // '\n'.charCodeAt(0);

exports.newline = newline;
var tab = 9; // '\t'.charCodeAt(0);
// Expose aliases primarily for readability.

exports.tab = tab;
var str = singleQuote; // No good single character representation!

exports.str = str;
var comment = -1;
exports.comment = comment;
var word = -2;
exports.word = word;
var combinator = -3;
exports.combinator = combinator;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/tokenize.js":
/*!***************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/tokenize.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = tokenize;
exports.FIELDS = void 0;

var t = _interopRequireWildcard(__webpack_require__(/*! ./tokenTypes */ "./node_modules/postcss-selector-parser/dist/tokenTypes.js"));

var _unescapable, _wordDelimiters;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
var hex = {};
var hexChars = "0123456789abcdefABCDEF";

for (var i = 0; i < hexChars.length; i++) {
  hex[hexChars.charCodeAt(i)] = true;
}
/**
 *  Returns the last index of the bar css word
 * @param {string} css The string in which the word begins
 * @param {number} start The index into the string where word's first letter occurs
 */


function consumeWord(css, start) {
  var next = start;
  var code;

  do {
    code = css.charCodeAt(next);

    if (wordDelimiters[code]) {
      return next - 1;
    } else if (code === t.backslash) {
      next = consumeEscape(css, next) + 1;
    } else {
      // All other characters are part of the word
      next++;
    }
  } while (next < css.length);

  return next - 1;
}
/**
 *  Returns the last index of the escape sequence
 * @param {string} css The string in which the sequence begins
 * @param {number} start The index into the string where escape character (`\`) occurs.
 */


function consumeEscape(css, start) {
  var next = start;
  var code = css.charCodeAt(next + 1);

  if (unescapable[code]) {// just consume the escape char
  } else if (hex[code]) {
    var hexDigits = 0; // consume up to 6 hex chars

    do {
      next++;
      hexDigits++;
      code = css.charCodeAt(next + 1);
    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


    if (hexDigits < 6 && code === t.space) {
      next++;
    }
  } else {
    // the next char is part of the current word
    next++;
  }

  return next;
}

var FIELDS = {
  TYPE: 0,
  START_LINE: 1,
  START_COL: 2,
  END_LINE: 3,
  END_COL: 4,
  START_POS: 5,
  END_POS: 6
};
exports.FIELDS = FIELDS;

function tokenize(input) {
  var tokens = [];
  var css = input.css.valueOf();
  var _css = css,
      length = _css.length;
  var offset = -1;
  var line = 1;
  var start = 0;
  var end = 0;
  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

  function unclosed(what, fix) {
    if (input.safe) {
      // fyi: this is never set to true.
      css += fix;
      next = css.length - 1;
    } else {
      throw input.error('Unclosed ' + what, line, start - offset, start);
    }
  }

  while (start < length) {
    code = css.charCodeAt(start);

    if (code === t.newline) {
      offset = start;
      line += 1;
    }

    switch (code) {
      case t.space:
      case t.tab:
      case t.newline:
      case t.cr:
      case t.feed:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);

          if (code === t.newline) {
            offset = next;
            line += 1;
          }
        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

        tokenType = t.space;
        endLine = line;
        endColumn = next - offset - 1;
        end = next;
        break;

      case t.plus:
      case t.greaterThan:
      case t.tilde:
      case t.pipe:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

        tokenType = t.combinator;
        endLine = line;
        endColumn = start - offset;
        end = next;
        break;
      // Consume these characters as single tokens.

      case t.asterisk:
      case t.ampersand:
      case t.bang:
      case t.comma:
      case t.equals:
      case t.dollar:
      case t.caret:
      case t.openSquare:
      case t.closeSquare:
      case t.colon:
      case t.semicolon:
      case t.openParenthesis:
      case t.closeParenthesis:
        next = start;
        tokenType = code;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      case t.singleQuote:
      case t.doubleQuote:
        quote = code === t.singleQuote ? "'" : '"';
        next = start;

        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) {
            unclosed('quote', quote);
          }

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === t.backslash) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        tokenType = t.str;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      default:
        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
          next = css.indexOf('*/', start + 2) + 1;

          if (next === 0) {
            unclosed('comment', '*/');
          }

          content = css.slice(start, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          tokenType = t.comment;
          line = nextLine;
          endLine = nextLine;
          endColumn = next - nextOffset;
        } else if (code === t.slash) {
          next = start;
          tokenType = code;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
        } else {
          next = consumeWord(css, start);
          tokenType = t.word;
          endLine = line;
          endColumn = next - offset;
        }

        end = next + 1;
        break;
    } // Ensure that the token structure remains consistent


    tokens.push([tokenType, // [0] Token type
    line, // [1] Starting line
    start - offset, // [2] Starting column
    endLine, // [3] Ending line
    endColumn, // [4] Ending column
    start, // [5] Start position / Source index
    end // [6] End position
    ]); // Reset offset for the next token

    if (nextOffset) {
      offset = nextOffset;
      nextOffset = null;
    }

    start = end;
  }

  return tokens;
}

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/ensureObject.js":
/*!************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/ensureObject.js ***!
  \************************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = ensureObject;

function ensureObject(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      obj[prop] = {};
    }

    obj = obj[prop];
  }
}

module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/getProp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/getProp.js ***!
  \*******************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = getProp;

function getProp(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      return undefined;
    }

    obj = obj[prop];
  }

  return obj;
}

module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;

var _unesc = _interopRequireDefault(__webpack_require__(/*! ./unesc */ "./node_modules/postcss-selector-parser/dist/util/unesc.js"));

exports.unesc = _unesc["default"];

var _getProp = _interopRequireDefault(__webpack_require__(/*! ./getProp */ "./node_modules/postcss-selector-parser/dist/util/getProp.js"));

exports.getProp = _getProp["default"];

var _ensureObject = _interopRequireDefault(__webpack_require__(/*! ./ensureObject */ "./node_modules/postcss-selector-parser/dist/util/ensureObject.js"));

exports.ensureObject = _ensureObject["default"];

var _stripComments = _interopRequireDefault(__webpack_require__(/*! ./stripComments */ "./node_modules/postcss-selector-parser/dist/util/stripComments.js"));

exports.stripComments = _stripComments["default"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/stripComments.js":
/*!*************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/stripComments.js ***!
  \*************************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = stripComments;

function stripComments(str) {
  var s = "";
  var commentStart = str.indexOf("/*");
  var lastEnd = 0;

  while (commentStart >= 0) {
    s = s + str.slice(lastEnd, commentStart);
    var commentEnd = str.indexOf("*/", commentStart + 2);

    if (commentEnd < 0) {
      return s;
    }

    lastEnd = commentEnd + 2;
    commentStart = str.indexOf("/*", lastEnd);
  }

  s = s + str.slice(lastEnd);
  return s;
}

module.exports = exports.default;

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/unesc.js":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/unesc.js ***!
  \*****************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = unesc;

// Many thanks for this post which made this migration much easier.
// https://mathiasbynens.be/notes/css-escapes

/**
 * 
 * @param {string} str 
 * @returns {[string, number]|undefined}
 */
function gobbleHex(str) {
  var lower = str.toLowerCase();
  var hex = '';
  var spaceTerminated = false;

  for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
    var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]

    var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point

    spaceTerminated = code === 32;

    if (!valid) {
      break;
    }

    hex += lower[i];
  }

  if (hex.length === 0) {
    return undefined;
  }

  var codePoint = parseInt(hex, 16);
  var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for
  // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
  // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point

  if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
    return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
  }

  return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
}

var CONTAINS_ESCAPE = /\\/;

function unesc(str) {
  var needToProcess = CONTAINS_ESCAPE.test(str);

  if (!needToProcess) {
    return str;
  }

  var ret = "";

  for (var i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      var gobbled = gobbleHex(str.slice(i + 1, i + 7));

      if (gobbled !== undefined) {
        ret += gobbled[0];
        i += gobbled[1];
        continue;
      } // Retain a pair of \\ if double escaped `\\\\`
      // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e


      if (str[i + 1] === "\\") {
        ret += "\\";
        i++;
        continue;
      } // if \\ is at the end of the string retain it
      // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb


      if (str.length === i + 1) {
        ret += str[i];
      }

      continue;
    }

    ret += str[i];
  }

  return ret;
}

module.exports = exports.default;

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./src/style.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ "./src/contact.js":
/*!************************!*\
  !*** ./src/contact.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

let contact = document.createElement('div');
contact.textContent = "Contact";
contact.classList.add('header-button');

let screen = document.querySelector('#middle-window');



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (contact);

/***/ }),

/***/ "./src/home.js":
/*!*********************!*\
  !*** ./src/home.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

let screen = document.querySelector('#middle-window');

let home = document.createElement('div');
home.textContent = 'Home';
home.classList.add('header-button');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (home);


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _home_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./home.js */ "./src/home.js");
/* harmony import */ var _menu_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./menu.js */ "./src/menu.js");
/* harmony import */ var _contact_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contact.js */ "./src/contact.js");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style.css */ "./src/style.css");
/* harmony import */ var postcss_selector_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! postcss-selector-parser */ "./node_modules/postcss-selector-parser/dist/index.js");
/* harmony import */ var postcss_selector_parser__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(postcss_selector_parser__WEBPACK_IMPORTED_MODULE_4__);







let content = document.createElement('div');
content.setAttribute('id','content');

let title = document.createElement('div');
title.setAttribute('id','title');
title.textContent = "Twisted Cones";
content.appendChild(title);

let header = document.createElement('div');
header.setAttribute('id','header');
header.appendChild(_home_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
header.appendChild(_menu_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
header.appendChild(_contact_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

content.appendChild(header);

let middle = document.createElement('div');
middle.setAttribute('id','middle');
let screen = document.createElement('div');
write_home();
screen.setAttribute('id','middle-window');
middle.appendChild(screen);
content.appendChild(middle);

_home_js__WEBPACK_IMPORTED_MODULE_0__["default"].addEventListener('click',write_home);

function write_home(){
    screen.innerHTML = '';
    screen.style.cssText = "dispay:flex; flex-direction:column; box-sizing:border-box; padding:50px; ";
    let text1 = document.createElement('h1');
    text1.setAttribute('id', 'text1');
    text1.textContent = "The best Ice Cream chain around.";

    let text2 = document.createElement('h3');
    text2.setAttribute('id', 'text2');
    text2.textContent = "Ice Creams are personal. So create your own flavour and make your cone your own. The possibilites are limitless.";


    screen.appendChild(text1);
    screen.appendChild(text2);

}

_menu_js__WEBPACK_IMPORTED_MODULE_1__["default"].addEventListener('click', write_menu)

function write_menu(){
    screen.innerHTML = '';
    screen.style.cssText = "display: grid; box-sizing: border-box; grid-template: 1fr 1fr/ 1fr 1fr; gap:20px; padding:40px;";

    let card1 = document.createElement('div');
    card1.classList.add('card');
    card1.textContent = "Chocolate";
    card1.style.backgroundColor = "brown";
    card1.style.color = 'white';

    let card2 = document.createElement('div');
    card2.classList.add('card');
    card2.textContent = "Strawberry";
    card2.style.backgroundColor = "pink";
    card2.style.color = 'black';

    let card3 = document.createElement('div');
    card3.classList.add('card');
    card3.textContent = "Pista";
    card3.style.backgroundColor = "lightgreen";
    card3.style.color = 'black';

    let card4 = document.createElement('div');
    card4.classList.add('card');
    card4.textContent = "Black Currant";
    card4.style.backgroundColor = "gray";
    card4.style.color = 'white';

    screen.appendChild(card1);
    screen.appendChild(card2);
    screen.appendChild(card3);
    screen.appendChild(card4);

}

_contact_js__WEBPACK_IMPORTED_MODULE_2__["default"].addEventListener('click', write_contact)

function write_contact(){
    screen.innerHTML = '';
    screen.style.cssText = "";

    let c1 = document.createElement('div');
    let p11 = document.createElement('p');
    p11.textContent = "Rocky Bhai"
    p11.style.fontSize = "30px";

    let p12 = document.createElement('p');
    p12.textContent = "CEO of India";

    let p13 = document.createElement('p');
    p13.textContent = "rockyash@narachi.co.in";
    c1.appendChild(p11);
    c1.appendChild(p12);
    c1.appendChild(p13);

    screen.appendChild(c1);

    
eateElement('div');
    


}

document.body.appendChild(content);


/***/ }),

/***/ "./src/menu.js":
/*!*********************!*\
  !*** ./src/menu.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
let screen = document.querySelector('#middle-window');

let menu = document.createElement('div');
menu.textContent = "Menu";
menu.classList.add('header-button');



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (menu);

/***/ }),

/***/ "./src/icon.svg":
/*!**********************!*\
  !*** ./src/icon.svg ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "8b0f4e372776bc043f35.svg";

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/index.js"));
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTSxvRUFBb0U7QUFDMUUsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qzs7O0FBR3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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QUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RSw0QkFBNEI7QUFDekc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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QixJQUFJO0FBQ0osdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0NBQW9DOzs7QUFHMUM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBcUI7O0FBRXJCO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCLGlDQUFpQyxVQUFVLGFBQWE7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0VBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSEE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUEsaUVBQWUsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvdGVsX3BhZ2UvLi9zcmMvc3R5bGUuY3NzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL2Nzc2VzYy9jc3Nlc2MuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3Byb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL2F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL2NsYXNzTmFtZS5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL2NvbWJpbmF0b3IuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy9jb21tZW50LmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvY29uc3RydWN0b3JzLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvY29udGFpbmVyLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvZ3VhcmRzLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvaWQuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL25lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy9ub2RlLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvcHNldWRvLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvcm9vdC5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3Qvc2VsZWN0b3JzL3NlbGVjdG9yLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvc3RyaW5nLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvdGFnLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC9zZWxlY3RvcnMvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NlbGVjdG9ycy91bml2ZXJzYWwuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3NvcnRBc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3Rva2VuVHlwZXMuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3Rva2VuaXplLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC91dGlsL2Vuc3VyZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2Rpc3QvdXRpbC9nZXRQcm9wLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC91dGlsL2luZGV4LmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvZGlzdC91dGlsL3N0cmlwQ29tbWVudHMuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9kaXN0L3V0aWwvdW5lc2MuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL3NyYy9zdHlsZS5jc3M/NzE2MyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9ob3RlbF9wYWdlLy4vc3JjL2NvbnRhY3QuanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL3NyYy9ob21lLmpzIiwid2VicGFjazovL2hvdGVsX3BhZ2UvLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaG90ZWxfcGFnZS8uL3NyYy9tZW51LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyA9IG5ldyBVUkwoXCJpY29uLnN2Z1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIip7XFxuICAgIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuYm9keXtcXG4gICAgbWFyZ2luOiAwO1xcbn1cXG5cXG4jdGl0bGV7XFxuICAgIFxcbiAgICBoZWlnaHQ6IDEwdmg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA5LCAxNTUsIDU1LCAwLjg2Myk7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmb250LXNpemU6IDMwcHg7XFxuICAgIGZvbnQtZmFtaWx5OiAnTG9ic3RlcicsIHNhbnMtc2VyaWY7XFxufVxcblxcblxcbiNoZWFkZXJ7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGhlaWdodDogMTB2aDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGdhcDozMHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBncmV5O1xcbiAgICBmb250LWZhbWlseTogJ0pvc2VmaW4gU2FucycsIHNhbnMtc2VyaWY7XFxuICAgIGZvbnQtc2l6ZTogMjVweDtcXG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcXG59XFxuXFxuI21pZGRsZXtcXG4gICAgZGlzcGxheTpmbGV4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoODgsIDgzLCAzMyk7XFxuICAgIGhlaWdodDogOTB2aDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gKyBcIik7XFxuICAgIGZvbnQtZmFtaWx5OiAnSm9zZWZpbiBTYW5zJywgc2Fucy1zZXJpZjtcXG59XFxuXFxuI21pZGRsZS13aW5kb3d7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcXG4gICAgY29sb3I6d2hpdGU7XFxuICAgIGhlaWdodDogNzAlO1xcbiAgICB3aWR0aDogNTAlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG59XFxuXFxuLmhlYWRlci1idXR0b257XFxuICAgIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgLyogYmFja2dyb3VuZC1jb2xvcjogdHVycXVvaXNlOyAqL1xcbiAgICBoZWlnaHQ6IDUwcHg7XFxuICAgIHdpZHRoOiAxNTBweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuXFxufVxcblxcbi5oZWFkZXItYnV0dG9uOmhvdmVye1xcbiAgICBib3JkZXItYm90dG9tOiAzcHggc29saWQgd2hpdGU7XFxufVxcblxcbi5jYXJke1xcbiAgICBoZWlnaHQ6MTAwJTtcXG4gICAgd2lkdGg6MTAwJTtcXG4gICAgZGlzcGxheTogZmxleDsgICAgXFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgICBmb250LXNpemU6IDIwcHg7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSx3QkFBd0I7QUFDNUI7O0FBRUE7SUFDSSxTQUFTO0FBQ2I7O0FBRUE7O0lBRUksWUFBWTtJQUNaLDJDQUEyQztJQUMzQyxhQUFhO0lBQ2IsdUJBQXVCO0lBQ3ZCLG1CQUFtQjtJQUNuQixlQUFlO0lBQ2Ysa0NBQWtDO0FBQ3RDOzs7QUFHQTtJQUNJLGFBQWE7SUFDYixZQUFZO0lBQ1osdUJBQXVCO0lBQ3ZCLG1CQUFtQjtJQUNuQixRQUFRO0lBQ1Isc0JBQXNCO0lBQ3RCLHVDQUF1QztJQUN2QyxlQUFlO0lBQ2YsZ0JBQWdCO0FBQ3BCOztBQUVBO0lBQ0ksWUFBWTtJQUNaLGlDQUFpQztJQUNqQyxZQUFZO0lBQ1osdUJBQXVCO0lBQ3ZCLG1CQUFtQjtJQUNuQixtREFBMkI7SUFDM0IsdUNBQXVDO0FBQzNDOztBQUVBO0lBQ0ksb0NBQW9DO0lBQ3BDLFdBQVc7SUFDWCxXQUFXO0lBQ1gsVUFBVTtJQUNWLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLHdCQUF3QjtJQUN4QixpQ0FBaUM7SUFDakMsWUFBWTtJQUNaLFlBQVk7SUFDWixhQUFhO0lBQ2IsdUJBQXVCO0lBQ3ZCLG1CQUFtQjs7QUFFdkI7O0FBRUE7SUFDSSw4QkFBOEI7QUFDbEM7O0FBRUE7SUFDSSxXQUFXO0lBQ1gsVUFBVTtJQUNWLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixlQUFlO0FBQ25CXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIip7XFxuICAgIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuYm9keXtcXG4gICAgbWFyZ2luOiAwO1xcbn1cXG5cXG4jdGl0bGV7XFxuICAgIFxcbiAgICBoZWlnaHQ6IDEwdmg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA5LCAxNTUsIDU1LCAwLjg2Myk7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmb250LXNpemU6IDMwcHg7XFxuICAgIGZvbnQtZmFtaWx5OiAnTG9ic3RlcicsIHNhbnMtc2VyaWY7XFxufVxcblxcblxcbiNoZWFkZXJ7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGhlaWdodDogMTB2aDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGdhcDozMHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBncmV5O1xcbiAgICBmb250LWZhbWlseTogJ0pvc2VmaW4gU2FucycsIHNhbnMtc2VyaWY7XFxuICAgIGZvbnQtc2l6ZTogMjVweDtcXG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcXG59XFxuXFxuI21pZGRsZXtcXG4gICAgZGlzcGxheTpmbGV4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoODgsIDgzLCAzMyk7XFxuICAgIGhlaWdodDogOTB2aDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQ6IHVybCgnaWNvbi5zdmcnKTtcXG4gICAgZm9udC1mYW1pbHk6ICdKb3NlZmluIFNhbnMnLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG4jbWlkZGxlLXdpbmRvd3tcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xcbiAgICBjb2xvcjp3aGl0ZTtcXG4gICAgaGVpZ2h0OiA3MCU7XFxuICAgIHdpZHRoOiA1MCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbn1cXG5cXG4uaGVhZGVyLWJ1dHRvbntcXG4gICAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAvKiBiYWNrZ3JvdW5kLWNvbG9yOiB0dXJxdW9pc2U7ICovXFxuICAgIGhlaWdodDogNTBweDtcXG4gICAgd2lkdGg6IDE1MHB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG5cXG59XFxuXFxuLmhlYWRlci1idXR0b246aG92ZXJ7XFxuICAgIGJvcmRlci1ib3R0b206IDNweCBzb2xpZCB3aGl0ZTtcXG59XFxuXFxuLmNhcmR7XFxuICAgIGhlaWdodDoxMDAlO1xcbiAgICB3aWR0aDoxMDAlO1xcbiAgICBkaXNwbGF5OiBmbGV4OyAgICBcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgIGZvbnQtc2l6ZTogMjBweDtcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHVybCA9IFN0cmluZyh1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsKTsgLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG5cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICB1cmwgKz0gb3B0aW9ucy5oYXNoO1xuICB9IC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblxuXG4gIGlmICgvW1wiJygpIFxcdFxcbl18KCUyMCkvLnRlc3QodXJsKSB8fCBvcHRpb25zLm5lZWRRdW90ZXMpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiLyohIGh0dHBzOi8vbXRocy5iZS9jc3Nlc2MgdjMuMC4wIGJ5IEBtYXRoaWFzICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3QgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG5cdGlmICghb3B0aW9ucykge1xuXHRcdHJldHVybiBkZWZhdWx0cztcblx0fVxuXHR2YXIgcmVzdWx0ID0ge307XG5cdGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuXHRcdC8vIGBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoa2V5KSB7IOKApiB9YCBpcyBub3QgbmVlZGVkIGhlcmUsIHNpbmNlXG5cdFx0Ly8gb25seSByZWNvZ25pemVkIG9wdGlvbiBuYW1lcyBhcmUgdXNlZC5cblx0XHRyZXN1bHRba2V5XSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywga2V5KSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRzW2tleV07XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciByZWdleEFueVNpbmdsZUVzY2FwZSA9IC9bIC0sXFwuXFwvOi1AXFxbLVxcXmBcXHstfl0vO1xudmFyIHJlZ2V4U2luZ2xlRXNjYXBlID0gL1sgLSxcXC5cXC86LUBcXFtcXF1cXF5gXFx7LX5dLztcbnZhciByZWdleEFsd2F5c0VzY2FwZSA9IC9bJ1wiXFxcXF0vO1xudmFyIHJlZ2V4RXhjZXNzaXZlU3BhY2VzID0gLyhefFxcXFwrKT8oXFxcXFtBLUYwLTldezEsNn0pXFx4MjAoPyFbYS1mQS1GMC05XFx4MjBdKS9nO1xuXG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvY3NzLWVzY2FwZXMjY3NzXG52YXIgY3NzZXNjID0gZnVuY3Rpb24gY3NzZXNjKHN0cmluZywgb3B0aW9ucykge1xuXHRvcHRpb25zID0gbWVyZ2Uob3B0aW9ucywgY3NzZXNjLm9wdGlvbnMpO1xuXHRpZiAob3B0aW9ucy5xdW90ZXMgIT0gJ3NpbmdsZScgJiYgb3B0aW9ucy5xdW90ZXMgIT0gJ2RvdWJsZScpIHtcblx0XHRvcHRpb25zLnF1b3RlcyA9ICdzaW5nbGUnO1xuXHR9XG5cdHZhciBxdW90ZSA9IG9wdGlvbnMucXVvdGVzID09ICdkb3VibGUnID8gJ1wiJyA6ICdcXCcnO1xuXHR2YXIgaXNJZGVudGlmaWVyID0gb3B0aW9ucy5pc0lkZW50aWZpZXI7XG5cblx0dmFyIGZpcnN0Q2hhciA9IHN0cmluZy5jaGFyQXQoMCk7XG5cdHZhciBvdXRwdXQgPSAnJztcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YXIgY2hhcmFjdGVyID0gc3RyaW5nLmNoYXJBdChjb3VudGVyKyspO1xuXHRcdHZhciBjb2RlUG9pbnQgPSBjaGFyYWN0ZXIuY2hhckNvZGVBdCgpO1xuXHRcdHZhciB2YWx1ZSA9IHZvaWQgMDtcblx0XHQvLyBJZiBpdOKAmXMgbm90IGEgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcuKAplxuXHRcdGlmIChjb2RlUG9pbnQgPCAweDIwIHx8IGNvZGVQb2ludCA+IDB4N0UpIHtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBJdOKAmXMgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHRcdHZhciBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkge1xuXHRcdFx0XHRcdC8vIG5leHQgY2hhcmFjdGVyIGlzIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRjb2RlUG9pbnQgPSAoKGNvZGVQb2ludCAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEl04oCZcyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZVxuXHRcdFx0XHRcdC8vIHRoZSBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhbHVlID0gJ1xcXFwnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJyAnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAob3B0aW9ucy5lc2NhcGVFdmVyeXRoaW5nKSB7XG5cdFx0XHRcdGlmIChyZWdleEFueVNpbmdsZUVzY2FwZS50ZXN0KGNoYXJhY3RlcikpIHtcblx0XHRcdFx0XHR2YWx1ZSA9ICdcXFxcJyArIGNoYXJhY3Rlcjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9ICdcXFxcJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICcgJztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgvW1xcdFxcblxcZlxcclxceDBCXS8udGVzdChjaGFyYWN0ZXIpKSB7XG5cdFx0XHRcdHZhbHVlID0gJ1xcXFwnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJyAnO1xuXHRcdFx0fSBlbHNlIGlmIChjaGFyYWN0ZXIgPT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXIgJiYgKGNoYXJhY3RlciA9PSAnXCInICYmIHF1b3RlID09IGNoYXJhY3RlciB8fCBjaGFyYWN0ZXIgPT0gJ1xcJycgJiYgcXVvdGUgPT0gY2hhcmFjdGVyKSB8fCBpc0lkZW50aWZpZXIgJiYgcmVnZXhTaW5nbGVFc2NhcGUudGVzdChjaGFyYWN0ZXIpKSB7XG5cdFx0XHRcdHZhbHVlID0gJ1xcXFwnICsgY2hhcmFjdGVyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSBjaGFyYWN0ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdG91dHB1dCArPSB2YWx1ZTtcblx0fVxuXG5cdGlmIChpc0lkZW50aWZpZXIpIHtcblx0XHRpZiAoL14tWy1cXGRdLy50ZXN0KG91dHB1dCkpIHtcblx0XHRcdG91dHB1dCA9ICdcXFxcLScgKyBvdXRwdXQuc2xpY2UoMSk7XG5cdFx0fSBlbHNlIGlmICgvXFxkLy50ZXN0KGZpcnN0Q2hhcikpIHtcblx0XHRcdG91dHB1dCA9ICdcXFxcMycgKyBmaXJzdENoYXIgKyAnICcgKyBvdXRwdXQuc2xpY2UoMSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHNwYWNlcyBhZnRlciBgXFxIRVhgIGVzY2FwZXMgdGhhdCBhcmUgbm90IGZvbGxvd2VkIGJ5IGEgaGV4IGRpZ2l0LFxuXHQvLyBzaW5jZSB0aGV54oCZcmUgcmVkdW5kYW50LiBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSBlc2NhcGVcblx0Ly8gc2VxdWVuY2UgaXNu4oCZdCBwcmVjZWRlZCBieSBhbiBvZGQgbnVtYmVyIG9mIGJhY2tzbGFzaGVzLlxuXHRvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShyZWdleEV4Y2Vzc2l2ZVNwYWNlcywgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcblx0XHRpZiAoJDEgJiYgJDEubGVuZ3RoICUgMikge1xuXHRcdFx0Ly8gSXTigJlzIG5vdCBzYWZlIHRvIHJlbW92ZSB0aGUgc3BhY2UsIHNvIGRvbuKAmXQuXG5cdFx0XHRyZXR1cm4gJDA7XG5cdFx0fVxuXHRcdC8vIFN0cmlwIHRoZSBzcGFjZS5cblx0XHRyZXR1cm4gKCQxIHx8ICcnKSArICQyO1xuXHR9KTtcblxuXHRpZiAoIWlzSWRlbnRpZmllciAmJiBvcHRpb25zLndyYXApIHtcblx0XHRyZXR1cm4gcXVvdGUgKyBvdXRwdXQgKyBxdW90ZTtcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufTtcblxuLy8gRXhwb3NlIGRlZmF1bHQgb3B0aW9ucyAoc28gdGhleSBjYW4gYmUgb3ZlcnJpZGRlbiBnbG9iYWxseSkuXG5jc3Nlc2Mub3B0aW9ucyA9IHtcblx0J2VzY2FwZUV2ZXJ5dGhpbmcnOiBmYWxzZSxcblx0J2lzSWRlbnRpZmllcic6IGZhbHNlLFxuXHQncXVvdGVzJzogJ3NpbmdsZScsXG5cdCd3cmFwJzogZmFsc2Vcbn07XG5cbmNzc2VzYy52ZXJzaW9uID0gJzMuMC4wJztcblxubW9kdWxlLmV4cG9ydHMgPSBjc3Nlc2M7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3Byb2Nlc3NvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcHJvY2Vzc29yXCIpKTtcblxudmFyIHNlbGVjdG9ycyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3NlbGVjdG9yc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIHBhcnNlciA9IGZ1bmN0aW9uIHBhcnNlcihwcm9jZXNzb3IpIHtcbiAgcmV0dXJuIG5ldyBfcHJvY2Vzc29yW1wiZGVmYXVsdFwiXShwcm9jZXNzb3IpO1xufTtcblxuT2JqZWN0LmFzc2lnbihwYXJzZXIsIHNlbGVjdG9ycyk7XG5kZWxldGUgcGFyc2VyLl9fZXNNb2R1bGU7XG52YXIgX2RlZmF1bHQgPSBwYXJzZXI7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9yb290ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvcm9vdFwiKSk7XG5cbnZhciBfc2VsZWN0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NlbGVjdG9ycy9zZWxlY3RvclwiKSk7XG5cbnZhciBfY2xhc3NOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvY2xhc3NOYW1lXCIpKTtcblxudmFyIF9jb21tZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvY29tbWVudFwiKSk7XG5cbnZhciBfaWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NlbGVjdG9ycy9pZFwiKSk7XG5cbnZhciBfdGFnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvdGFnXCIpKTtcblxudmFyIF9zdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NlbGVjdG9ycy9zdHJpbmdcIikpO1xuXG52YXIgX3BzZXVkbyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2VsZWN0b3JzL3BzZXVkb1wiKSk7XG5cbnZhciBfYXR0cmlidXRlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vc2VsZWN0b3JzL2F0dHJpYnV0ZVwiKSk7XG5cbnZhciBfdW5pdmVyc2FsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvdW5pdmVyc2FsXCIpKTtcblxudmFyIF9jb21iaW5hdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZWxlY3RvcnMvY29tYmluYXRvclwiKSk7XG5cbnZhciBfbmVzdGluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2VsZWN0b3JzL25lc3RpbmdcIikpO1xuXG52YXIgX3NvcnRBc2NlbmRpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NvcnRBc2NlbmRpbmdcIikpO1xuXG52YXIgX3Rva2VuaXplID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdG9rZW5pemVcIikpO1xuXG52YXIgdG9rZW5zID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdG9rZW5UeXBlc1wiKSk7XG5cbnZhciB0eXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3NlbGVjdG9ycy90eXBlc1wiKSk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBfV0hJVEVTUEFDRV9UT0tFTlMsIF9PYmplY3QkYXNzaWduO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIFdISVRFU1BBQ0VfVE9LRU5TID0gKF9XSElURVNQQUNFX1RPS0VOUyA9IHt9LCBfV0hJVEVTUEFDRV9UT0tFTlNbdG9rZW5zLnNwYWNlXSA9IHRydWUsIF9XSElURVNQQUNFX1RPS0VOU1t0b2tlbnMuY3JdID0gdHJ1ZSwgX1dISVRFU1BBQ0VfVE9LRU5TW3Rva2Vucy5mZWVkXSA9IHRydWUsIF9XSElURVNQQUNFX1RPS0VOU1t0b2tlbnMubmV3bGluZV0gPSB0cnVlLCBfV0hJVEVTUEFDRV9UT0tFTlNbdG9rZW5zLnRhYl0gPSB0cnVlLCBfV0hJVEVTUEFDRV9UT0tFTlMpO1xudmFyIFdISVRFU1BBQ0VfRVFVSVZfVE9LRU5TID0gT2JqZWN0LmFzc2lnbih7fSwgV0hJVEVTUEFDRV9UT0tFTlMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnblt0b2tlbnMuY29tbWVudF0gPSB0cnVlLCBfT2JqZWN0JGFzc2lnbikpO1xuXG5mdW5jdGlvbiB0b2tlblN0YXJ0KHRva2VuKSB7XG4gIHJldHVybiB7XG4gICAgbGluZTogdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9MSU5FXSxcbiAgICBjb2x1bW46IHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfQ09MXVxuICB9O1xufVxuXG5mdW5jdGlvbiB0b2tlbkVuZCh0b2tlbikge1xuICByZXR1cm4ge1xuICAgIGxpbmU6IHRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0xJTkVdLFxuICAgIGNvbHVtbjogdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5FTkRfQ09MXVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2Uoc3RhcnRMaW5lLCBzdGFydENvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHtcbiAgICAgIGxpbmU6IHN0YXJ0TGluZSxcbiAgICAgIGNvbHVtbjogc3RhcnRDb2x1bW5cbiAgICB9LFxuICAgIGVuZDoge1xuICAgICAgbGluZTogZW5kTGluZSxcbiAgICAgIGNvbHVtbjogZW5kQ29sdW1uXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUb2tlblNvdXJjZSh0b2tlbikge1xuICByZXR1cm4gZ2V0U291cmNlKHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfTElORV0sIHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfQ09MXSwgdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5FTkRfTElORV0sIHRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pO1xufVxuXG5mdW5jdGlvbiBnZXRUb2tlblNvdXJjZVNwYW4oc3RhcnRUb2tlbiwgZW5kVG9rZW4pIHtcbiAgaWYgKCFzdGFydFRva2VuKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBnZXRTb3VyY2Uoc3RhcnRUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0xJTkVdLCBzdGFydFRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfQ09MXSwgZW5kVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5FTkRfTElORV0sIGVuZFRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZVByb3Aobm9kZSwgcHJvcCkge1xuICB2YXIgdmFsdWUgPSBub2RlW3Byb3BdO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodmFsdWUuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xKSB7XG4gICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnKTtcbiAgICBub2RlW3Byb3BdID0gKDAsIF91dGlsLnVuZXNjKSh2YWx1ZSk7XG5cbiAgICBpZiAobm9kZS5yYXdzW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGUucmF3c1twcm9wXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpbmRleGVzT2YoYXJyYXksIGl0ZW0pIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICB3aGlsZSAoKGkgPSBhcnJheS5pbmRleE9mKGl0ZW0sIGkgKyAxKSkgIT09IC0xKSB7XG4gICAgaW5kZXhlcy5wdXNoKGkpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4ZXM7XG59XG5cbmZ1bmN0aW9uIHVuaXFzKCkge1xuICB2YXIgbGlzdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFyZ3VtZW50cyk7XG4gIHJldHVybiBsaXN0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIHJldHVybiBpID09PSBsaXN0LmluZGV4T2YoaXRlbSk7XG4gIH0pO1xufVxuXG52YXIgUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFyc2VyKHJ1bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlID0gcnVsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxvc3N5OiBmYWxzZSxcbiAgICAgIHNhZmU6IGZhbHNlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5jc3MgPSB0eXBlb2YgdGhpcy5ydWxlID09PSAnc3RyaW5nJyA/IHRoaXMucnVsZSA6IHRoaXMucnVsZS5zZWxlY3RvcjtcbiAgICB0aGlzLnRva2VucyA9ICgwLCBfdG9rZW5pemVbXCJkZWZhdWx0XCJdKSh7XG4gICAgICBjc3M6IHRoaXMuY3NzLFxuICAgICAgZXJyb3I6IHRoaXMuX2Vycm9yR2VuZXJhdG9yKCksXG4gICAgICBzYWZlOiB0aGlzLm9wdGlvbnMuc2FmZVxuICAgIH0pO1xuICAgIHZhciByb290U291cmNlID0gZ2V0VG9rZW5Tb3VyY2VTcGFuKHRoaXMudG9rZW5zWzBdLCB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSk7XG4gICAgdGhpcy5yb290ID0gbmV3IF9yb290W1wiZGVmYXVsdFwiXSh7XG4gICAgICBzb3VyY2U6IHJvb3RTb3VyY2VcbiAgICB9KTtcbiAgICB0aGlzLnJvb3QuZXJyb3JHZW5lcmF0b3IgPSB0aGlzLl9lcnJvckdlbmVyYXRvcigpO1xuICAgIHZhciBzZWxlY3RvciA9IG5ldyBfc2VsZWN0b3JbXCJkZWZhdWx0XCJdKHtcbiAgICAgIHNvdXJjZToge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGxpbmU6IDEsXG4gICAgICAgICAgY29sdW1uOiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJvb3QuYXBwZW5kKHNlbGVjdG9yKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICB0aGlzLmxvb3AoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5fZXJyb3JHZW5lcmF0b3IgPSBmdW5jdGlvbiBfZXJyb3JHZW5lcmF0b3IoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgZXJyb3JPcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIF90aGlzLnJ1bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5ydWxlLmVycm9yKG1lc3NhZ2UsIGVycm9yT3B0aW9ucyk7XG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uYXR0cmlidXRlID0gZnVuY3Rpb24gYXR0cmlidXRlKCkge1xuICAgIHZhciBhdHRyID0gW107XG4gICAgdmFyIHN0YXJ0aW5nVG9rZW4gPSB0aGlzLmN1cnJUb2tlbjtcbiAgICB0aGlzLnBvc2l0aW9uKys7XG5cbiAgICB3aGlsZSAodGhpcy5wb3NpdGlvbiA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdICE9PSB0b2tlbnMuY2xvc2VTcXVhcmUpIHtcbiAgICAgIGF0dHIucHVzaCh0aGlzLmN1cnJUb2tlbik7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gIT09IHRva2Vucy5jbG9zZVNxdWFyZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoJ2Nsb3Npbmcgc3F1YXJlIGJyYWNrZXQnLCB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10pO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBhdHRyLmxlbmd0aDtcbiAgICB2YXIgbm9kZSA9IHtcbiAgICAgIHNvdXJjZTogZ2V0U291cmNlKHN0YXJ0aW5nVG9rZW5bMV0sIHN0YXJ0aW5nVG9rZW5bMl0sIHRoaXMuY3VyclRva2VuWzNdLCB0aGlzLmN1cnJUb2tlbls0XSksXG4gICAgICBzb3VyY2VJbmRleDogc3RhcnRpbmdUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cbiAgICB9O1xuXG4gICAgaWYgKGxlbiA9PT0gMSAmJiAhflt0b2tlbnMud29yZF0uaW5kZXhPZihhdHRyWzBdW190b2tlbml6ZS5GSUVMRFMuVFlQRV0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnYXR0cmlidXRlJywgYXR0clswXVtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10pO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBzcGFjZUJlZm9yZSA9ICcnO1xuICAgIHZhciBjb21tZW50QmVmb3JlID0gJyc7XG4gICAgdmFyIGxhc3RBZGRlZCA9IG51bGw7XG4gICAgdmFyIHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4gPSBmYWxzZTtcblxuICAgIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICAgIHZhciB0b2tlbiA9IGF0dHJbcG9zXTtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50KHRva2VuKTtcbiAgICAgIHZhciBuZXh0ID0gYXR0cltwb3MgKyAxXTtcblxuICAgICAgc3dpdGNoICh0b2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdKSB7XG4gICAgICAgIGNhc2UgdG9rZW5zLnNwYWNlOlxuICAgICAgICAgIC8vIGlmIChcbiAgICAgICAgICAvLyAgICAgbGVuID09PSAxIHx8XG4gICAgICAgICAgLy8gICAgIHBvcyA9PT0gMCAmJiB0aGlzLmNvbnRlbnQobmV4dCkgPT09ICd8J1xuICAgICAgICAgIC8vICkge1xuICAgICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnYXR0cmlidXRlJywgdG9rZW5bVE9LRU4uU1RBUlRfUE9TXSwgY29udGVudCk7XG4gICAgICAgICAgLy8gfVxuICAgICAgICAgIHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4gPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb3NzeSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxhc3RBZGRlZCkge1xuICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3NwYWNlcycsIGxhc3RBZGRlZCk7XG4gICAgICAgICAgICB2YXIgcHJldkNvbnRlbnQgPSBub2RlLnNwYWNlc1tsYXN0QWRkZWRdLmFmdGVyIHx8ICcnO1xuICAgICAgICAgICAgbm9kZS5zcGFjZXNbbGFzdEFkZGVkXS5hZnRlciA9IHByZXZDb250ZW50ICsgY29udGVudDtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ0NvbW1lbnQgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAnc3BhY2VzJywgbGFzdEFkZGVkLCAnYWZ0ZXInKSB8fCBudWxsO1xuXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdDb21tZW50KSB7XG4gICAgICAgICAgICAgIG5vZGUucmF3cy5zcGFjZXNbbGFzdEFkZGVkXS5hZnRlciA9IGV4aXN0aW5nQ29tbWVudCArIGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gc3BhY2VCZWZvcmUgKyBjb250ZW50O1xuICAgICAgICAgICAgY29tbWVudEJlZm9yZSA9IGNvbW1lbnRCZWZvcmUgKyBjb250ZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdG9rZW5zLmFzdGVyaXNrOlxuICAgICAgICAgIGlmIChuZXh0W190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5lcXVhbHMpIHtcbiAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSBjb250ZW50O1xuICAgICAgICAgICAgbGFzdEFkZGVkID0gJ29wZXJhdG9yJztcbiAgICAgICAgICB9IGVsc2UgaWYgKCghbm9kZS5uYW1lc3BhY2UgfHwgbGFzdEFkZGVkID09PSBcIm5hbWVzcGFjZVwiICYmICFzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuKSAmJiBuZXh0KSB7XG4gICAgICAgICAgICBpZiAoc3BhY2VCZWZvcmUpIHtcbiAgICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3NwYWNlcycsICdhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgICAgbm9kZS5zcGFjZXMuYXR0cmlidXRlLmJlZm9yZSA9IHNwYWNlQmVmb3JlO1xuICAgICAgICAgICAgICBzcGFjZUJlZm9yZSA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tbWVudEJlZm9yZSkge1xuICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycsICdzcGFjZXMnLCAnYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAgIG5vZGUucmF3cy5zcGFjZXMuYXR0cmlidXRlLmJlZm9yZSA9IHNwYWNlQmVmb3JlO1xuICAgICAgICAgICAgICBjb21tZW50QmVmb3JlID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUubmFtZXNwYWNlID0gKG5vZGUubmFtZXNwYWNlIHx8IFwiXCIpICsgY29udGVudDtcbiAgICAgICAgICAgIHZhciByYXdWYWx1ZSA9ICgwLCBfdXRpbC5nZXRQcm9wKShub2RlLCAncmF3cycsICduYW1lc3BhY2UnKSB8fCBudWxsO1xuXG4gICAgICAgICAgICBpZiAocmF3VmFsdWUpIHtcbiAgICAgICAgICAgICAgbm9kZS5yYXdzLm5hbWVzcGFjZSArPSBjb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0QWRkZWQgPSAnbmFtZXNwYWNlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0b2tlbnMuZG9sbGFyOlxuICAgICAgICAgIGlmIChsYXN0QWRkZWQgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgdmFyIG9sZFJhd1ZhbHVlID0gKDAsIF91dGlsLmdldFByb3ApKG5vZGUsICdyYXdzJywgJ3ZhbHVlJyk7XG4gICAgICAgICAgICBub2RlLnZhbHVlICs9IFwiJFwiO1xuXG4gICAgICAgICAgICBpZiAob2xkUmF3VmFsdWUpIHtcbiAgICAgICAgICAgICAgbm9kZS5yYXdzLnZhbHVlID0gb2xkUmF3VmFsdWUgKyBcIiRcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGxzIHRocm91Z2hcblxuICAgICAgICBjYXNlIHRva2Vucy5jYXJldDpcbiAgICAgICAgICBpZiAobmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuZXF1YWxzKSB7XG4gICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gY29udGVudDtcbiAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdvcGVyYXRvcic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdG9rZW5zLmNvbWJpbmF0b3I6XG4gICAgICAgICAgaWYgKGNvbnRlbnQgPT09ICd+JyAmJiBuZXh0W190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5lcXVhbHMpIHtcbiAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSBjb250ZW50O1xuICAgICAgICAgICAgbGFzdEFkZGVkID0gJ29wZXJhdG9yJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGVudCAhPT0gJ3wnKSB7XG4gICAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuZXF1YWxzKSB7XG4gICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gY29udGVudDtcbiAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdvcGVyYXRvcic7XG4gICAgICAgICAgfSBlbHNlIGlmICghbm9kZS5uYW1lc3BhY2UgJiYgIW5vZGUuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBub2RlLm5hbWVzcGFjZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdG9rZW5zLndvcmQ6XG4gICAgICAgICAgaWYgKG5leHQgJiYgdGhpcy5jb250ZW50KG5leHQpID09PSAnfCcgJiYgYXR0cltwb3MgKyAyXSAmJiBhdHRyW3BvcyArIDJdW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gIT09IHRva2Vucy5lcXVhbHMgJiYgLy8gdGhpcyBsb29rLWFoZWFkIHByb2JhYmx5IGZhaWxzIHdpdGggY29tbWVudCBub2RlcyBpbnZvbHZlZC5cbiAgICAgICAgICAhbm9kZS5vcGVyYXRvciAmJiAhbm9kZS5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIG5vZGUubmFtZXNwYWNlID0gY29udGVudDtcbiAgICAgICAgICAgIGxhc3RBZGRlZCA9ICduYW1lc3BhY2UnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUuYXR0cmlidXRlIHx8IGxhc3RBZGRlZCA9PT0gXCJhdHRyaWJ1dGVcIiAmJiAhc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbikge1xuICAgICAgICAgICAgaWYgKHNwYWNlQmVmb3JlKSB7XG4gICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdzcGFjZXMnLCAnYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAgIG5vZGUuc3BhY2VzLmF0dHJpYnV0ZS5iZWZvcmUgPSBzcGFjZUJlZm9yZTtcbiAgICAgICAgICAgICAgc3BhY2VCZWZvcmUgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnLCAnc3BhY2VzJywgJ2F0dHJpYnV0ZScpO1xuICAgICAgICAgICAgICBub2RlLnJhd3Muc3BhY2VzLmF0dHJpYnV0ZS5iZWZvcmUgPSBjb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICBjb21tZW50QmVmb3JlID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlID0gKG5vZGUuYXR0cmlidXRlIHx8IFwiXCIpICsgY29udGVudDtcblxuICAgICAgICAgICAgdmFyIF9yYXdWYWx1ZSA9ICgwLCBfdXRpbC5nZXRQcm9wKShub2RlLCAncmF3cycsICdhdHRyaWJ1dGUnKSB8fCBudWxsO1xuXG4gICAgICAgICAgICBpZiAoX3Jhd1ZhbHVlKSB7XG4gICAgICAgICAgICAgIG5vZGUucmF3cy5hdHRyaWJ1dGUgKz0gY29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdEFkZGVkID0gJ2F0dHJpYnV0ZSc7XG4gICAgICAgICAgfSBlbHNlIGlmICghbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlICE9PSBcIlwiIHx8IGxhc3RBZGRlZCA9PT0gXCJ2YWx1ZVwiICYmICFzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuKSB7XG4gICAgICAgICAgICB2YXIgX3VuZXNjYXBlZCA9ICgwLCBfdXRpbC51bmVzYykoY29udGVudCk7XG5cbiAgICAgICAgICAgIHZhciBfb2xkUmF3VmFsdWUgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAndmFsdWUnKSB8fCAnJztcblxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gbm9kZS52YWx1ZSB8fCAnJztcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBvbGRWYWx1ZSArIF91bmVzY2FwZWQ7XG4gICAgICAgICAgICBub2RlLnF1b3RlTWFyayA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChfdW5lc2NhcGVkICE9PSBjb250ZW50IHx8IF9vbGRSYXdWYWx1ZSkge1xuICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycpO1xuICAgICAgICAgICAgICBub2RlLnJhd3MudmFsdWUgPSAoX29sZFJhd1ZhbHVlIHx8IG9sZFZhbHVlKSArIGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RBZGRlZCA9ICd2YWx1ZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnNlbnNpdGl2ZSA9IGNvbnRlbnQgPT09ICdpJyB8fCBjb250ZW50ID09PSBcIklcIjtcblxuICAgICAgICAgICAgaWYgKChub2RlLnZhbHVlIHx8IG5vZGUudmFsdWUgPT09ICcnKSAmJiAobm9kZS5xdW90ZU1hcmsgfHwgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbikpIHtcbiAgICAgICAgICAgICAgbm9kZS5pbnNlbnNpdGl2ZSA9IGluc2Vuc2l0aXZlO1xuXG4gICAgICAgICAgICAgIGlmICghaW5zZW5zaXRpdmUgfHwgY29udGVudCA9PT0gXCJJXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycpO1xuICAgICAgICAgICAgICAgIG5vZGUucmF3cy5pbnNlbnNpdGl2ZUZsYWcgPSBjb250ZW50O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGFzdEFkZGVkID0gJ2luc2Vuc2l0aXZlJztcblxuICAgICAgICAgICAgICBpZiAoc3BhY2VCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAnc3BhY2VzJywgJ2luc2Vuc2l0aXZlJyk7XG4gICAgICAgICAgICAgICAgbm9kZS5zcGFjZXMuaW5zZW5zaXRpdmUuYmVmb3JlID0gc3BhY2VCZWZvcmU7XG4gICAgICAgICAgICAgICAgc3BhY2VCZWZvcmUgPSAnJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb21tZW50QmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnLCAnc3BhY2VzJywgJ2luc2Vuc2l0aXZlJyk7XG4gICAgICAgICAgICAgICAgbm9kZS5yYXdzLnNwYWNlcy5pbnNlbnNpdGl2ZS5iZWZvcmUgPSBjb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGNvbW1lbnRCZWZvcmUgPSAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnZhbHVlIHx8IG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIGxhc3RBZGRlZCA9ICd2YWx1ZSc7XG4gICAgICAgICAgICAgIG5vZGUudmFsdWUgKz0gY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAobm9kZS5yYXdzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yYXdzLnZhbHVlICs9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0b2tlbnMuc3RyOlxuICAgICAgICAgIGlmICghbm9kZS5hdHRyaWJ1dGUgfHwgIW5vZGUub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgYW4gYXR0cmlidXRlIGZvbGxvd2VkIGJ5IGFuIG9wZXJhdG9yIHByZWNlZGluZyB0aGUgc3RyaW5nLlwiLCB7XG4gICAgICAgICAgICAgIGluZGV4OiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfdW5lc2NhcGVWYWx1ZSA9ICgwLCBfYXR0cmlidXRlLnVuZXNjYXBlVmFsdWUpKGNvbnRlbnQpLFxuICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBfdW5lc2NhcGVWYWx1ZS51bmVzY2FwZWQsXG4gICAgICAgICAgICAgIHF1b3RlTWFyayA9IF91bmVzY2FwZVZhbHVlLnF1b3RlTWFyaztcblxuICAgICAgICAgIG5vZGUudmFsdWUgPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgbm9kZS5xdW90ZU1hcmsgPSBxdW90ZU1hcms7XG4gICAgICAgICAgbGFzdEFkZGVkID0gJ3ZhbHVlJztcbiAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycpO1xuICAgICAgICAgIG5vZGUucmF3cy52YWx1ZSA9IGNvbnRlbnQ7XG4gICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdG9rZW5zLmVxdWFsczpcbiAgICAgICAgICBpZiAoIW5vZGUuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnYXR0cmlidXRlJywgdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLCBjb250ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1VuZXhwZWN0ZWQgXCI9XCIgZm91bmQ7IGFuIG9wZXJhdG9yIHdhcyBhbHJlYWR5IGRlZmluZWQuJywge1xuICAgICAgICAgICAgICBpbmRleDogdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2RlLm9wZXJhdG9yID0gbm9kZS5vcGVyYXRvciA/IG5vZGUub3BlcmF0b3IgKyBjb250ZW50IDogY29udGVudDtcbiAgICAgICAgICBsYXN0QWRkZWQgPSAnb3BlcmF0b3InO1xuICAgICAgICAgIHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRva2Vucy5jb21tZW50OlxuICAgICAgICAgIGlmIChsYXN0QWRkZWQpIHtcbiAgICAgICAgICAgIGlmIChzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuIHx8IG5leHQgJiYgbmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuc3BhY2UgfHwgbGFzdEFkZGVkID09PSAnaW5zZW5zaXRpdmUnKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0Q29tbWVudCA9ICgwLCBfdXRpbC5nZXRQcm9wKShub2RlLCAnc3BhY2VzJywgbGFzdEFkZGVkLCAnYWZ0ZXInKSB8fCAnJztcbiAgICAgICAgICAgICAgdmFyIHJhd0xhc3RDb21tZW50ID0gKDAsIF91dGlsLmdldFByb3ApKG5vZGUsICdyYXdzJywgJ3NwYWNlcycsIGxhc3RBZGRlZCwgJ2FmdGVyJykgfHwgbGFzdENvbW1lbnQ7XG4gICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJywgJ3NwYWNlcycsIGxhc3RBZGRlZCk7XG4gICAgICAgICAgICAgIG5vZGUucmF3cy5zcGFjZXNbbGFzdEFkZGVkXS5hZnRlciA9IHJhd0xhc3RDb21tZW50ICsgY29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0VmFsdWUgPSBub2RlW2xhc3RBZGRlZF0gfHwgJyc7XG4gICAgICAgICAgICAgIHZhciByYXdMYXN0VmFsdWUgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCBsYXN0QWRkZWQpIHx8IGxhc3RWYWx1ZTtcbiAgICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnKTtcbiAgICAgICAgICAgICAgbm9kZS5yYXdzW2xhc3RBZGRlZF0gPSByYXdMYXN0VmFsdWUgKyBjb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21tZW50QmVmb3JlID0gY29tbWVudEJlZm9yZSArIGNvbnRlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgXFxcIlwiICsgY29udGVudCArIFwiXFxcIiBmb3VuZC5cIiwge1xuICAgICAgICAgICAgaW5kZXg6IHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICB1bmVzY2FwZVByb3Aobm9kZSwgXCJhdHRyaWJ1dGVcIik7XG4gICAgdW5lc2NhcGVQcm9wKG5vZGUsIFwibmFtZXNwYWNlXCIpO1xuICAgIHRoaXMubmV3Tm9kZShuZXcgX2F0dHJpYnV0ZVtcImRlZmF1bHRcIl0obm9kZSkpO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgfVxuICAvKipcbiAgICogcmV0dXJuIGEgbm9kZSBjb250YWluaW5nIG1lYW5pbmdsZXNzIGdhcmJhZ2UgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgc3BlY2lmaWVkIHRva2VuIHBvc2l0aW9uLlxuICAgKiBpZiB0aGUgdG9rZW4gcG9zaXRpb24gaXMgbmVnYXRpdmUsIGFsbCByZW1haW5pbmcgdG9rZW5zIGFyZSBjb25zdW1lZC5cbiAgICpcbiAgICogVGhpcyByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBzaW5nbGUgc3RyaW5nIG5vZGUgaWYgYWxsIHdoaXRlc3BhY2UsXG4gICAqIG90aGVyd2lzZSBhbiBhcnJheSBvZiBjb21tZW50IG5vZGVzIHdpdGggc3BhY2UgYmVmb3JlIGFuZCBhZnRlci5cbiAgICpcbiAgICogVGhlc2UgdG9rZW5zIGFyZSBub3QgYWRkZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0b3IsIHRoZSBjYWxsZXIgY2FuIGFkZCB0aGVtIG9yIHVzZSB0aGVtIHRvIGFtZW5kXG4gICAqIGEgcHJldmlvdXMgbm9kZSdzIHNwYWNlIG1ldGFkYXRhLlxuICAgKlxuICAgKiBJbiBsb3NzeSBtb2RlLCB0aGlzIHJldHVybnMgb25seSBjb21tZW50cy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VXaGl0ZXNwYWNlRXF1aXZhbGVudFRva2VucyA9IGZ1bmN0aW9uIHBhcnNlV2hpdGVzcGFjZUVxdWl2YWxlbnRUb2tlbnMoc3RvcFBvc2l0aW9uKSB7XG4gICAgaWYgKHN0b3BQb3NpdGlvbiA8IDApIHtcbiAgICAgIHN0b3BQb3NpdGlvbiA9IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIHNwYWNlID0gXCJcIjtcbiAgICB2YXIgbGFzdENvbW1lbnQgPSB1bmRlZmluZWQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoV0hJVEVTUEFDRV9UT0tFTlNbdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXV0pIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubG9zc3kpIHtcbiAgICAgICAgICBzcGFjZSArPSB0aGlzLmNvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuY29tbWVudCkge1xuICAgICAgICB2YXIgc3BhY2VzID0ge307XG5cbiAgICAgICAgaWYgKHNwYWNlKSB7XG4gICAgICAgICAgc3BhY2VzLmJlZm9yZSA9IHNwYWNlO1xuICAgICAgICAgIHNwYWNlID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RDb21tZW50ID0gbmV3IF9jb21tZW50W1wiZGVmYXVsdFwiXSh7XG4gICAgICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuICAgICAgICAgIHNvdXJjZTogZ2V0VG9rZW5Tb3VyY2UodGhpcy5jdXJyVG9rZW4pLFxuICAgICAgICAgIHNvdXJjZUluZGV4OiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10sXG4gICAgICAgICAgc3BhY2VzOiBzcGFjZXNcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzLnB1c2gobGFzdENvbW1lbnQpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCsrdGhpcy5wb3NpdGlvbiA8IHN0b3BQb3NpdGlvbik7XG5cbiAgICBpZiAoc3BhY2UpIHtcbiAgICAgIGlmIChsYXN0Q29tbWVudCkge1xuICAgICAgICBsYXN0Q29tbWVudC5zcGFjZXMuYWZ0ZXIgPSBzcGFjZTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5sb3NzeSkge1xuICAgICAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMudG9rZW5zW3N0YXJ0UG9zaXRpb25dO1xuICAgICAgICB2YXIgbGFzdFRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiAtIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBfc3RyaW5nW1wiZGVmYXVsdFwiXSh7XG4gICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgIHNvdXJjZTogZ2V0U291cmNlKGZpcnN0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9MSU5FXSwgZmlyc3RUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF0sIGxhc3RUb2tlbltfdG9rZW5pemUuRklFTERTLkVORF9MSU5FXSwgbGFzdFRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pLFxuICAgICAgICAgIHNvdXJjZUluZGV4OiBmaXJzdFRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSxcbiAgICAgICAgICBzcGFjZXM6IHtcbiAgICAgICAgICAgIGJlZm9yZTogc3BhY2UsXG4gICAgICAgICAgICBhZnRlcjogJydcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgLyoqXG4gICAqIFxuICAgKiBAcGFyYW0geyp9IG5vZGVzIFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jb252ZXJ0V2hpdGVzcGFjZU5vZGVzVG9TcGFjZSA9IGZ1bmN0aW9uIGNvbnZlcnRXaGl0ZXNwYWNlTm9kZXNUb1NwYWNlKG5vZGVzLCByZXF1aXJlZFNwYWNlKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAocmVxdWlyZWRTcGFjZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXF1aXJlZFNwYWNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNwYWNlID0gXCJcIjtcbiAgICB2YXIgcmF3U3BhY2UgPSBcIlwiO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgIHZhciBzcGFjZUJlZm9yZSA9IF90aGlzMi5sb3NzeVNwYWNlKG4uc3BhY2VzLmJlZm9yZSwgcmVxdWlyZWRTcGFjZSk7XG5cbiAgICAgIHZhciByYXdTcGFjZUJlZm9yZSA9IF90aGlzMi5sb3NzeVNwYWNlKG4ucmF3U3BhY2VCZWZvcmUsIHJlcXVpcmVkU3BhY2UpO1xuXG4gICAgICBzcGFjZSArPSBzcGFjZUJlZm9yZSArIF90aGlzMi5sb3NzeVNwYWNlKG4uc3BhY2VzLmFmdGVyLCByZXF1aXJlZFNwYWNlICYmIHNwYWNlQmVmb3JlLmxlbmd0aCA9PT0gMCk7XG4gICAgICByYXdTcGFjZSArPSBzcGFjZUJlZm9yZSArIG4udmFsdWUgKyBfdGhpczIubG9zc3lTcGFjZShuLnJhd1NwYWNlQWZ0ZXIsIHJlcXVpcmVkU3BhY2UgJiYgcmF3U3BhY2VCZWZvcmUubGVuZ3RoID09PSAwKTtcbiAgICB9KTtcblxuICAgIGlmIChyYXdTcGFjZSA9PT0gc3BhY2UpIHtcbiAgICAgIHJhd1NwYWNlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBzcGFjZTogc3BhY2UsXG4gICAgICByYXdTcGFjZTogcmF3U3BhY2VcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLmlzTmFtZWRDb21iaW5hdG9yID0gZnVuY3Rpb24gaXNOYW1lZENvbWJpbmF0b3IocG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDBdICYmIHRoaXMudG9rZW5zW3Bvc2l0aW9uICsgMF1bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLnNsYXNoICYmIHRoaXMudG9rZW5zW3Bvc2l0aW9uICsgMV0gJiYgdGhpcy50b2tlbnNbcG9zaXRpb24gKyAxXVtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMud29yZCAmJiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDJdICYmIHRoaXMudG9rZW5zW3Bvc2l0aW9uICsgMl1bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLnNsYXNoO1xuICB9O1xuXG4gIF9wcm90by5uYW1lZENvbWJpbmF0b3IgPSBmdW5jdGlvbiBuYW1lZENvbWJpbmF0b3IoKSB7XG4gICAgaWYgKHRoaXMuaXNOYW1lZENvbWJpbmF0b3IoKSkge1xuICAgICAgdmFyIG5hbWVSYXcgPSB0aGlzLmNvbnRlbnQodGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDFdKTtcbiAgICAgIHZhciBuYW1lID0gKDAsIF91dGlsLnVuZXNjKShuYW1lUmF3KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJhd3MgPSB7fTtcblxuICAgICAgaWYgKG5hbWUgIT09IG5hbWVSYXcpIHtcbiAgICAgICAgcmF3cy52YWx1ZSA9IFwiL1wiICsgbmFtZVJhdyArIFwiL1wiO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IG5ldyBfY29tYmluYXRvcltcImRlZmF1bHRcIl0oe1xuICAgICAgICB2YWx1ZTogXCIvXCIgKyBuYW1lICsgXCIvXCIsXG4gICAgICAgIHNvdXJjZTogZ2V0U291cmNlKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfTElORV0sIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfQ09MXSwgdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDJdW190b2tlbml6ZS5GSUVMRFMuRU5EX0xJTkVdLCB0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uICsgMl1bX3Rva2VuaXplLkZJRUxEUy5FTkRfQ09MXSksXG4gICAgICAgIHNvdXJjZUluZGV4OiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10sXG4gICAgICAgIHJhd3M6IHJhd3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gKyAzO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tYmluYXRvciA9IGZ1bmN0aW9uIGNvbWJpbmF0b3IoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5jb250ZW50KCkgPT09ICd8Jykge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlKCk7XG4gICAgfSAvLyBXZSBuZWVkIHRvIGRlY2lkZSBiZXR3ZWVuIGEgc3BhY2UgdGhhdCdzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yIGFuZCBtZWFuaW5nbGVzcyB3aGl0ZXNwYWNlIGF0IHRoZSBlbmQgb2YgYSBzZWxlY3Rvci5cblxuXG4gICAgdmFyIG5leHRTaWdUb2tlblBvcyA9IHRoaXMubG9jYXRlTmV4dE1lYW5pbmdmdWxUb2tlbih0aGlzLnBvc2l0aW9uKTtcblxuICAgIGlmIChuZXh0U2lnVG9rZW5Qb3MgPCAwIHx8IHRoaXMudG9rZW5zW25leHRTaWdUb2tlblBvc11bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNvbW1hKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLnBhcnNlV2hpdGVzcGFjZUVxdWl2YWxlbnRUb2tlbnMobmV4dFNpZ1Rva2VuUG9zKTtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmN1cnJlbnQubGFzdDtcblxuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgIHZhciBfdGhpcyRjb252ZXJ0V2hpdGVzcGEgPSB0aGlzLmNvbnZlcnRXaGl0ZXNwYWNlTm9kZXNUb1NwYWNlKG5vZGVzKSxcbiAgICAgICAgICAgICAgc3BhY2UgPSBfdGhpcyRjb252ZXJ0V2hpdGVzcGEuc3BhY2UsXG4gICAgICAgICAgICAgIHJhd1NwYWNlID0gX3RoaXMkY29udmVydFdoaXRlc3BhLnJhd1NwYWNlO1xuXG4gICAgICAgICAgaWYgKHJhd1NwYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhc3QucmF3U3BhY2VBZnRlciArPSByYXdTcGFjZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYXN0LnNwYWNlcy5hZnRlciArPSBzcGFjZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLm5ld05vZGUobik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5jdXJyVG9rZW47XG4gICAgdmFyIHNwYWNlT3JEZXNjZW5kYW50U2VsZWN0b3JOb2RlcyA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXh0U2lnVG9rZW5Qb3MgPiB0aGlzLnBvc2l0aW9uKSB7XG4gICAgICBzcGFjZU9yRGVzY2VuZGFudFNlbGVjdG9yTm9kZXMgPSB0aGlzLnBhcnNlV2hpdGVzcGFjZUVxdWl2YWxlbnRUb2tlbnMobmV4dFNpZ1Rva2VuUG9zKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZTtcblxuICAgIGlmICh0aGlzLmlzTmFtZWRDb21iaW5hdG9yKCkpIHtcbiAgICAgIG5vZGUgPSB0aGlzLm5hbWVkQ29tYmluYXRvcigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNvbWJpbmF0b3IpIHtcbiAgICAgIG5vZGUgPSBuZXcgX2NvbWJpbmF0b3JbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuICAgICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlKHRoaXMuY3VyclRva2VuKSxcbiAgICAgICAgc291cmNlSW5kZXg6IHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfSBlbHNlIGlmIChXSElURVNQQUNFX1RPS0VOU1t0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdXSkgey8vIHBhc3NcbiAgICB9IGVsc2UgaWYgKCFzcGFjZU9yRGVzY2VuZGFudFNlbGVjdG9yTm9kZXMpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIGlmIChub2RlKSB7XG4gICAgICBpZiAoc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyRjb252ZXJ0V2hpdGVzcGEyID0gdGhpcy5jb252ZXJ0V2hpdGVzcGFjZU5vZGVzVG9TcGFjZShzcGFjZU9yRGVzY2VuZGFudFNlbGVjdG9yTm9kZXMpLFxuICAgICAgICAgICAgX3NwYWNlID0gX3RoaXMkY29udmVydFdoaXRlc3BhMi5zcGFjZSxcbiAgICAgICAgICAgIF9yYXdTcGFjZSA9IF90aGlzJGNvbnZlcnRXaGl0ZXNwYTIucmF3U3BhY2U7XG5cbiAgICAgICAgbm9kZS5zcGFjZXMuYmVmb3JlID0gX3NwYWNlO1xuICAgICAgICBub2RlLnJhd1NwYWNlQmVmb3JlID0gX3Jhd1NwYWNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JcbiAgICAgIHZhciBfdGhpcyRjb252ZXJ0V2hpdGVzcGEzID0gdGhpcy5jb252ZXJ0V2hpdGVzcGFjZU5vZGVzVG9TcGFjZShzcGFjZU9yRGVzY2VuZGFudFNlbGVjdG9yTm9kZXMsIHRydWUpLFxuICAgICAgICAgIF9zcGFjZTIgPSBfdGhpcyRjb252ZXJ0V2hpdGVzcGEzLnNwYWNlLFxuICAgICAgICAgIF9yYXdTcGFjZTIgPSBfdGhpcyRjb252ZXJ0V2hpdGVzcGEzLnJhd1NwYWNlO1xuXG4gICAgICBpZiAoIV9yYXdTcGFjZTIpIHtcbiAgICAgICAgX3Jhd1NwYWNlMiA9IF9zcGFjZTI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGFjZXMgPSB7fTtcbiAgICAgIHZhciByYXdzID0ge1xuICAgICAgICBzcGFjZXM6IHt9XG4gICAgICB9O1xuXG4gICAgICBpZiAoX3NwYWNlMi5lbmRzV2l0aCgnICcpICYmIF9yYXdTcGFjZTIuZW5kc1dpdGgoJyAnKSkge1xuICAgICAgICBzcGFjZXMuYmVmb3JlID0gX3NwYWNlMi5zbGljZSgwLCBfc3BhY2UyLmxlbmd0aCAtIDEpO1xuICAgICAgICByYXdzLnNwYWNlcy5iZWZvcmUgPSBfcmF3U3BhY2UyLnNsaWNlKDAsIF9yYXdTcGFjZTIubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKF9zcGFjZTIuc3RhcnRzV2l0aCgnICcpICYmIF9yYXdTcGFjZTIuc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICAgIHNwYWNlcy5hZnRlciA9IF9zcGFjZTIuc2xpY2UoMSk7XG4gICAgICAgIHJhd3Muc3BhY2VzLmFmdGVyID0gX3Jhd1NwYWNlMi5zbGljZSgxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd3MudmFsdWUgPSBfcmF3U3BhY2UyO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbmV3IF9jb21iaW5hdG9yW1wiZGVmYXVsdFwiXSh7XG4gICAgICAgIHZhbHVlOiAnICcsXG4gICAgICAgIHNvdXJjZTogZ2V0VG9rZW5Tb3VyY2VTcGFuKGZpcnN0VG9rZW4sIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gLSAxXSksXG4gICAgICAgIHNvdXJjZUluZGV4OiBmaXJzdFRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSxcbiAgICAgICAgc3BhY2VzOiBzcGFjZXMsXG4gICAgICAgIHJhd3M6IHJhd3NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmN1cnJUb2tlbiAmJiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuc3BhY2UpIHtcbiAgICAgIG5vZGUuc3BhY2VzLmFmdGVyID0gdGhpcy5vcHRpb25hbFNwYWNlKHRoaXMuY29udGVudCgpKTtcbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5uZXdOb2RlKG5vZGUpO1xuICB9O1xuXG4gIF9wcm90by5jb21tYSA9IGZ1bmN0aW9uIGNvbW1hKCkge1xuICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSB0aGlzLnRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLnJvb3QudHJhaWxpbmdDb21tYSA9IHRydWU7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50Ll9pbmZlckVuZFBvc2l0aW9uKCk7XG5cbiAgICB2YXIgc2VsZWN0b3IgPSBuZXcgX3NlbGVjdG9yW1wiZGVmYXVsdFwiXSh7XG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgc3RhcnQ6IHRva2VuU3RhcnQodGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDFdKVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudC5wYXJlbnQuYXBwZW5kKHNlbGVjdG9yKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICB0aGlzLnBvc2l0aW9uKys7XG4gIH07XG5cbiAgX3Byb3RvLmNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyVG9rZW47XG4gICAgdGhpcy5uZXdOb2RlKG5ldyBfY29tbWVudFtcImRlZmF1bHRcIl0oe1xuICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZShjdXJyZW50KSxcbiAgICAgIHNvdXJjZUluZGV4OiBjdXJyZW50W190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuICAgIH0pKTtcbiAgICB0aGlzLnBvc2l0aW9uKys7XG4gIH07XG5cbiAgX3Byb3RvLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgb3B0cykge1xuICAgIHRocm93IHRoaXMucm9vdC5lcnJvcihtZXNzYWdlLCBvcHRzKTtcbiAgfTtcblxuICBfcHJvdG8ubWlzc2luZ0JhY2tzbGFzaCA9IGZ1bmN0aW9uIG1pc3NpbmdCYWNrc2xhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0V4cGVjdGVkIGEgYmFja3NsYXNoIHByZWNlZGluZyB0aGUgc2VtaWNvbG9uLicsIHtcbiAgICAgIGluZGV4OiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubWlzc2luZ1BhcmVudGhlc2lzID0gZnVuY3Rpb24gbWlzc2luZ1BhcmVudGhlc2lzKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdvcGVuaW5nIHBhcmVudGhlc2lzJywgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcbiAgfTtcblxuICBfcHJvdG8ubWlzc2luZ1NxdWFyZUJyYWNrZXQgPSBmdW5jdGlvbiBtaXNzaW5nU3F1YXJlQnJhY2tldCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnb3BlbmluZyBzcXVhcmUgYnJhY2tldCcsIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSk7XG4gIH07XG5cbiAgX3Byb3RvLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbiB1bmV4cGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCAnXCIgKyB0aGlzLmNvbnRlbnQoKSArIFwiJy4gRXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIHdpdGggXFxcXCBtYXkgaGVscC5cIiwgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcbiAgfTtcblxuICBfcHJvdG8ubmFtZXNwYWNlID0gZnVuY3Rpb24gbmFtZXNwYWNlKCkge1xuICAgIHZhciBiZWZvcmUgPSB0aGlzLnByZXZUb2tlbiAmJiB0aGlzLmNvbnRlbnQodGhpcy5wcmV2VG9rZW4pIHx8IHRydWU7XG5cbiAgICBpZiAodGhpcy5uZXh0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLndvcmQpIHtcbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0aGlzLndvcmQoYmVmb3JlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5hc3Rlcmlzaykge1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgcmV0dXJuIHRoaXMudW5pdmVyc2FsKGJlZm9yZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5uZXN0aW5nID0gZnVuY3Rpb24gbmVzdGluZygpIHtcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4pIHtcbiAgICAgIHZhciBuZXh0Q29udGVudCA9IHRoaXMuY29udGVudCh0aGlzLm5leHRUb2tlbik7XG5cbiAgICAgIGlmIChuZXh0Q29udGVudCA9PT0gXCJ8XCIpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJUb2tlbjtcbiAgICB0aGlzLm5ld05vZGUobmV3IF9uZXN0aW5nW1wiZGVmYXVsdFwiXSh7XG4gICAgICB2YWx1ZTogdGhpcy5jb250ZW50KCksXG4gICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlKGN1cnJlbnQpLFxuICAgICAgc291cmNlSW5kZXg6IGN1cnJlbnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgfSkpO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgfTtcblxuICBfcHJvdG8ucGFyZW50aGVzZXMgPSBmdW5jdGlvbiBwYXJlbnRoZXNlcygpIHtcbiAgICB2YXIgbGFzdCA9IHRoaXMuY3VycmVudC5sYXN0O1xuICAgIHZhciB1bmJhbGFuY2VkID0gMTtcbiAgICB0aGlzLnBvc2l0aW9uKys7XG5cbiAgICBpZiAobGFzdCAmJiBsYXN0LnR5cGUgPT09IHR5cGVzLlBTRVVETykge1xuICAgICAgdmFyIHNlbGVjdG9yID0gbmV3IF9zZWxlY3RvcltcImRlZmF1bHRcIl0oe1xuICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICBzdGFydDogdG9rZW5TdGFydCh0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uIC0gMV0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5jdXJyZW50O1xuICAgICAgbGFzdC5hcHBlbmQoc2VsZWN0b3IpO1xuICAgICAgdGhpcy5jdXJyZW50ID0gc2VsZWN0b3I7XG5cbiAgICAgIHdoaWxlICh0aGlzLnBvc2l0aW9uIDwgdGhpcy50b2tlbnMubGVuZ3RoICYmIHVuYmFsYW5jZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5vcGVuUGFyZW50aGVzaXMpIHtcbiAgICAgICAgICB1bmJhbGFuY2VkKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNsb3NlUGFyZW50aGVzaXMpIHtcbiAgICAgICAgICB1bmJhbGFuY2VkLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5iYWxhbmNlZCkge1xuICAgICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc291cmNlLmVuZCA9IHRva2VuRW5kKHRoaXMuY3VyclRva2VuKTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQucGFyZW50LnNvdXJjZS5lbmQgPSB0b2tlbkVuZCh0aGlzLmN1cnJUb2tlbik7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudCA9IGNhY2hlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJIHRoaW5rIHRoaXMgY2FzZSBzaG91bGQgYmUgYW4gZXJyb3IuIEl0J3MgdXNlZCB0byBpbXBsZW1lbnQgYSBiYXNpYyBwYXJzZSBvZiBtZWRpYSBxdWVyaWVzXG4gICAgICAvLyBidXQgSSBkb24ndCB0aGluayBpdCdzIGEgZ29vZCBpZGVhLlxuICAgICAgdmFyIHBhcmVuU3RhcnQgPSB0aGlzLmN1cnJUb2tlbjtcbiAgICAgIHZhciBwYXJlblZhbHVlID0gXCIoXCI7XG4gICAgICB2YXIgcGFyZW5FbmQ7XG5cbiAgICAgIHdoaWxlICh0aGlzLnBvc2l0aW9uIDwgdGhpcy50b2tlbnMubGVuZ3RoICYmIHVuYmFsYW5jZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5vcGVuUGFyZW50aGVzaXMpIHtcbiAgICAgICAgICB1bmJhbGFuY2VkKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNsb3NlUGFyZW50aGVzaXMpIHtcbiAgICAgICAgICB1bmJhbGFuY2VkLS07XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbkVuZCA9IHRoaXMuY3VyclRva2VuO1xuICAgICAgICBwYXJlblZhbHVlICs9IHRoaXMucGFyc2VQYXJlbnRoZXNpc1Rva2VuKHRoaXMuY3VyclRva2VuKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdCkge1xuICAgICAgICBsYXN0LmFwcGVuZFRvUHJvcGVydHlBbmRFc2NhcGUoXCJ2YWx1ZVwiLCBwYXJlblZhbHVlLCBwYXJlblZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmV3Tm9kZShuZXcgX3N0cmluZ1tcImRlZmF1bHRcIl0oe1xuICAgICAgICAgIHZhbHVlOiBwYXJlblZhbHVlLFxuICAgICAgICAgIHNvdXJjZTogZ2V0U291cmNlKHBhcmVuU3RhcnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9MSU5FXSwgcGFyZW5TdGFydFtfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF0sIHBhcmVuRW5kW190b2tlbml6ZS5GSUVMRFMuRU5EX0xJTkVdLCBwYXJlbkVuZFtfdG9rZW5pemUuRklFTERTLkVORF9DT0xdKSxcbiAgICAgICAgICBzb3VyY2VJbmRleDogcGFyZW5TdGFydFtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1bmJhbGFuY2VkKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnY2xvc2luZyBwYXJlbnRoZXNpcycsIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wc2V1ZG8gPSBmdW5jdGlvbiBwc2V1ZG8oKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgcHNldWRvU3RyID0gJyc7XG4gICAgdmFyIHN0YXJ0aW5nVG9rZW4gPSB0aGlzLmN1cnJUb2tlbjtcblxuICAgIHdoaWxlICh0aGlzLmN1cnJUb2tlbiAmJiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuY29sb24pIHtcbiAgICAgIHBzZXVkb1N0ciArPSB0aGlzLmNvbnRlbnQoKTtcbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY3VyclRva2VuKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBlY3RlZChbJ3BzZXVkby1jbGFzcycsICdwc2V1ZG8tZWxlbWVudCddLCB0aGlzLnBvc2l0aW9uIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy53b3JkKSB7XG4gICAgICB0aGlzLnNwbGl0V29yZChmYWxzZSwgZnVuY3Rpb24gKGZpcnN0LCBsZW5ndGgpIHtcbiAgICAgICAgcHNldWRvU3RyICs9IGZpcnN0O1xuXG4gICAgICAgIF90aGlzNC5uZXdOb2RlKG5ldyBfcHNldWRvW1wiZGVmYXVsdFwiXSh7XG4gICAgICAgICAgdmFsdWU6IHBzZXVkb1N0cixcbiAgICAgICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlU3BhbihzdGFydGluZ1Rva2VuLCBfdGhpczQuY3VyclRva2VuKSxcbiAgICAgICAgICBzb3VyY2VJbmRleDogc3RhcnRpbmdUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPiAxICYmIF90aGlzNC5uZXh0VG9rZW4gJiYgX3RoaXM0Lm5leHRUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMub3BlblBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgX3RoaXM0LmVycm9yKCdNaXNwbGFjZWQgcGFyZW50aGVzaXMuJywge1xuICAgICAgICAgICAgaW5kZXg6IF90aGlzNC5uZXh0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBlY3RlZChbJ3BzZXVkby1jbGFzcycsICdwc2V1ZG8tZWxlbWVudCddLCB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc3BhY2UgPSBmdW5jdGlvbiBzcGFjZSgpIHtcbiAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudCgpOyAvLyBIYW5kbGUgc3BhY2UgYmVmb3JlIGFuZCBhZnRlciB0aGUgc2VsZWN0b3JcblxuICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAwIHx8IHRoaXMucHJldlRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21tYSB8fCB0aGlzLnByZXZUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMub3BlblBhcmVudGhlc2lzIHx8IHRoaXMuY3VycmVudC5ub2Rlcy5ldmVyeShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2NvbW1lbnQnO1xuICAgIH0pKSB7XG4gICAgICB0aGlzLnNwYWNlcyA9IHRoaXMub3B0aW9uYWxTcGFjZShjb250ZW50KTtcbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zaXRpb24gPT09IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEgfHwgdGhpcy5uZXh0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNvbW1hIHx8IHRoaXMubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jbG9zZVBhcmVudGhlc2lzKSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGFzdC5zcGFjZXMuYWZ0ZXIgPSB0aGlzLm9wdGlvbmFsU3BhY2UoY29udGVudCk7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tYmluYXRvcigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc3RyaW5nID0gZnVuY3Rpb24gc3RyaW5nKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyVG9rZW47XG4gICAgdGhpcy5uZXdOb2RlKG5ldyBfc3RyaW5nW1wiZGVmYXVsdFwiXSh7XG4gICAgICB2YWx1ZTogdGhpcy5jb250ZW50KCksXG4gICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlKGN1cnJlbnQpLFxuICAgICAgc291cmNlSW5kZXg6IGN1cnJlbnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG4gICAgfSkpO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgfTtcblxuICBfcHJvdG8udW5pdmVyc2FsID0gZnVuY3Rpb24gdW5pdmVyc2FsKG5hbWVzcGFjZSkge1xuICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcblxuICAgIGlmIChuZXh0VG9rZW4gJiYgdGhpcy5jb250ZW50KG5leHRUb2tlbikgPT09ICd8Jykge1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlKCk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJUb2tlbjtcbiAgICB0aGlzLm5ld05vZGUobmV3IF91bml2ZXJzYWxbXCJkZWZhdWx0XCJdKHtcbiAgICAgIHZhbHVlOiB0aGlzLmNvbnRlbnQoKSxcbiAgICAgIHNvdXJjZTogZ2V0VG9rZW5Tb3VyY2UoY3VycmVudCksXG4gICAgICBzb3VyY2VJbmRleDogY3VycmVudFtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cbiAgICB9KSwgbmFtZXNwYWNlKTtcbiAgICB0aGlzLnBvc2l0aW9uKys7XG4gIH07XG5cbiAgX3Byb3RvLnNwbGl0V29yZCA9IGZ1bmN0aW9uIHNwbGl0V29yZChuYW1lc3BhY2UsIGZpcnN0Q2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgd29yZCA9IHRoaXMuY29udGVudCgpO1xuXG4gICAgd2hpbGUgKG5leHRUb2tlbiAmJiB+W3Rva2Vucy5kb2xsYXIsIHRva2Vucy5jYXJldCwgdG9rZW5zLmVxdWFscywgdG9rZW5zLndvcmRdLmluZGV4T2YobmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0pKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY29udGVudCgpO1xuICAgICAgd29yZCArPSBjdXJyZW50O1xuXG4gICAgICBpZiAoY3VycmVudC5sYXN0SW5kZXhPZignXFxcXCcpID09PSBjdXJyZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHRUb2tlbjtcblxuICAgICAgICBpZiAobmV4dCAmJiBuZXh0W190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5zcGFjZSkge1xuICAgICAgICAgIHdvcmQgKz0gdGhpcy5yZXF1aXJlZFNwYWNlKHRoaXMuY29udGVudChuZXh0KSk7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgIH1cblxuICAgIHZhciBoYXNDbGFzcyA9IGluZGV4ZXNPZih3b3JkLCAnLicpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgLy8gQWxsb3cgZXNjYXBlZCBkb3Qgd2l0aGluIGNsYXNzIG5hbWVcbiAgICAgIHZhciBlc2NhcGVkRG90ID0gd29yZFtpIC0gMV0gPT09ICdcXFxcJzsgLy8gQWxsb3cgZGVjaW1hbCBudW1iZXJzIHBlcmNlbnQgaW4gQGtleWZyYW1lc1xuXG4gICAgICB2YXIgaXNLZXlmcmFtZXNQZXJjZW50ID0gL15cXGQrXFwuXFxkKyUkLy50ZXN0KHdvcmQpO1xuICAgICAgcmV0dXJuICFlc2NhcGVkRG90ICYmICFpc0tleWZyYW1lc1BlcmNlbnQ7XG4gICAgfSk7XG4gICAgdmFyIGhhc0lkID0gaW5kZXhlc09mKHdvcmQsICcjJykuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gd29yZFtpIC0gMV0gIT09ICdcXFxcJztcbiAgICB9KTsgLy8gRWxpbWluYXRlIFNhc3MgaW50ZXJwb2xhdGlvbnMgZnJvbSB0aGUgbGlzdCBvZiBpZCBpbmRleGVzXG5cbiAgICB2YXIgaW50ZXJwb2xhdGlvbnMgPSBpbmRleGVzT2Yod29yZCwgJyN7Jyk7XG5cbiAgICBpZiAoaW50ZXJwb2xhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBoYXNJZCA9IGhhc0lkLmZpbHRlcihmdW5jdGlvbiAoaGFzaEluZGV4KSB7XG4gICAgICAgIHJldHVybiAhfmludGVycG9sYXRpb25zLmluZGV4T2YoaGFzaEluZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpbmRpY2VzID0gKDAsIF9zb3J0QXNjZW5kaW5nW1wiZGVmYXVsdFwiXSkodW5pcXMoWzBdLmNvbmNhdChoYXNDbGFzcywgaGFzSWQpKSk7XG4gICAgaW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmQsIGkpIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGljZXNbaSArIDFdIHx8IHdvcmQubGVuZ3RoO1xuICAgICAgdmFyIHZhbHVlID0gd29yZC5zbGljZShpbmQsIGluZGV4KTtcblxuICAgICAgaWYgKGkgPT09IDAgJiYgZmlyc3RDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZmlyc3RDYWxsYmFjay5jYWxsKF90aGlzNSwgdmFsdWUsIGluZGljZXMubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGU7XG4gICAgICB2YXIgY3VycmVudCA9IF90aGlzNS5jdXJyVG9rZW47XG4gICAgICB2YXIgc291cmNlSW5kZXggPSBjdXJyZW50W190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSArIGluZGljZXNbaV07XG4gICAgICB2YXIgc291cmNlID0gZ2V0U291cmNlKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0gKyBpbmQsIGN1cnJlbnRbM10sIGN1cnJlbnRbMl0gKyAoaW5kZXggLSAxKSk7XG5cbiAgICAgIGlmICh+aGFzQ2xhc3MuaW5kZXhPZihpbmQpKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWVPcHRzID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZSgxKSxcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBzb3VyY2VJbmRleDogc291cmNlSW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgbm9kZSA9IG5ldyBfY2xhc3NOYW1lW1wiZGVmYXVsdFwiXSh1bmVzY2FwZVByb3AoY2xhc3NOYW1lT3B0cywgXCJ2YWx1ZVwiKSk7XG4gICAgICB9IGVsc2UgaWYgKH5oYXNJZC5pbmRleE9mKGluZCkpIHtcbiAgICAgICAgdmFyIGlkT3B0cyA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUuc2xpY2UoMSksXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgc291cmNlSW5kZXg6IHNvdXJjZUluZGV4XG4gICAgICAgIH07XG4gICAgICAgIG5vZGUgPSBuZXcgX2lkW1wiZGVmYXVsdFwiXSh1bmVzY2FwZVByb3AoaWRPcHRzLCBcInZhbHVlXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWdPcHRzID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBzb3VyY2VJbmRleDogc291cmNlSW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgdW5lc2NhcGVQcm9wKHRhZ09wdHMsIFwidmFsdWVcIik7XG4gICAgICAgIG5vZGUgPSBuZXcgX3RhZ1tcImRlZmF1bHRcIl0odGFnT3B0cyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzNS5uZXdOb2RlKG5vZGUsIG5hbWVzcGFjZSk7IC8vIEVuc3VyZSB0aGF0IHRoZSBuYW1lc3BhY2UgaXMgdXNlZCBvbmx5IG9uY2VcblxuXG4gICAgICBuYW1lc3BhY2UgPSBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgfTtcblxuICBfcHJvdG8ud29yZCA9IGZ1bmN0aW9uIHdvcmQobmFtZXNwYWNlKSB7XG4gICAgdmFyIG5leHRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuXG4gICAgaWYgKG5leHRUb2tlbiAmJiB0aGlzLmNvbnRlbnQobmV4dFRva2VuKSA9PT0gJ3wnKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGxpdFdvcmQobmFtZXNwYWNlKTtcbiAgfTtcblxuICBfcHJvdG8ubG9vcCA9IGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgd2hpbGUgKHRoaXMucG9zaXRpb24gPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucGFyc2UodHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50Ll9pbmZlckVuZFBvc2l0aW9uKCk7XG5cbiAgICByZXR1cm4gdGhpcy5yb290O1xuICB9O1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRocm93T25QYXJlbnRoZXNpcykge1xuICAgIHN3aXRjaCAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSkge1xuICAgICAgY2FzZSB0b2tlbnMuc3BhY2U6XG4gICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdG9rZW5zLmNvbW1lbnQ6XG4gICAgICAgIHRoaXMuY29tbWVudCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0b2tlbnMub3BlblBhcmVudGhlc2lzOlxuICAgICAgICB0aGlzLnBhcmVudGhlc2VzKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRva2Vucy5jbG9zZVBhcmVudGhlc2lzOlxuICAgICAgICBpZiAodGhyb3dPblBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgdGhpcy5taXNzaW5nUGFyZW50aGVzaXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRva2Vucy5vcGVuU3F1YXJlOlxuICAgICAgICB0aGlzLmF0dHJpYnV0ZSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0b2tlbnMuZG9sbGFyOlxuICAgICAgY2FzZSB0b2tlbnMuY2FyZXQ6XG4gICAgICBjYXNlIHRva2Vucy5lcXVhbHM6XG4gICAgICBjYXNlIHRva2Vucy53b3JkOlxuICAgICAgICB0aGlzLndvcmQoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdG9rZW5zLmNvbG9uOlxuICAgICAgICB0aGlzLnBzZXVkbygpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0b2tlbnMuY29tbWE6XG4gICAgICAgIHRoaXMuY29tbWEoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdG9rZW5zLmFzdGVyaXNrOlxuICAgICAgICB0aGlzLnVuaXZlcnNhbCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0b2tlbnMuYW1wZXJzYW5kOlxuICAgICAgICB0aGlzLm5lc3RpbmcoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdG9rZW5zLnNsYXNoOlxuICAgICAgY2FzZSB0b2tlbnMuY29tYmluYXRvcjpcbiAgICAgICAgdGhpcy5jb21iaW5hdG9yKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRva2Vucy5zdHI6XG4gICAgICAgIHRoaXMuc3RyaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gVGhlc2UgY2FzZXMgdGhyb3c7IG5vIGJyZWFrIG5lZWRlZC5cblxuICAgICAgY2FzZSB0b2tlbnMuY2xvc2VTcXVhcmU6XG4gICAgICAgIHRoaXMubWlzc2luZ1NxdWFyZUJyYWNrZXQoKTtcblxuICAgICAgY2FzZSB0b2tlbnMuc2VtaWNvbG9uOlxuICAgICAgICB0aGlzLm1pc3NpbmdCYWNrc2xhc2goKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmV4cGVjdGVkID0gZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24sIGluZGV4LCBmb3VuZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc2NyaXB0aW9uKSkge1xuICAgICAgdmFyIGxhc3QgPSBkZXNjcmlwdGlvbi5wb3AoKTtcbiAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24uam9pbignLCAnKSArIFwiIG9yIFwiICsgbGFzdDtcbiAgICB9XG5cbiAgICB2YXIgYW4gPSAvXlthZWlvdV0vLnRlc3QoZGVzY3JpcHRpb25bMF0pID8gJ2FuJyA6ICdhJztcblxuICAgIGlmICghZm91bmQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBhbiArIFwiIFwiICsgZGVzY3JpcHRpb24gKyBcIi5cIiwge1xuICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBhbiArIFwiIFwiICsgZGVzY3JpcHRpb24gKyBcIiwgZm91bmQgXFxcIlwiICsgZm91bmQgKyBcIlxcXCIgaW5zdGVhZC5cIiwge1xuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcXVpcmVkU3BhY2UgPSBmdW5jdGlvbiByZXF1aXJlZFNwYWNlKHNwYWNlKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sb3NzeSA/ICcgJyA6IHNwYWNlO1xuICB9O1xuXG4gIF9wcm90by5vcHRpb25hbFNwYWNlID0gZnVuY3Rpb24gb3B0aW9uYWxTcGFjZShzcGFjZSkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubG9zc3kgPyAnJyA6IHNwYWNlO1xuICB9O1xuXG4gIF9wcm90by5sb3NzeVNwYWNlID0gZnVuY3Rpb24gbG9zc3lTcGFjZShzcGFjZSwgcmVxdWlyZWQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvc3N5KSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWQgPyAnICcgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNwYWNlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGFyc2VQYXJlbnRoZXNpc1Rva2VuID0gZnVuY3Rpb24gcGFyc2VQYXJlbnRoZXNpc1Rva2VuKHRva2VuKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQodG9rZW4pO1xuXG4gICAgaWYgKHRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5zcGFjZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZWRTcGFjZShjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5uZXdOb2RlID0gZnVuY3Rpb24gbmV3Tm9kZShub2RlLCBuYW1lc3BhY2UpIHtcbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICBpZiAoL14gKyQvLnRlc3QobmFtZXNwYWNlKSkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sb3NzeSkge1xuICAgICAgICAgIHRoaXMuc3BhY2VzID0gKHRoaXMuc3BhY2VzIHx8ICcnKSArIG5hbWVzcGFjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVzcGFjZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgdW5lc2NhcGVQcm9wKG5vZGUsIFwibmFtZXNwYWNlXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNwYWNlcykge1xuICAgICAgbm9kZS5zcGFjZXMuYmVmb3JlID0gdGhpcy5zcGFjZXM7XG4gICAgICB0aGlzLnNwYWNlcyA9ICcnO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmN1cnJlbnQuYXBwZW5kKG5vZGUpO1xuICB9O1xuXG4gIF9wcm90by5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCh0b2tlbikge1xuICAgIGlmICh0b2tlbiA9PT0gdm9pZCAwKSB7XG4gICAgICB0b2tlbiA9IHRoaXMuY3VyclRva2VuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNzcy5zbGljZSh0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10sIHRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX1BPU10pO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBub24td2hpdGVzcGFjZSwgbm9uLWNvbW1lbnQgdG9rZW4uXG4gICAqIHJldHVybnMgLTEgaWYgbm8gbWVhbmluZ2Z1bCB0b2tlbiBpcyBmb3VuZC5cbiAgICovXG4gIF9wcm90by5sb2NhdGVOZXh0TWVhbmluZ2Z1bFRva2VuID0gZnVuY3Rpb24gbG9jYXRlTmV4dE1lYW5pbmdmdWxUb2tlbihzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gKyAxO1xuICAgIH1cblxuICAgIHZhciBzZWFyY2hQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG5cbiAgICB3aGlsZSAoc2VhcmNoUG9zaXRpb24gPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGlmIChXSElURVNQQUNFX0VRVUlWX1RPS0VOU1t0aGlzLnRva2Vuc1tzZWFyY2hQb3NpdGlvbl1bX3Rva2VuaXplLkZJRUxEUy5UWVBFXV0pIHtcbiAgICAgICAgc2VhcmNoUG9zaXRpb24rKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VhcmNoUG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhQYXJzZXIsIFt7XG4gICAga2V5OiBcImN1cnJUb2tlblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb25dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXh0VG9rZW5cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uICsgMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXZUb2tlblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gLSAxXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFyc2VyO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBhcnNlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcGFyc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZXJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFByb2Nlc3NvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb2Nlc3NvcihmdW5jLCBvcHRpb25zKSB7XG4gICAgdGhpcy5mdW5jID0gZnVuYyB8fCBmdW5jdGlvbiBub29wKCkge307XG5cbiAgICB0aGlzLmZ1bmNSZXMgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUHJvY2Vzc29yLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3Nob3VsZFVwZGF0ZVNlbGVjdG9yID0gZnVuY3Rpb24gX3Nob3VsZFVwZGF0ZVNlbGVjdG9yKHJ1bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAobWVyZ2VkLnVwZGF0ZVNlbGVjdG9yID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHJ1bGUgIT09IFwic3RyaW5nXCI7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5faXNMb3NzeSA9IGZ1bmN0aW9uIF9pc0xvc3N5KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAobWVyZ2VkLmxvc3NsZXNzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9yb290ID0gZnVuY3Rpb24gX3Jvb3QocnVsZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VyID0gbmV3IF9wYXJzZXJbXCJkZWZhdWx0XCJdKHJ1bGUsIHRoaXMuX3BhcnNlT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgcmV0dXJuIHBhcnNlci5yb290O1xuICB9O1xuXG4gIF9wcm90by5fcGFyc2VPcHRpb25zID0gZnVuY3Rpb24gX3BhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvc3N5OiB0aGlzLl9pc0xvc3N5KG9wdGlvbnMpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uX3J1biA9IGZ1bmN0aW9uIF9ydW4ocnVsZSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByb290ID0gX3RoaXMuX3Jvb3QocnVsZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKF90aGlzLmZ1bmMocm9vdCkpLnRoZW4oZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgICAgIHZhciBzdHJpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuX3Nob3VsZFVwZGF0ZVNlbGVjdG9yKHJ1bGUsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSByb290LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBydWxlLnNlbGVjdG9yID0gc3RyaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9ydW5TeW5jID0gZnVuY3Rpb24gX3J1blN5bmMocnVsZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QocnVsZSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5mdW5jKHJvb3QpO1xuXG4gICAgaWYgKHRyYW5zZm9ybSAmJiB0eXBlb2YgdHJhbnNmb3JtLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0b3IgcHJvY2Vzc29yIHJldHVybmVkIGEgcHJvbWlzZSB0byBhIHN5bmNocm9ub3VzIGNhbGwuXCIpO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAob3B0aW9ucy51cGRhdGVTZWxlY3RvciAmJiB0eXBlb2YgcnVsZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgc3RyaW5nID0gcm9vdC50b1N0cmluZygpO1xuICAgICAgcnVsZS5zZWxlY3RvciA9IHN0cmluZztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICByb290OiByb290LFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIHJ1bGUgaW50byBhIHNlbGVjdG9yIEFTVC5cbiAgICpcbiAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHByb2Nlc3NpbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8cGFyc2VyLlJvb3Q+fSBUaGUgQVNUIG9mIHRoZSBzZWxlY3RvciBhZnRlciBwcm9jZXNzaW5nIGl0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hc3QgPSBmdW5jdGlvbiBhc3QocnVsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9ydW4ocnVsZSwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnJvb3Q7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcnVsZSBpbnRvIGEgc2VsZWN0b3IgQVNUIHN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIEBwYXJhbSBydWxlIHtwb3N0Y3NzLlJ1bGUgfCBzdHJpbmd9IFRoZSBjc3Mgc2VsZWN0b3IgdG8gYmUgcHJvY2Vzc2VkXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBwcm9jZXNzaW5nXG4gICAqIEByZXR1cm5zIHtwYXJzZXIuUm9vdH0gVGhlIEFTVCBvZiB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZyBpdC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYXN0U3luYyA9IGZ1bmN0aW9uIGFzdFN5bmMocnVsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9ydW5TeW5jKHJ1bGUsIG9wdGlvbnMpLnJvb3Q7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBzZWxlY3RvciBpbnRvIGEgdHJhbnNmb3JtZWQgdmFsdWUgYXN5bmNocm9ub3VzbHlcbiAgICpcbiAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHByb2Nlc3NpbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBwcm9jZXNzb3IuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybShydWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bihydWxlLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQudHJhbnNmb3JtO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIGEgc2VsZWN0b3IgaW50byBhIHRyYW5zZm9ybWVkIHZhbHVlIHN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIEBwYXJhbSBydWxlIHtwb3N0Y3NzLlJ1bGUgfCBzdHJpbmd9IFRoZSBjc3Mgc2VsZWN0b3IgdG8gYmUgcHJvY2Vzc2VkXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBwcm9jZXNzaW5nXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgcHJvY2Vzc29yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50cmFuc2Zvcm1TeW5jID0gZnVuY3Rpb24gdHJhbnNmb3JtU3luYyhydWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1blN5bmMocnVsZSwgb3B0aW9ucykudHJhbnNmb3JtO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIGEgc2VsZWN0b3IgaW50byBhIG5ldyBzZWxlY3RvciBzdHJpbmcgYXN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIEBwYXJhbSBydWxlIHtwb3N0Y3NzLlJ1bGUgfCBzdHJpbmd9IFRoZSBjc3Mgc2VsZWN0b3IgdG8gYmUgcHJvY2Vzc2VkXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBwcm9jZXNzaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBzZWxlY3RvciBhZnRlciBwcm9jZXNzaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhydWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bihydWxlLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuc3RyaW5nIHx8IHJlc3VsdC5yb290LnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBzZWxlY3RvciBpbnRvIGEgbmV3IHNlbGVjdG9yIHN0cmluZyBzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gcnVsZSB7cG9zdGNzcy5SdWxlIHwgc3RyaW5nfSBUaGUgY3NzIHNlbGVjdG9yIHRvIGJlIHByb2Nlc3NlZFxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHJvY2Vzc1N5bmMgPSBmdW5jdGlvbiBwcm9jZXNzU3luYyhydWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX3J1blN5bmMocnVsZSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnN0cmluZyB8fCByZXN1bHQucm9vdC50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBQcm9jZXNzb3I7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUHJvY2Vzc29yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuZXNjYXBlVmFsdWUgPSB1bmVzY2FwZVZhbHVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY3NzZXNjID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY3NzZXNjXCIpKTtcblxudmFyIF91bmVzYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWwvdW5lc2NcIikpO1xuXG52YXIgX25hbWVzcGFjZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG52YXIgX0NTU0VTQ19RVU9URV9PUFRJT05TO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoXCJ1dGlsLWRlcHJlY2F0ZVwiKTtcblxudmFyIFdSQVBQRURfSU5fUVVPVEVTID0gL14oJ3xcIikoW15dKilcXDEkLztcbnZhciB3YXJuT2ZEZXByZWNhdGVkVmFsdWVBc3NpZ25tZW50ID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHt9LCBcIkFzc2lnbmluZyBhbiBhdHRyaWJ1dGUgYSB2YWx1ZSBjb250YWluaW5nIGNoYXJhY3RlcnMgdGhhdCBtaWdodCBuZWVkIHRvIGJlIGVzY2FwZWQgaXMgZGVwcmVjYXRlZC4gXCIgKyBcIkNhbGwgYXR0cmlidXRlLnNldFZhbHVlKCkgaW5zdGVhZC5cIik7XG52YXIgd2Fybk9mRGVwcmVjYXRlZFF1b3RlZEFzc2lnbm1lbnQgPSBkZXByZWNhdGUoZnVuY3Rpb24gKCkge30sIFwiQXNzaWduaW5nIGF0dHIucXVvdGVkIGlzIGRlcHJlY2F0ZWQgYW5kIGhhcyBubyBlZmZlY3QuIEFzc2lnbiB0byBhdHRyLnF1b3RlTWFyayBpbnN0ZWFkLlwiKTtcbnZhciB3YXJuT2ZEZXByZWNhdGVkQ29uc3RydWN0b3IgPSBkZXByZWNhdGUoZnVuY3Rpb24gKCkge30sIFwiQ29uc3RydWN0aW5nIGFuIEF0dHJpYnV0ZSBzZWxlY3RvciB3aXRoIGEgdmFsdWUgd2l0aG91dCBzcGVjaWZ5aW5nIHF1b3RlTWFyayBpcyBkZXByZWNhdGVkLiBOb3RlOiBUaGUgdmFsdWUgc2hvdWxkIGJlIHVuZXNjYXBlZCBub3cuXCIpO1xuXG5mdW5jdGlvbiB1bmVzY2FwZVZhbHVlKHZhbHVlKSB7XG4gIHZhciBkZXByZWNhdGVkVXNhZ2UgPSBmYWxzZTtcbiAgdmFyIHF1b3RlTWFyayA9IG51bGw7XG4gIHZhciB1bmVzY2FwZWQgPSB2YWx1ZTtcbiAgdmFyIG0gPSB1bmVzY2FwZWQubWF0Y2goV1JBUFBFRF9JTl9RVU9URVMpO1xuXG4gIGlmIChtKSB7XG4gICAgcXVvdGVNYXJrID0gbVsxXTtcbiAgICB1bmVzY2FwZWQgPSBtWzJdO1xuICB9XG5cbiAgdW5lc2NhcGVkID0gKDAsIF91bmVzY1tcImRlZmF1bHRcIl0pKHVuZXNjYXBlZCk7XG5cbiAgaWYgKHVuZXNjYXBlZCAhPT0gdmFsdWUpIHtcbiAgICBkZXByZWNhdGVkVXNhZ2UgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkZXByZWNhdGVkVXNhZ2U6IGRlcHJlY2F0ZWRVc2FnZSxcbiAgICB1bmVzY2FwZWQ6IHVuZXNjYXBlZCxcbiAgICBxdW90ZU1hcms6IHF1b3RlTWFya1xuICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVEZXByZWNhdGVkQ29udHJ1Y3Rvck9wdHMob3B0cykge1xuICBpZiAob3B0cy5xdW90ZU1hcmsgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvcHRzO1xuICB9XG5cbiAgaWYgKG9wdHMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvcHRzO1xuICB9XG5cbiAgd2Fybk9mRGVwcmVjYXRlZENvbnN0cnVjdG9yKCk7XG5cbiAgdmFyIF91bmVzY2FwZVZhbHVlID0gdW5lc2NhcGVWYWx1ZShvcHRzLnZhbHVlKSxcbiAgICAgIHF1b3RlTWFyayA9IF91bmVzY2FwZVZhbHVlLnF1b3RlTWFyayxcbiAgICAgIHVuZXNjYXBlZCA9IF91bmVzY2FwZVZhbHVlLnVuZXNjYXBlZDtcblxuICBpZiAoIW9wdHMucmF3cykge1xuICAgIG9wdHMucmF3cyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdHMucmF3cy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cy5yYXdzLnZhbHVlID0gb3B0cy52YWx1ZTtcbiAgfVxuXG4gIG9wdHMudmFsdWUgPSB1bmVzY2FwZWQ7XG4gIG9wdHMucXVvdGVNYXJrID0gcXVvdGVNYXJrO1xuICByZXR1cm4gb3B0cztcbn1cblxudmFyIEF0dHJpYnV0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05hbWVzcGFjZSkge1xuICBfaW5oZXJpdHNMb29zZShBdHRyaWJ1dGUsIF9OYW1lc3BhY2UpO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZShvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX05hbWVzcGFjZS5jYWxsKHRoaXMsIGhhbmRsZURlcHJlY2F0ZWRDb250cnVjdG9yT3B0cyhvcHRzKSkgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gX3R5cGVzLkFUVFJJQlVURTtcbiAgICBfdGhpcy5yYXdzID0gX3RoaXMucmF3cyB8fCB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMucmF3cywgJ3VucXVvdGVkJywge1xuICAgICAgZ2V0OiBkZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudmFsdWU7XG4gICAgICB9LCBcImF0dHIucmF3cy51bnF1b3RlZCBpcyBkZXByZWNhdGVkLiBDYWxsIGF0dHIudmFsdWUgaW5zdGVhZC5cIiksXG4gICAgICBzZXQ6IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy52YWx1ZTtcbiAgICAgIH0sIFwiU2V0dGluZyBhdHRyLnJhd3MudW5xdW90ZWQgaXMgZGVwcmVjYXRlZCBhbmQgaGFzIG5vIGVmZmVjdC4gYXR0ci52YWx1ZSBpcyB1bmVzY2FwZWQgYnkgZGVmYXVsdCBub3cuXCIpXG4gICAgfSk7XG4gICAgX3RoaXMuX2NvbnN0cnVjdGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEF0dHJpYnV0ZSdzIHZhbHVlIHF1b3RlZCBzdWNoIHRoYXQgaXQgd291bGQgYmUgbGVnYWwgdG8gdXNlXG4gICAqIGluIHRoZSB2YWx1ZSBvZiBhIGNzcyBmaWxlLiBUaGUgb3JpZ2luYWwgdmFsdWUncyBxdW90YXRpb24gc2V0dGluZ1xuICAgKiB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gaXMgbGVmdCB1bmNoYW5nZWQuIFNlZSBgc2V0VmFsdWUodmFsdWUsIG9wdGlvbnMpYFxuICAgKiBpZiB5b3Ugd2FudCB0byBjb250cm9sIHRoZSBxdW90ZSBzZXR0aW5ncyBvZiBhIG5ldyB2YWx1ZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIGNoYW5nZSB0aGUgcXVvdGF0aW9uIHVzZWQgZm9yIHRoZSBjdXJyZW50IHZhbHVlIGJ5IHNldHRpbmcgcXVvdGVNYXJrLlxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKiAgICogcXVvdGVNYXJrIHsnXCInIHwgXCInXCIgfCBudWxsfSAtIFVzZSB0aGlzIHZhbHVlIHRvIHF1b3RlIHRoZSB2YWx1ZS4gSWYgdGhpc1xuICAgKiAgICAgb3B0aW9uIGlzIG5vdCBzZXQsIHRoZSBvcmlnaW5hbCB2YWx1ZSBmb3IgcXVvdGVNYXJrIHdpbGwgYmUgdXNlZC4gSWZcbiAgICogICAgIGluZGV0ZXJtaW5hdGUsIGEgZG91YmxlIHF1b3RlIGlzIHVzZWQuIFRoZSBsZWdhbCB2YWx1ZXMgYXJlOlxuICAgKiAgICAgKiBgbnVsbGAgLSB0aGUgdmFsdWUgd2lsbCBiZSB1bnF1b3RlZCBhbmQgY2hhcmFjdGVycyB3aWxsIGJlIGVzY2FwZWQgYXMgbmVjZXNzYXJ5LlxuICAgKiAgICAgKiBgJ2AgLSB0aGUgdmFsdWUgd2lsbCBiZSBxdW90ZWQgd2l0aCBhIHNpbmdsZSBxdW90ZSBhbmQgc2luZ2xlIHF1b3RlcyBhcmUgZXNjYXBlZC5cbiAgICogICAgICogYFwiYCAtIHRoZSB2YWx1ZSB3aWxsIGJlIHF1b3RlZCB3aXRoIGEgZG91YmxlIHF1b3RlIGFuZCBkb3VibGUgcXVvdGVzIGFyZSBlc2NhcGVkLlxuICAgKiAgICogcHJlZmVyQ3VycmVudFF1b3RlTWFyayB7Ym9vbGVhbn0gLSBpZiB0cnVlLCBwcmVmZXIgdGhlIHNvdXJjZSBxdW90ZSBtYXJrXG4gICAqICAgICBvdmVyIHRoZSBxdW90ZU1hcmsgb3B0aW9uIHZhbHVlLlxuICAgKiAgICogc21hcnQge2Jvb2xlYW59IC0gaWYgdHJ1ZSwgd2lsbCBzZWxlY3QgYSBxdW90ZSBtYXJrIGJhc2VkIG9uIHRoZSB2YWx1ZVxuICAgKiAgICAgYW5kIHRoZSBvdGhlciBvcHRpb25zIHNwZWNpZmllZCBoZXJlLiBTZWUgdGhlIGBzbWFydFF1b3RlTWFyaygpYFxuICAgKiAgICAgbWV0aG9kLlxuICAgKiovXG5cblxuICB2YXIgX3Byb3RvID0gQXR0cmlidXRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0UXVvdGVkVmFsdWUgPSBmdW5jdGlvbiBnZXRRdW90ZWRWYWx1ZShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBxdW90ZU1hcmsgPSB0aGlzLl9kZXRlcm1pbmVRdW90ZU1hcmsob3B0aW9ucyk7XG5cbiAgICB2YXIgY3NzZXNjb3B0cyA9IENTU0VTQ19RVU9URV9PUFRJT05TW3F1b3RlTWFya107XG4gICAgdmFyIGVzY2FwZWQgPSAoMCwgX2Nzc2VzY1tcImRlZmF1bHRcIl0pKHRoaXMuX3ZhbHVlLCBjc3Nlc2NvcHRzKTtcbiAgICByZXR1cm4gZXNjYXBlZDtcbiAgfTtcblxuICBfcHJvdG8uX2RldGVybWluZVF1b3RlTWFyayA9IGZ1bmN0aW9uIF9kZXRlcm1pbmVRdW90ZU1hcmsob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnNtYXJ0ID8gdGhpcy5zbWFydFF1b3RlTWFyayhvcHRpb25zKSA6IHRoaXMucHJlZmVycmVkUXVvdGVNYXJrKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHVuZXNjYXBlZCB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVvdGF0aW9uIG9wdGlvbnMuIFRoZSB2YWx1ZVxuICAgKiBwcm92aWRlZCBtdXN0IG5vdCBpbmNsdWRlIGFueSB3cmFwcGluZyBxdW90ZSBtYXJrcyAtLSB0aG9zZSBxdW90ZXMgd2lsbFxuICAgKiBiZSBpbnRlcnByZXRlZCBhcyBwYXJ0IG9mIHRoZSB2YWx1ZSBhbmQgZXNjYXBlZCBhY2NvcmRpbmdseS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX3F1b3RlTWFyayA9IHRoaXMuX2RldGVybWluZVF1b3RlTWFyayhvcHRpb25zKTtcblxuICAgIHRoaXMuX3N5bmNSYXdWYWx1ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlbGxpZ2VudGx5IHNlbGVjdCBhIHF1b3RlTWFyayB2YWx1ZSBiYXNlZCBvbiB0aGUgdmFsdWUncyBjb250ZW50cy4gSWZcbiAgICogdGhlIHZhbHVlIGlzIGEgbGVnYWwgQ1NTIGlkZW50LCBpdCB3aWxsIG5vdCBiZSBxdW90ZWQuIE90aGVyd2lzZSBhIHF1b3RlXG4gICAqIG1hcmsgd2lsbCBiZSBwaWNrZWQgdGhhdCBtaW5pbWl6ZXMgdGhlIG51bWJlciBvZiBlc2NhcGVzLlxuICAgKlxuICAgKiBJZiB0aGVyZSdzIG5vIGNsZWFyIHdpbm5lciwgdGhlIHF1b3RlIG1hcmsgZnJvbSB0aGVzZSBvcHRpb25zIGlzIHVzZWQsXG4gICAqIHRoZW4gdGhlIHNvdXJjZSBxdW90ZSBtYXJrICh0aGlzIGlzIGludmVydGVkIGlmIGBwcmVmZXJDdXJyZW50UXVvdGVNYXJrYCBpc1xuICAgKiB0cnVlKS4gSWYgdGhlIHF1b3RlTWFyayBpcyB1bnNwZWNpZmllZCwgYSBkb3VibGUgcXVvdGUgaXMgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhpcyB0YWtlcyB0aGUgcXVvdGVNYXJrIGFuZCBwcmVmZXJDdXJyZW50UXVvdGVNYXJrIG9wdGlvbnNcbiAgICogZnJvbSB0aGUgcXVvdGVWYWx1ZSBtZXRob2QuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNtYXJ0UXVvdGVNYXJrID0gZnVuY3Rpb24gc21hcnRRdW90ZU1hcmsob3B0aW9ucykge1xuICAgIHZhciB2ID0gdGhpcy52YWx1ZTtcbiAgICB2YXIgbnVtU2luZ2xlUXVvdGVzID0gdi5yZXBsYWNlKC9bXiddL2csICcnKS5sZW5ndGg7XG4gICAgdmFyIG51bURvdWJsZVF1b3RlcyA9IHYucmVwbGFjZSgvW15cIl0vZywgJycpLmxlbmd0aDtcblxuICAgIGlmIChudW1TaW5nbGVRdW90ZXMgKyBudW1Eb3VibGVRdW90ZXMgPT09IDApIHtcbiAgICAgIHZhciBlc2NhcGVkID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKSh2LCB7XG4gICAgICAgIGlzSWRlbnRpZmllcjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlc2NhcGVkID09PSB2KSB7XG4gICAgICAgIHJldHVybiBBdHRyaWJ1dGUuTk9fUVVPVEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJlZiA9IHRoaXMucHJlZmVycmVkUXVvdGVNYXJrKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChwcmVmID09PSBBdHRyaWJ1dGUuTk9fUVVPVEUpIHtcbiAgICAgICAgICAvLyBwaWNrIGEgcXVvdGUgbWFyayB0aGF0IGlzbid0IG5vbmUgYW5kIHNlZSBpZiBpdCdzIHNtYWxsZXJcbiAgICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnF1b3RlTWFyayB8fCBvcHRpb25zLnF1b3RlTWFyayB8fCBBdHRyaWJ1dGUuRE9VQkxFX1FVT1RFO1xuICAgICAgICAgIHZhciBvcHRzID0gQ1NTRVNDX1FVT1RFX09QVElPTlNbcXVvdGVdO1xuICAgICAgICAgIHZhciBxdW90ZVZhbHVlID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKSh2LCBvcHRzKTtcblxuICAgICAgICAgIGlmIChxdW90ZVZhbHVlLmxlbmd0aCA8IGVzY2FwZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZWY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChudW1Eb3VibGVRdW90ZXMgPT09IG51bVNpbmdsZVF1b3Rlcykge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZmVycmVkUXVvdGVNYXJrKG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAobnVtRG91YmxlUXVvdGVzIDwgbnVtU2luZ2xlUXVvdGVzKSB7XG4gICAgICByZXR1cm4gQXR0cmlidXRlLkRPVUJMRV9RVU9URTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEF0dHJpYnV0ZS5TSU5HTEVfUVVPVEU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSBwcmVmZXJyZWQgcXVvdGUgbWFyayBiYXNlZCBvbiB0aGUgb3B0aW9ucyBhbmQgdGhlIGN1cnJlbnQgcXVvdGUgbWFyayB2YWx1ZS5cbiAgICogSWYgeW91IHdhbnQgdGhlIHF1b3RlIG1hcmsgdG8gZGVwZW5kIG9uIHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgYHNtYXJ0UXVvdGVNYXJrKG9wdHMpYFxuICAgKiBpbnN0ZWFkLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wcmVmZXJyZWRRdW90ZU1hcmsgPSBmdW5jdGlvbiBwcmVmZXJyZWRRdW90ZU1hcmsob3B0aW9ucykge1xuICAgIHZhciBxdW90ZU1hcmsgPSBvcHRpb25zLnByZWZlckN1cnJlbnRRdW90ZU1hcmsgPyB0aGlzLnF1b3RlTWFyayA6IG9wdGlvbnMucXVvdGVNYXJrO1xuXG4gICAgaWYgKHF1b3RlTWFyayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBxdW90ZU1hcmsgPSBvcHRpb25zLnByZWZlckN1cnJlbnRRdW90ZU1hcmsgPyBvcHRpb25zLnF1b3RlTWFyayA6IHRoaXMucXVvdGVNYXJrO1xuICAgIH1cblxuICAgIGlmIChxdW90ZU1hcmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcXVvdGVNYXJrID0gQXR0cmlidXRlLkRPVUJMRV9RVU9URTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvdGVNYXJrO1xuICB9O1xuXG4gIF9wcm90by5fc3luY1Jhd1ZhbHVlID0gZnVuY3Rpb24gX3N5bmNSYXdWYWx1ZSgpIHtcbiAgICB2YXIgcmF3VmFsdWUgPSAoMCwgX2Nzc2VzY1tcImRlZmF1bHRcIl0pKHRoaXMuX3ZhbHVlLCBDU1NFU0NfUVVPVEVfT1BUSU9OU1t0aGlzLnF1b3RlTWFya10pO1xuXG4gICAgaWYgKHJhd1ZhbHVlID09PSB0aGlzLl92YWx1ZSkge1xuICAgICAgaWYgKHRoaXMucmF3cykge1xuICAgICAgICBkZWxldGUgdGhpcy5yYXdzLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJhd3MudmFsdWUgPSByYXdWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVFc2NhcGVzID0gZnVuY3Rpb24gX2hhbmRsZUVzY2FwZXMocHJvcCwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fY29uc3RydWN0ZWQpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKSh2YWx1ZSwge1xuICAgICAgICBpc0lkZW50aWZpZXI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXNjYXBlZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYXdzW3Byb3BdID0gZXNjYXBlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJhd3NbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fc3BhY2VzRm9yID0gZnVuY3Rpb24gX3NwYWNlc0ZvcihuYW1lKSB7XG4gICAgdmFyIGF0dHJTcGFjZXMgPSB7XG4gICAgICBiZWZvcmU6ICcnLFxuICAgICAgYWZ0ZXI6ICcnXG4gICAgfTtcbiAgICB2YXIgc3BhY2VzID0gdGhpcy5zcGFjZXNbbmFtZV0gfHwge307XG4gICAgdmFyIHJhd1NwYWNlcyA9IHRoaXMucmF3cy5zcGFjZXMgJiYgdGhpcy5yYXdzLnNwYWNlc1tuYW1lXSB8fCB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhdHRyU3BhY2VzLCBzcGFjZXMsIHJhd1NwYWNlcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9zdHJpbmdGb3IgPSBmdW5jdGlvbiBfc3RyaW5nRm9yKG5hbWUsIHNwYWNlTmFtZSwgY29uY2F0KSB7XG4gICAgaWYgKHNwYWNlTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzcGFjZU5hbWUgPSBuYW1lO1xuICAgIH1cblxuICAgIGlmIChjb25jYXQgPT09IHZvaWQgMCkge1xuICAgICAgY29uY2F0ID0gZGVmYXVsdEF0dHJDb25jYXQ7XG4gICAgfVxuXG4gICAgdmFyIGF0dHJTcGFjZXMgPSB0aGlzLl9zcGFjZXNGb3Ioc3BhY2VOYW1lKTtcblxuICAgIHJldHVybiBjb25jYXQodGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShuYW1lKSwgYXR0clNwYWNlcyk7XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIG9mZnNldCBvZiB0aGUgYXR0cmlidXRlIHBhcnQgc3BlY2lmaWVkIHJlbGF0aXZlIHRvIHRoZVxuICAgKiBzdGFydCBvZiB0aGUgbm9kZSBvZiB0aGUgb3V0cHV0IHN0cmluZy5cbiAgICpcbiAgICogKiBcIm5zXCIgLSBhbGlhcyBmb3IgXCJuYW1lc3BhY2VcIlxuICAgKiAqIFwibmFtZXNwYWNlXCIgLSB0aGUgbmFtZXNwYWNlIGlmIGl0IGV4aXN0cy5cbiAgICogKiBcImF0dHJpYnV0ZVwiIC0gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAqICogXCJhdHRyaWJ1dGVOU1wiIC0gdGhlIHN0YXJ0IG9mIHRoZSBhdHRyaWJ1dGUgb3IgaXRzIG5hbWVzcGFjZVxuICAgKiAqIFwib3BlcmF0b3JcIiAtIHRoZSBtYXRjaCBvcGVyYXRvciBvZiB0aGUgYXR0cmlidXRlXG4gICAqICogXCJ2YWx1ZVwiIC0gVGhlIHZhbHVlIChzdHJpbmcgb3IgaWRlbnRpZmllcilcbiAgICogKiBcImluc2Vuc2l0aXZlXCIgLSB0aGUgY2FzZSBpbnNlbnNpdGl2aXR5IGZsYWc7XG4gICAqIEBwYXJhbSBwYXJ0IE9uZSBvZiB0aGUgcG9zc2libGUgdmFsdWVzIGluc2lkZSBhbiBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm5zIC0xIGlmIHRoZSBuYW1lIGlzIGludmFsaWQgb3IgdGhlIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhpcyBhdHRyaWJ1dGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9mZnNldE9mID0gZnVuY3Rpb24gb2Zmc2V0T2YobmFtZSkge1xuICAgIHZhciBjb3VudCA9IDE7XG5cbiAgICB2YXIgYXR0cmlidXRlU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKFwiYXR0cmlidXRlXCIpO1xuXG4gICAgY291bnQgKz0gYXR0cmlidXRlU3BhY2VzLmJlZm9yZS5sZW5ndGg7XG5cbiAgICBpZiAobmFtZSA9PT0gXCJuYW1lc3BhY2VcIiB8fCBuYW1lID09PSBcIm5zXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZSA/IGNvdW50IDogLTE7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IFwiYXR0cmlidXRlTlNcIikge1xuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIGNvdW50ICs9IHRoaXMubmFtZXNwYWNlU3RyaW5nLmxlbmd0aDtcblxuICAgIGlmICh0aGlzLm5hbWVzcGFjZSkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gXCJhdHRyaWJ1dGVcIikge1xuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIGNvdW50ICs9IHRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJhdHRyaWJ1dGVcIikubGVuZ3RoO1xuICAgIGNvdW50ICs9IGF0dHJpYnV0ZVNwYWNlcy5hZnRlci5sZW5ndGg7XG5cbiAgICB2YXIgb3BlcmF0b3JTcGFjZXMgPSB0aGlzLl9zcGFjZXNGb3IoXCJvcGVyYXRvclwiKTtcblxuICAgIGNvdW50ICs9IG9wZXJhdG9yU3BhY2VzLmJlZm9yZS5sZW5ndGg7XG4gICAgdmFyIG9wZXJhdG9yID0gdGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcIm9wZXJhdG9yXCIpO1xuXG4gICAgaWYgKG5hbWUgPT09IFwib3BlcmF0b3JcIikge1xuICAgICAgcmV0dXJuIG9wZXJhdG9yID8gY291bnQgOiAtMTtcbiAgICB9XG5cbiAgICBjb3VudCArPSBvcGVyYXRvci5sZW5ndGg7XG4gICAgY291bnQgKz0gb3BlcmF0b3JTcGFjZXMuYWZ0ZXIubGVuZ3RoO1xuXG4gICAgdmFyIHZhbHVlU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKFwidmFsdWVcIik7XG5cbiAgICBjb3VudCArPSB2YWx1ZVNwYWNlcy5iZWZvcmUubGVuZ3RoO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJ2YWx1ZVwiKTtcblxuICAgIGlmIChuYW1lID09PSBcInZhbHVlXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IGNvdW50IDogLTE7XG4gICAgfVxuXG4gICAgY291bnQgKz0gdmFsdWUubGVuZ3RoO1xuICAgIGNvdW50ICs9IHZhbHVlU3BhY2VzLmFmdGVyLmxlbmd0aDtcblxuICAgIHZhciBpbnNlbnNpdGl2ZVNwYWNlcyA9IHRoaXMuX3NwYWNlc0ZvcihcImluc2Vuc2l0aXZlXCIpO1xuXG4gICAgY291bnQgKz0gaW5zZW5zaXRpdmVTcGFjZXMuYmVmb3JlLmxlbmd0aDtcblxuICAgIGlmIChuYW1lID09PSBcImluc2Vuc2l0aXZlXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2Vuc2l0aXZlID8gY291bnQgOiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgc2VsZWN0b3IgPSBbdGhpcy5yYXdTcGFjZUJlZm9yZSwgJ1snXTtcbiAgICBzZWxlY3Rvci5wdXNoKHRoaXMuX3N0cmluZ0ZvcigncXVhbGlmaWVkQXR0cmlidXRlJywgJ2F0dHJpYnV0ZScpKTtcblxuICAgIGlmICh0aGlzLm9wZXJhdG9yICYmICh0aGlzLnZhbHVlIHx8IHRoaXMudmFsdWUgPT09ICcnKSkge1xuICAgICAgc2VsZWN0b3IucHVzaCh0aGlzLl9zdHJpbmdGb3IoJ29wZXJhdG9yJykpO1xuICAgICAgc2VsZWN0b3IucHVzaCh0aGlzLl9zdHJpbmdGb3IoJ3ZhbHVlJykpO1xuICAgICAgc2VsZWN0b3IucHVzaCh0aGlzLl9zdHJpbmdGb3IoJ2luc2Vuc2l0aXZlRmxhZycsICdpbnNlbnNpdGl2ZScsIGZ1bmN0aW9uIChhdHRyVmFsdWUsIGF0dHJTcGFjZXMpIHtcbiAgICAgICAgaWYgKGF0dHJWYWx1ZS5sZW5ndGggPiAwICYmICFfdGhpczIucXVvdGVkICYmIGF0dHJTcGFjZXMuYmVmb3JlLmxlbmd0aCA9PT0gMCAmJiAhKF90aGlzMi5zcGFjZXMudmFsdWUgJiYgX3RoaXMyLnNwYWNlcy52YWx1ZS5hZnRlcikpIHtcbiAgICAgICAgICBhdHRyU3BhY2VzLmJlZm9yZSA9IFwiIFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRBdHRyQ29uY2F0KGF0dHJWYWx1ZSwgYXR0clNwYWNlcyk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgc2VsZWN0b3IucHVzaCgnXScpO1xuICAgIHNlbGVjdG9yLnB1c2godGhpcy5yYXdTcGFjZUFmdGVyKTtcbiAgICByZXR1cm4gc2VsZWN0b3Iuam9pbignJyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEF0dHJpYnV0ZSwgW3tcbiAgICBrZXk6IFwicXVvdGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcW0gPSB0aGlzLnF1b3RlTWFyaztcbiAgICAgIHJldHVybiBxbSA9PT0gXCInXCIgfHwgcW0gPT09ICdcIic7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgd2Fybk9mRGVwcmVjYXRlZFF1b3RlZEFzc2lnbm1lbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhIHNpbmdsZSAoYCdgKSBvciBkb3VibGUgKGBcImApIHF1b3RlIGNoYXJhY3RlciBpZiB0aGUgdmFsdWUgaXMgcXVvdGVkLlxuICAgICAqIHJldHVybnMgYG51bGxgIGlmIHRoZSB2YWx1ZSBpcyBub3QgcXVvdGVkLlxuICAgICAqIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIHF1b3RhdGlvbiBzdGF0ZSBpcyB1bmtub3duICh0aGlzIGNhbiBoYXBwZW4gd2hlblxuICAgICAqIHRoZSBhdHRyaWJ1dGUgaXMgY29uc3RydWN0ZWQgd2l0aG91dCBzcGVjaWZ5aW5nIGEgcXVvdGUgbWFyay4pXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJxdW90ZU1hcmtcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdW90ZU1hcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcXVvdGUgbWFyayB0byBiZSB1c2VkIGJ5IHRoaXMgYXR0cmlidXRlJ3MgdmFsdWUuXG4gICAgICogSWYgdGhlIHF1b3RlIG1hcmsgY2hhbmdlcywgdGhlIHJhdyAoZXNjYXBlZCkgdmFsdWUgYXQgYGF0dHIucmF3cy52YWx1ZWAgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIHZhbHVlIGlzIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1wiJ1wiIHwgJ1wiJyB8IG51bGx9IHF1b3RlTWFyayBUaGUgcXVvdGUgbWFyayBvciBgbnVsbGAgaWYgdGhlIHZhbHVlIHNob3VsZCBiZSB1bnF1b3RlZC5cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQocXVvdGVNYXJrKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnN0cnVjdGVkKSB7XG4gICAgICAgIHRoaXMuX3F1b3RlTWFyayA9IHF1b3RlTWFyaztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcXVvdGVNYXJrICE9PSBxdW90ZU1hcmspIHtcbiAgICAgICAgdGhpcy5fcXVvdGVNYXJrID0gcXVvdGVNYXJrO1xuXG4gICAgICAgIHRoaXMuX3N5bmNSYXdWYWx1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWFsaWZpZWRBdHRyaWJ1dGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1YWxpZmllZE5hbWUodGhpcy5yYXdzLmF0dHJpYnV0ZSB8fCB0aGlzLmF0dHJpYnV0ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2Vuc2l0aXZlRmxhZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZW5zaXRpdmUgPyAnaScgOiAnJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVmb3JlIDMuMCwgdGhlIHZhbHVlIGhhZCB0byBiZSBzZXQgdG8gYW4gZXNjYXBlZCB2YWx1ZSBpbmNsdWRpbmcgYW55IHdyYXBwZWRcbiAgICAgKiBxdW90ZSBtYXJrcy4gSW4gMy4wLCB0aGUgc2VtYW50aWNzIG9mIGBBdHRyaWJ1dGUudmFsdWVgIGNoYW5nZWQgc28gdGhhdCB0aGUgdmFsdWVcbiAgICAgKiBpcyB1bmVzY2FwZWQgZHVyaW5nIHBhcnNpbmcgYW5kIGFueSBxdW90ZSBtYXJrcyBhcmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEJlY2F1c2UgdGhlIGFtYmlndWl0eSBvZiB0aGlzIHNlbWFudGljIGNoYW5nZSwgaWYgeW91IHNldCBgYXR0ci52YWx1ZSA9IG5ld1ZhbHVlYCxcbiAgICAgKiBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgaXMgcmFpc2VkIHdoZW4gdGhlIG5ldyB2YWx1ZSBjb250YWlucyBhbnkgY2hhcmFjdGVycyB0aGF0IHdvdWxkXG4gICAgICogcmVxdWlyZSBlc2NhcGluZyAoaW5jbHVkaW5nIGlmIGl0IGNvbnRhaW5zIHdyYXBwZWQgcXVvdGVzKS5cbiAgICAgKlxuICAgICAqIEluc3RlYWQsIHlvdSBzaG91bGQgY2FsbCBgYXR0ci5zZXRWYWx1ZShuZXdWYWx1ZSwgb3B0cylgIGFuZCBwYXNzIG9wdGlvbnMgdGhhdCBkZXNjcmliZVxuICAgICAqIGhvdyB0aGUgbmV3IHZhbHVlIGlzIHF1b3RlZC5cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodikge1xuICAgICAgaWYgKHRoaXMuX2NvbnN0cnVjdGVkKSB7XG4gICAgICAgIHZhciBfdW5lc2NhcGVWYWx1ZTIgPSB1bmVzY2FwZVZhbHVlKHYpLFxuICAgICAgICAgICAgZGVwcmVjYXRlZFVzYWdlID0gX3VuZXNjYXBlVmFsdWUyLmRlcHJlY2F0ZWRVc2FnZSxcbiAgICAgICAgICAgIHVuZXNjYXBlZCA9IF91bmVzY2FwZVZhbHVlMi51bmVzY2FwZWQsXG4gICAgICAgICAgICBxdW90ZU1hcmsgPSBfdW5lc2NhcGVWYWx1ZTIucXVvdGVNYXJrO1xuXG4gICAgICAgIGlmIChkZXByZWNhdGVkVXNhZ2UpIHtcbiAgICAgICAgICB3YXJuT2ZEZXByZWNhdGVkVmFsdWVBc3NpZ25tZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5lc2NhcGVkID09PSB0aGlzLl92YWx1ZSAmJiBxdW90ZU1hcmsgPT09IHRoaXMuX3F1b3RlTWFyaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdW5lc2NhcGVkO1xuICAgICAgICB0aGlzLl9xdW90ZU1hcmsgPSBxdW90ZU1hcms7XG5cbiAgICAgICAgdGhpcy5fc3luY1Jhd1ZhbHVlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5hbWUpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUVzY2FwZXMoXCJhdHRyaWJ1dGVcIiwgbmFtZSk7XG5cbiAgICAgIHRoaXMuX2F0dHJpYnV0ZSA9IG5hbWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF0dHJpYnV0ZTtcbn0oX25hbWVzcGFjZVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEF0dHJpYnV0ZTtcbkF0dHJpYnV0ZS5OT19RVU9URSA9IG51bGw7XG5BdHRyaWJ1dGUuU0lOR0xFX1FVT1RFID0gXCInXCI7XG5BdHRyaWJ1dGUuRE9VQkxFX1FVT1RFID0gJ1wiJztcbnZhciBDU1NFU0NfUVVPVEVfT1BUSU9OUyA9IChfQ1NTRVNDX1FVT1RFX09QVElPTlMgPSB7XG4gIFwiJ1wiOiB7XG4gICAgcXVvdGVzOiAnc2luZ2xlJyxcbiAgICB3cmFwOiB0cnVlXG4gIH0sXG4gICdcIic6IHtcbiAgICBxdW90ZXM6ICdkb3VibGUnLFxuICAgIHdyYXA6IHRydWVcbiAgfVxufSwgX0NTU0VTQ19RVU9URV9PUFRJT05TW251bGxdID0ge1xuICBpc0lkZW50aWZpZXI6IHRydWVcbn0sIF9DU1NFU0NfUVVPVEVfT1BUSU9OUyk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRBdHRyQ29uY2F0KGF0dHJWYWx1ZSwgYXR0clNwYWNlcykge1xuICByZXR1cm4gXCJcIiArIGF0dHJTcGFjZXMuYmVmb3JlICsgYXR0clZhbHVlICsgYXR0clNwYWNlcy5hZnRlcjtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2Nzc2VzYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNzc2VzY1wiKSk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG52YXIgX25vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVcIikpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgQ2xhc3NOYW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHNMb29zZShDbGFzc05hbWUsIF9Ob2RlKTtcblxuICBmdW5jdGlvbiBDbGFzc05hbWUob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX05vZGUuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuQ0xBU1M7XG4gICAgX3RoaXMuX2NvbnN0cnVjdGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2xhc3NOYW1lLnByb3RvdHlwZTtcblxuICBfcHJvdG8udmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uIHZhbHVlVG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICcuJyArIF9Ob2RlLnByb3RvdHlwZS52YWx1ZVRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKENsYXNzTmFtZSwgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcbiAgICAgIGlmICh0aGlzLl9jb25zdHJ1Y3RlZCkge1xuICAgICAgICB2YXIgZXNjYXBlZCA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkodiwge1xuICAgICAgICAgIGlzSWRlbnRpZmllcjogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXNjYXBlZCAhPT0gdikge1xuICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKHRoaXMsIFwicmF3c1wiKTtcbiAgICAgICAgICB0aGlzLnJhd3MudmFsdWUgPSBlc2NhcGVkO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmF3cykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnJhd3MudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbGFzc05hbWU7XG59KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2xhc3NOYW1lO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ub2RlXCIpKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBDb21iaW5hdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHNMb29zZShDb21iaW5hdG9yLCBfTm9kZSk7XG5cbiAgZnVuY3Rpb24gQ29tYmluYXRvcihvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IF90eXBlcy5DT01CSU5BVE9SO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBDb21iaW5hdG9yO1xufShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbWJpbmF0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX25vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVcIikpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIENvbW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0c0xvb3NlKENvbW1lbnQsIF9Ob2RlKTtcblxuICBmdW5jdGlvbiBDb21tZW50KG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gX3R5cGVzLkNPTU1FTlQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIENvbW1lbnQ7XG59KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29tbWVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bml2ZXJzYWwgPSBleHBvcnRzLnRhZyA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5zZWxlY3RvciA9IGV4cG9ydHMucm9vdCA9IGV4cG9ydHMucHNldWRvID0gZXhwb3J0cy5uZXN0aW5nID0gZXhwb3J0cy5pZCA9IGV4cG9ydHMuY29tbWVudCA9IGV4cG9ydHMuY29tYmluYXRvciA9IGV4cG9ydHMuY2xhc3NOYW1lID0gZXhwb3J0cy5hdHRyaWJ1dGUgPSB2b2lkIDA7XG5cbnZhciBfYXR0cmlidXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9hdHRyaWJ1dGVcIikpO1xuXG52YXIgX2NsYXNzTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xhc3NOYW1lXCIpKTtcblxudmFyIF9jb21iaW5hdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb21iaW5hdG9yXCIpKTtcblxudmFyIF9jb21tZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb21tZW50XCIpKTtcblxudmFyIF9pZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaWRcIikpO1xuXG52YXIgX25lc3RpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25lc3RpbmdcIikpO1xuXG52YXIgX3BzZXVkbyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcHNldWRvXCIpKTtcblxudmFyIF9yb290ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb290XCIpKTtcblxudmFyIF9zZWxlY3RvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2VsZWN0b3JcIikpO1xuXG52YXIgX3N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RyaW5nXCIpKTtcblxudmFyIF90YWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RhZ1wiKSk7XG5cbnZhciBfdW5pdmVyc2FsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91bml2ZXJzYWxcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIGF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGF0dHJpYnV0ZShvcHRzKSB7XG4gIHJldHVybiBuZXcgX2F0dHJpYnV0ZVtcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuXG5leHBvcnRzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcblxudmFyIGNsYXNzTmFtZSA9IGZ1bmN0aW9uIGNsYXNzTmFtZShvcHRzKSB7XG4gIHJldHVybiBuZXcgX2NsYXNzTmFtZVtcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuXG5leHBvcnRzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxudmFyIGNvbWJpbmF0b3IgPSBmdW5jdGlvbiBjb21iaW5hdG9yKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfY29tYmluYXRvcltcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuXG5leHBvcnRzLmNvbWJpbmF0b3IgPSBjb21iaW5hdG9yO1xuXG52YXIgY29tbWVudCA9IGZ1bmN0aW9uIGNvbW1lbnQob3B0cykge1xuICByZXR1cm4gbmV3IF9jb21tZW50W1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmV4cG9ydHMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbnZhciBpZCA9IGZ1bmN0aW9uIGlkKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfaWRbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy5pZCA9IGlkO1xuXG52YXIgbmVzdGluZyA9IGZ1bmN0aW9uIG5lc3Rpbmcob3B0cykge1xuICByZXR1cm4gbmV3IF9uZXN0aW5nW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmV4cG9ydHMubmVzdGluZyA9IG5lc3Rpbmc7XG5cbnZhciBwc2V1ZG8gPSBmdW5jdGlvbiBwc2V1ZG8ob3B0cykge1xuICByZXR1cm4gbmV3IF9wc2V1ZG9bXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy5wc2V1ZG8gPSBwc2V1ZG87XG5cbnZhciByb290ID0gZnVuY3Rpb24gcm9vdChvcHRzKSB7XG4gIHJldHVybiBuZXcgX3Jvb3RbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy5yb290ID0gcm9vdDtcblxudmFyIHNlbGVjdG9yID0gZnVuY3Rpb24gc2VsZWN0b3Iob3B0cykge1xuICByZXR1cm4gbmV3IF9zZWxlY3RvcltcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuXG5leHBvcnRzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcob3B0cykge1xuICByZXR1cm4gbmV3IF9zdHJpbmdbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5cbnZhciB0YWcgPSBmdW5jdGlvbiB0YWcob3B0cykge1xuICByZXR1cm4gbmV3IF90YWdbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy50YWcgPSB0YWc7XG5cbnZhciB1bml2ZXJzYWwgPSBmdW5jdGlvbiB1bml2ZXJzYWwob3B0cykge1xuICByZXR1cm4gbmV3IF91bml2ZXJzYWxbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuZXhwb3J0cy51bml2ZXJzYWwgPSB1bml2ZXJzYWw7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ub2RlXCIpKTtcblxudmFyIHR5cGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdHlwZXNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAoKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IHJldHVybiBpdC5uZXh0LmJpbmQoaXQpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIENvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ29udGFpbmVyLCBfTm9kZSk7XG5cbiAgZnVuY3Rpb24gQ29udGFpbmVyKG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblxuICAgIGlmICghX3RoaXMubm9kZXMpIHtcbiAgICAgIF90aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENvbnRhaW5lci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChzZWxlY3Rvcikge1xuICAgIHNlbGVjdG9yLnBhcmVudCA9IHRoaXM7XG4gICAgdGhpcy5ub2Rlcy5wdXNoKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoc2VsZWN0b3IpIHtcbiAgICBzZWxlY3Rvci5wYXJlbnQgPSB0aGlzO1xuICAgIHRoaXMubm9kZXMudW5zaGlmdChzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmF0ID0gZnVuY3Rpb24gYXQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1tpbmRleF07XG4gIH07XG5cbiAgX3Byb3RvLmluZGV4ID0gZnVuY3Rpb24gaW5kZXgoY2hpbGQpIHtcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgY2hpbGQgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICB0aGlzLmF0KGNoaWxkKS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpO1xuICAgIHZhciBpbmRleDtcblxuICAgIGZvciAodmFyIGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXggPSB0aGlzLmluZGV4ZXNbaWRdO1xuXG4gICAgICBpZiAoaW5kZXggPj0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4IC0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlQWxsID0gZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcy5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbm9kZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgbm9kZS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5lbXB0eSA9IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbCgpO1xuICB9O1xuXG4gIF9wcm90by5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgICBuZXdOb2RlLnBhcmVudCA9IHRoaXM7XG4gICAgdmFyIG9sZEluZGV4ID0gdGhpcy5pbmRleChvbGROb2RlKTtcbiAgICB0aGlzLm5vZGVzLnNwbGljZShvbGRJbmRleCArIDEsIDAsIG5ld05vZGUpO1xuICAgIG5ld05vZGUucGFyZW50ID0gdGhpcztcbiAgICB2YXIgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXTtcblxuICAgICAgaWYgKG9sZEluZGV4IDw9IGluZGV4KSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgIHZhciBvbGRJbmRleCA9IHRoaXMuaW5kZXgob2xkTm9kZSk7XG4gICAgdGhpcy5ub2Rlcy5zcGxpY2Uob2xkSW5kZXgsIDAsIG5ld05vZGUpO1xuICAgIG5ld05vZGUucGFyZW50ID0gdGhpcztcbiAgICB2YXIgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXTtcblxuICAgICAgaWYgKGluZGV4IDw9IG9sZEluZGV4KSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLl9maW5kQ2hpbGRBdFBvc2l0aW9uID0gZnVuY3Rpb24gX2ZpbmRDaGlsZEF0UG9zaXRpb24obGluZSwgY29sKSB7XG4gICAgdmFyIGZvdW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUuYXRQb3NpdGlvbikge1xuICAgICAgICB2YXIgZm91bmRDaGlsZCA9IG5vZGUuYXRQb3NpdGlvbihsaW5lLCBjb2wpO1xuXG4gICAgICAgIGlmIChmb3VuZENoaWxkKSB7XG4gICAgICAgICAgZm91bmQgPSBmb3VuZENoaWxkO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmlzQXRQb3NpdGlvbihsaW5lLCBjb2wpKSB7XG4gICAgICAgIGZvdW5kID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtb3N0IHNwZWNpZmljIG5vZGUgYXQgdGhlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXIgZ2l2ZW4uXG4gICAqIFRoZSBzb3VyY2UgbG9jYXRpb24gaXMgYmFzZWQgb24gdGhlIG9yaWdpbmFsIHBhcnNlZCBsb2NhdGlvbiwgbG9jYXRpb25zIGFyZW4ndFxuICAgKiB1cGRhdGVkIGFzIHNlbGVjdG9yIG5vZGVzIGFyZSBtdXRhdGVkLlxuICAgKiBcbiAgICogTm90ZSB0aGF0IHRoaXMgbG9jYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICogb2YgdGhlIHNlbGVjdG9yLCBhbmQgbm90IHRoZSBsb2NhdGlvbiBvZiB0aGUgc2VsZWN0b3IgaW4gdGhlIG92ZXJhbGwgZG9jdW1lbnRcbiAgICogd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggcG9zdGNzcy5cbiAgICpcbiAgICogSWYgbm90IGZvdW5kLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmUgVGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBub2RlIHRvIGZpbmQuICgxLWJhc2VkIGluZGV4KVxuICAgKiBAcGFyYW0ge251bWJlcn0gY29sICBUaGUgY29sdW1uIG51bWJlciBvZiB0aGUgbm9kZSB0byBmaW5kLiAoMS1iYXNlZCBpbmRleClcbiAgICovXG4gIDtcblxuICBfcHJvdG8uYXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGF0UG9zaXRpb24obGluZSwgY29sKSB7XG4gICAgaWYgKHRoaXMuaXNBdFBvc2l0aW9uKGxpbmUsIGNvbCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kQ2hpbGRBdFBvc2l0aW9uKGxpbmUsIGNvbCkgfHwgdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9pbmZlckVuZFBvc2l0aW9uID0gZnVuY3Rpb24gX2luZmVyRW5kUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMubGFzdCAmJiB0aGlzLmxhc3Quc291cmNlICYmIHRoaXMubGFzdC5zb3VyY2UuZW5kKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHRoaXMuc291cmNlIHx8IHt9O1xuICAgICAgdGhpcy5zb3VyY2UuZW5kID0gdGhpcy5zb3VyY2UuZW5kIHx8IHt9O1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnNvdXJjZS5lbmQsIHRoaXMubGFzdC5zb3VyY2UuZW5kKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmVhY2ggPSBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmxhc3RFYWNoKSB7XG4gICAgICB0aGlzLmxhc3RFYWNoID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaW5kZXhlcykge1xuICAgICAgdGhpcy5pbmRleGVzID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0RWFjaCsrO1xuICAgIHZhciBpZCA9IHRoaXMubGFzdEVhY2g7XG4gICAgdGhpcy5pbmRleGVzW2lkXSA9IDA7XG5cbiAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBpbmRleCwgcmVzdWx0O1xuXG4gICAgd2hpbGUgKHRoaXMuaW5kZXhlc1tpZF0gPCB0aGlzLmxlbmd0aCkge1xuICAgICAgaW5kZXggPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodGhpcy5hdChpbmRleCksIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5kZXhlc1tpZF0gKz0gMTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5pbmRleGVzW2lkXTtcblxuICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by53YWxrID0gZnVuY3Rpb24gd2FsayhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhub2RlLCBpKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UgJiYgbm9kZS5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gbm9kZS53YWxrKGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by53YWxrQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHdhbGtBdHRyaWJ1dGVzKGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzLkFUVFJJQlVURSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczIsIHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ud2Fsa0NsYXNzZXMgPSBmdW5jdGlvbiB3YWxrQ2xhc3NlcyhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcy5DTEFTUykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczMsIHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ud2Fsa0NvbWJpbmF0b3JzID0gZnVuY3Rpb24gd2Fsa0NvbWJpbmF0b3JzKGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzLkNPTUJJTkFUT1IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXM0LCBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLndhbGtDb21tZW50cyA9IGZ1bmN0aW9uIHdhbGtDb21tZW50cyhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcy5DT01NRU5UKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKF90aGlzNSwgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by53YWxrSWRzID0gZnVuY3Rpb24gd2Fsa0lkcyhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcy5JRCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczYsIHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ud2Fsa05lc3RpbmcgPSBmdW5jdGlvbiB3YWxrTmVzdGluZyhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcy5ORVNUSU5HKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKF90aGlzNywgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by53YWxrUHNldWRvcyA9IGZ1bmN0aW9uIHdhbGtQc2V1ZG9zKGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzLlBTRVVETykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczgsIHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ud2Fsa1RhZ3MgPSBmdW5jdGlvbiB3YWxrVGFncyhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcy5UQUcpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXM5LCBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLndhbGtVbml2ZXJzYWxzID0gZnVuY3Rpb24gd2Fsa1VuaXZlcnNhbHMoY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzLlVOSVZFUlNBTCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczEwLCBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICB2YXIgY3VycmVudCA9IFtdO1xuICAgIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgbm9kZSwgaW5kZXgpIHtcbiAgICAgIHZhciBzcGxpdCA9IGNhbGxiYWNrLmNhbGwoX3RoaXMxMSwgbm9kZSk7XG4gICAgICBjdXJyZW50LnB1c2gobm9kZSk7XG5cbiAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICBtZW1vLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IF90aGlzMTEubGVuZ3RoIC0gMSkge1xuICAgICAgICBtZW1vLnB1c2goY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIFtdKTtcbiAgfTtcblxuICBfcHJvdG8ubWFwID0gZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMubWFwKGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8ucmVkdWNlID0gZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrLCBtZW1vKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKGNhbGxiYWNrLCBtZW1vKTtcbiAgfTtcblxuICBfcHJvdG8uZXZlcnkgPSBmdW5jdGlvbiBldmVyeShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmV2ZXJ5KGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uc29tZSA9IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5zb21lKGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuZmlsdGVyKGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uc29ydCA9IGZ1bmN0aW9uIHNvcnQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5zb3J0KGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoU3RyaW5nKS5qb2luKCcnKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoQ29udGFpbmVyLCBbe1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXQoMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0KHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb250YWluZXI7XG59KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29udGFpbmVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmlzTm9kZSA9IGlzTm9kZTtcbmV4cG9ydHMuaXNQc2V1ZG9FbGVtZW50ID0gaXNQc2V1ZG9FbGVtZW50O1xuZXhwb3J0cy5pc1BzZXVkb0NsYXNzID0gaXNQc2V1ZG9DbGFzcztcbmV4cG9ydHMuaXNDb250YWluZXIgPSBpc0NvbnRhaW5lcjtcbmV4cG9ydHMuaXNOYW1lc3BhY2UgPSBpc05hbWVzcGFjZTtcbmV4cG9ydHMuaXNVbml2ZXJzYWwgPSBleHBvcnRzLmlzVGFnID0gZXhwb3J0cy5pc1N0cmluZyA9IGV4cG9ydHMuaXNTZWxlY3RvciA9IGV4cG9ydHMuaXNSb290ID0gZXhwb3J0cy5pc1BzZXVkbyA9IGV4cG9ydHMuaXNOZXN0aW5nID0gZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBleHBvcnRzLmlzQ29tbWVudCA9IGV4cG9ydHMuaXNDb21iaW5hdG9yID0gZXhwb3J0cy5pc0NsYXNzTmFtZSA9IGV4cG9ydHMuaXNBdHRyaWJ1dGUgPSB2b2lkIDA7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxudmFyIF9JU19UWVBFO1xuXG52YXIgSVNfVFlQRSA9IChfSVNfVFlQRSA9IHt9LCBfSVNfVFlQRVtfdHlwZXMuQVRUUklCVVRFXSA9IHRydWUsIF9JU19UWVBFW190eXBlcy5DTEFTU10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuQ09NQklOQVRPUl0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuQ09NTUVOVF0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuSURdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLk5FU1RJTkddID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLlBTRVVET10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuUk9PVF0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuU0VMRUNUT1JdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLlNUUklOR10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuVEFHXSA9IHRydWUsIF9JU19UWVBFW190eXBlcy5VTklWRVJTQUxdID0gdHJ1ZSwgX0lTX1RZUEUpO1xuXG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICByZXR1cm4gdHlwZW9mIG5vZGUgPT09IFwib2JqZWN0XCIgJiYgSVNfVFlQRVtub2RlLnR5cGVdO1xufVxuXG5mdW5jdGlvbiBpc05vZGVUeXBlKHR5cGUsIG5vZGUpIHtcbiAgcmV0dXJuIGlzTm9kZShub2RlKSAmJiBub2RlLnR5cGUgPT09IHR5cGU7XG59XG5cbnZhciBpc0F0dHJpYnV0ZSA9IGlzTm9kZVR5cGUuYmluZChudWxsLCBfdHlwZXMuQVRUUklCVVRFKTtcbmV4cG9ydHMuaXNBdHRyaWJ1dGUgPSBpc0F0dHJpYnV0ZTtcbnZhciBpc0NsYXNzTmFtZSA9IGlzTm9kZVR5cGUuYmluZChudWxsLCBfdHlwZXMuQ0xBU1MpO1xuZXhwb3J0cy5pc0NsYXNzTmFtZSA9IGlzQ2xhc3NOYW1lO1xudmFyIGlzQ29tYmluYXRvciA9IGlzTm9kZVR5cGUuYmluZChudWxsLCBfdHlwZXMuQ09NQklOQVRPUik7XG5leHBvcnRzLmlzQ29tYmluYXRvciA9IGlzQ29tYmluYXRvcjtcbnZhciBpc0NvbW1lbnQgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLkNPTU1FTlQpO1xuZXhwb3J0cy5pc0NvbW1lbnQgPSBpc0NvbW1lbnQ7XG52YXIgaXNJZGVudGlmaWVyID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5JRCk7XG5leHBvcnRzLmlzSWRlbnRpZmllciA9IGlzSWRlbnRpZmllcjtcbnZhciBpc05lc3RpbmcgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLk5FU1RJTkcpO1xuZXhwb3J0cy5pc05lc3RpbmcgPSBpc05lc3Rpbmc7XG52YXIgaXNQc2V1ZG8gPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlBTRVVETyk7XG5leHBvcnRzLmlzUHNldWRvID0gaXNQc2V1ZG87XG52YXIgaXNSb290ID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5ST09UKTtcbmV4cG9ydHMuaXNSb290ID0gaXNSb290O1xudmFyIGlzU2VsZWN0b3IgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlNFTEVDVE9SKTtcbmV4cG9ydHMuaXNTZWxlY3RvciA9IGlzU2VsZWN0b3I7XG52YXIgaXNTdHJpbmcgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlNUUklORyk7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG52YXIgaXNUYWcgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlRBRyk7XG5leHBvcnRzLmlzVGFnID0gaXNUYWc7XG52YXIgaXNVbml2ZXJzYWwgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlVOSVZFUlNBTCk7XG5leHBvcnRzLmlzVW5pdmVyc2FsID0gaXNVbml2ZXJzYWw7XG5cbmZ1bmN0aW9uIGlzUHNldWRvRWxlbWVudChub2RlKSB7XG4gIHJldHVybiBpc1BzZXVkbyhub2RlKSAmJiBub2RlLnZhbHVlICYmIChub2RlLnZhbHVlLnN0YXJ0c1dpdGgoXCI6OlwiKSB8fCBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwiOmJlZm9yZVwiIHx8IG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCI6YWZ0ZXJcIiB8fCBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwiOmZpcnN0LWxldHRlclwiIHx8IG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCI6Zmlyc3QtbGluZVwiKTtcbn1cblxuZnVuY3Rpb24gaXNQc2V1ZG9DbGFzcyhub2RlKSB7XG4gIHJldHVybiBpc1BzZXVkbyhub2RlKSAmJiAhaXNQc2V1ZG9FbGVtZW50KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBpc0NvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShpc05vZGUobm9kZSkgJiYgbm9kZS53YWxrKTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lc3BhY2Uobm9kZSkge1xuICByZXR1cm4gaXNBdHRyaWJ1dGUobm9kZSkgfHwgaXNUYWcobm9kZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ub2RlXCIpKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBJRCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoSUQsIF9Ob2RlKTtcblxuICBmdW5jdGlvbiBJRChvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IF90eXBlcy5JRDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSUQucHJvdG90eXBlO1xuXG4gIF9wcm90by52YWx1ZVRvU3RyaW5nID0gZnVuY3Rpb24gdmFsdWVUb1N0cmluZygpIHtcbiAgICByZXR1cm4gJyMnICsgX05vZGUucHJvdG90eXBlLnZhbHVlVG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gSUQ7XG59KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gSUQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5PYmplY3Qua2V5cyhfdHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90eXBlc1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF90eXBlc1trZXldO1xufSk7XG5cbnZhciBfY29uc3RydWN0b3JzID0gcmVxdWlyZShcIi4vY29uc3RydWN0b3JzXCIpO1xuXG5PYmplY3Qua2V5cyhfY29uc3RydWN0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfY29uc3RydWN0b3JzW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2NvbnN0cnVjdG9yc1trZXldO1xufSk7XG5cbnZhciBfZ3VhcmRzID0gcmVxdWlyZShcIi4vZ3VhcmRzXCIpO1xuXG5PYmplY3Qua2V5cyhfZ3VhcmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfZ3VhcmRzW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2d1YXJkc1trZXldO1xufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jc3Nlc2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjc3Nlc2NcIikpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxudmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ub2RlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBOYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0c0xvb3NlKE5hbWVzcGFjZSwgX05vZGUpO1xuXG4gIGZ1bmN0aW9uIE5hbWVzcGFjZSgpIHtcbiAgICByZXR1cm4gX05vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE5hbWVzcGFjZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnF1YWxpZmllZE5hbWUgPSBmdW5jdGlvbiBxdWFsaWZpZWROYW1lKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMubmFtZXNwYWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VTdHJpbmcgKyBcInxcIiArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by52YWx1ZVRvU3RyaW5nID0gZnVuY3Rpb24gdmFsdWVUb1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5xdWFsaWZpZWROYW1lKF9Ob2RlLnByb3RvdHlwZS52YWx1ZVRvU3RyaW5nLmNhbGwodGhpcykpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhOYW1lc3BhY2UsIFt7XG4gICAga2V5OiBcIm5hbWVzcGFjZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWVzcGFjZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5hbWVzcGFjZSkge1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdHJ1ZSB8fCBuYW1lc3BhY2UgPT09IFwiKlwiIHx8IG5hbWVzcGFjZSA9PT0gXCImXCIpIHtcbiAgICAgICAgdGhpcy5fbmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gICAgICAgIGlmICh0aGlzLnJhd3MpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5yYXdzLm5hbWVzcGFjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVzY2FwZWQgPSAoMCwgX2Nzc2VzY1tcImRlZmF1bHRcIl0pKG5hbWVzcGFjZSwge1xuICAgICAgICBpc0lkZW50aWZpZXI6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gICAgICBpZiAoZXNjYXBlZCAhPT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKHRoaXMsIFwicmF3c1wiKTtcbiAgICAgICAgdGhpcy5yYXdzLm5hbWVzcGFjZSA9IGVzY2FwZWQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmF3cykge1xuICAgICAgICBkZWxldGUgdGhpcy5yYXdzLm5hbWVzcGFjZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uYW1lc3BhY2U7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lc3BhY2UpIHtcbiAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuYW1lc3BhY2VTdHJpbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLm5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbnMgPSB0aGlzLnN0cmluZ2lmeVByb3BlcnR5KFwibmFtZXNwYWNlXCIpO1xuXG4gICAgICAgIGlmIChucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmFtZXNwYWNlO1xufShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE5hbWVzcGFjZTtcbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZVwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgTmVzdGluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoTmVzdGluZywgX05vZGUpO1xuXG4gIGZ1bmN0aW9uIE5lc3Rpbmcob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX05vZGUuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuTkVTVElORztcbiAgICBfdGhpcy52YWx1ZSA9ICcmJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gTmVzdGluZztcbn0oX25vZGVbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBOZXN0aW5nO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIGNsb25lTm9kZSA9IGZ1bmN0aW9uIGNsb25lTm9kZShvYmosIHBhcmVudCkge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBjbG9uZWQgPSBuZXcgb2JqLmNvbnN0cnVjdG9yKCk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gb2JqW2ldO1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKGkgPT09ICdwYXJlbnQnICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNsb25lZFtpXSA9IHBhcmVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGNsb25lZFtpXSA9IHZhbHVlLm1hcChmdW5jdGlvbiAoaikge1xuICAgICAgICByZXR1cm4gY2xvbmVOb2RlKGosIGNsb25lZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvbmVkW2ldID0gY2xvbmVOb2RlKHZhbHVlLCBjbG9uZWQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9uZWQ7XG59O1xuXG52YXIgTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vZGUob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdHMpO1xuICAgIHRoaXMuc3BhY2VzID0gdGhpcy5zcGFjZXMgfHwge307XG4gICAgdGhpcy5zcGFjZXMuYmVmb3JlID0gdGhpcy5zcGFjZXMuYmVmb3JlIHx8ICcnO1xuICAgIHRoaXMuc3BhY2VzLmFmdGVyID0gdGhpcy5zcGFjZXMuYWZ0ZXIgfHwgJyc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTm9kZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIHJlcGxhY2VXaXRoKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgZm9yICh2YXIgaW5kZXggaW4gYXJndW1lbnRzKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBhcmd1bWVudHNbaW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmF0KHRoaXMucGFyZW50LmluZGV4KHRoaXMpICsgMSk7XG4gIH07XG5cbiAgX3Byb3RvLnByZXYgPSBmdW5jdGlvbiBwcmV2KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hdCh0aGlzLnBhcmVudC5pbmRleCh0aGlzKSAtIDEpO1xuICB9O1xuXG4gIF9wcm90by5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG92ZXJyaWRlcykge1xuICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkge1xuICAgICAgb3ZlcnJpZGVzID0ge307XG4gICAgfVxuXG4gICAgdmFyIGNsb25lZCA9IGNsb25lTm9kZSh0aGlzKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICBjbG9uZWRbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICAvKipcbiAgICogU29tZSBub24tc3RhbmRhcmQgc3ludGF4IGRvZXNuJ3QgZm9sbG93IG5vcm1hbCBlc2NhcGluZyBydWxlcyBmb3IgY3NzLlxuICAgKiBUaGlzIGFsbG93cyBub24gc3RhbmRhcmQgc3ludGF4IHRvIGJlIGFwcGVuZGVkIHRvIGFuIGV4aXN0aW5nIHByb3BlcnR5XG4gICAqIGJ5IHNwZWNpZnlpbmcgdGhlIGVzY2FwZWQgdmFsdWUuIEJ5IHNwZWNpZnlpbmcgdGhlIGVzY2FwZWQgdmFsdWUsXG4gICAqIGlsbGVnYWwgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCB0byBiZSBkaXJlY3RseSBpbnNlcnRlZCBpbnRvIGNzcyBvdXRwdXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIHRoZSB1bmVzY2FwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUVzY2FwZWQgb3B0aW9uYWwuIHRoZSBlc2NhcGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYXBwZW5kVG9Qcm9wZXJ0eUFuZEVzY2FwZSA9IGZ1bmN0aW9uIGFwcGVuZFRvUHJvcGVydHlBbmRFc2NhcGUobmFtZSwgdmFsdWUsIHZhbHVlRXNjYXBlZCkge1xuICAgIGlmICghdGhpcy5yYXdzKSB7XG4gICAgICB0aGlzLnJhd3MgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IHRoaXNbbmFtZV07XG4gICAgdmFyIG9yaWdpbmFsRXNjYXBlZCA9IHRoaXMucmF3c1tuYW1lXTtcbiAgICB0aGlzW25hbWVdID0gb3JpZ2luYWxWYWx1ZSArIHZhbHVlOyAvLyB0aGlzIG1heSB0cmlnZ2VyIGEgc2V0dGVyIHRoYXQgdXBkYXRlcyByYXdzLCBzbyBpdCBoYXMgdG8gYmUgc2V0IGZpcnN0LlxuXG4gICAgaWYgKG9yaWdpbmFsRXNjYXBlZCB8fCB2YWx1ZUVzY2FwZWQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnJhd3NbbmFtZV0gPSAob3JpZ2luYWxFc2NhcGVkIHx8IG9yaWdpbmFsVmFsdWUpICsgdmFsdWVFc2NhcGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5yYXdzW25hbWVdOyAvLyBkZWxldGUgYW55IGVzY2FwZWQgdmFsdWUgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgc2V0dGVyLlxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU29tZSBub24tc3RhbmRhcmQgc3ludGF4IGRvZXNuJ3QgZm9sbG93IG5vcm1hbCBlc2NhcGluZyBydWxlcyBmb3IgY3NzLlxuICAgKiBUaGlzIGFsbG93cyB0aGUgZXNjYXBlZCB2YWx1ZSB0byBiZSBzcGVjaWZpZWQgZGlyZWN0bHksIGFsbG93aW5nIGlsbGVnYWxcbiAgICogY2hhcmFjdGVycyB0byBiZSBkaXJlY3RseSBpbnNlcnRlZCBpbnRvIGNzcyBvdXRwdXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIHRoZSB1bmVzY2FwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUVzY2FwZWQgdGhlIGVzY2FwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRQcm9wZXJ0eUFuZEVzY2FwZSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5QW5kRXNjYXBlKG5hbWUsIHZhbHVlLCB2YWx1ZUVzY2FwZWQpIHtcbiAgICBpZiAoIXRoaXMucmF3cykge1xuICAgICAgdGhpcy5yYXdzID0ge307XG4gICAgfVxuXG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlOyAvLyB0aGlzIG1heSB0cmlnZ2VyIGEgc2V0dGVyIHRoYXQgdXBkYXRlcyByYXdzLCBzbyBpdCBoYXMgdG8gYmUgc2V0IGZpcnN0LlxuXG4gICAgdGhpcy5yYXdzW25hbWVdID0gdmFsdWVFc2NhcGVkO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIHlvdSB3YW50IGEgdmFsdWUgdG8gcGFzc2VkIHRocm91Z2ggdG8gQ1NTIGRpcmVjdGx5LiBUaGlzIG1ldGhvZFxuICAgKiBkZWxldGVzIHRoZSBjb3JyZXNwb25kaW5nIHJhdyB2YWx1ZSBjYXVzaW5nIHRoZSBzdHJpbmdpZmllciB0byBmYWxsYmFja1xuICAgKiB0byB0aGUgdW5lc2NhcGVkIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgaXMgYm90aCBlc2NhcGVkIGFuZCB1bmVzY2FwZWQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldFByb3BlcnR5V2l0aG91dEVzY2FwZSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5V2l0aG91dEVzY2FwZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTsgLy8gdGhpcyBtYXkgdHJpZ2dlciBhIHNldHRlciB0aGF0IHVwZGF0ZXMgcmF3cywgc28gaXQgaGFzIHRvIGJlIHNldCBmaXJzdC5cblxuICAgIGlmICh0aGlzLnJhd3MpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJhd3NbbmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZSBUaGUgbnVtYmVyIChzdGFydGluZyB3aXRoIDEpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gVGhlIGNvbHVtbiBudW1iZXIgKHN0YXJ0aW5nIHdpdGggMSlcbiAgICovXG4gIDtcblxuICBfcHJvdG8uaXNBdFBvc2l0aW9uID0gZnVuY3Rpb24gaXNBdFBvc2l0aW9uKGxpbmUsIGNvbHVtbikge1xuICAgIGlmICh0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5zdGFydCAmJiB0aGlzLnNvdXJjZS5lbmQpIHtcbiAgICAgIGlmICh0aGlzLnNvdXJjZS5zdGFydC5saW5lID4gbGluZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZS5lbmQubGluZSA8IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2Uuc3RhcnQubGluZSA9PT0gbGluZSAmJiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4gPiBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2UuZW5kLmxpbmUgPT09IGxpbmUgJiYgdGhpcy5zb3VyY2UuZW5kLmNvbHVtbiA8IGNvbHVtbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgX3Byb3RvLnN0cmluZ2lmeVByb3BlcnR5ID0gZnVuY3Rpb24gc3RyaW5naWZ5UHJvcGVydHkobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJhd3MgJiYgdGhpcy5yYXdzW25hbWVdIHx8IHRoaXNbbmFtZV07XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlVG9TdHJpbmcgPSBmdW5jdGlvbiB2YWx1ZVRvU3RyaW5nKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcInZhbHVlXCIpKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gW3RoaXMucmF3U3BhY2VCZWZvcmUsIHRoaXMudmFsdWVUb1N0cmluZygpLCB0aGlzLnJhd1NwYWNlQWZ0ZXJdLmpvaW4oJycpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhOb2RlLCBbe1xuICAgIGtleTogXCJyYXdTcGFjZUJlZm9yZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHJhd1NwYWNlID0gdGhpcy5yYXdzICYmIHRoaXMucmF3cy5zcGFjZXMgJiYgdGhpcy5yYXdzLnNwYWNlcy5iZWZvcmU7XG5cbiAgICAgIGlmIChyYXdTcGFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJhd1NwYWNlID0gdGhpcy5zcGFjZXMgJiYgdGhpcy5zcGFjZXMuYmVmb3JlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3U3BhY2UgfHwgXCJcIjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHJhdykge1xuICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkodGhpcywgXCJyYXdzXCIsIFwic3BhY2VzXCIpO1xuICAgICAgdGhpcy5yYXdzLnNwYWNlcy5iZWZvcmUgPSByYXc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhd1NwYWNlQWZ0ZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByYXdTcGFjZSA9IHRoaXMucmF3cyAmJiB0aGlzLnJhd3Muc3BhY2VzICYmIHRoaXMucmF3cy5zcGFjZXMuYWZ0ZXI7XG5cbiAgICAgIGlmIChyYXdTcGFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJhd1NwYWNlID0gdGhpcy5zcGFjZXMuYWZ0ZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYXdTcGFjZSB8fCBcIlwiO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQocmF3KSB7XG4gICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KSh0aGlzLCBcInJhd3NcIiwgXCJzcGFjZXNcIik7XG4gICAgICB0aGlzLnJhd3Muc3BhY2VzLmFmdGVyID0gcmF3O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE5vZGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NvbnRhaW5lciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udGFpbmVyXCIpKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBQc2V1ZG8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUHNldWRvLCBfQ29udGFpbmVyKTtcblxuICBmdW5jdGlvbiBQc2V1ZG8ob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NvbnRhaW5lci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IF90eXBlcy5QU0VVRE87XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBzZXVkby5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMubGVuZ3RoID8gJygnICsgdGhpcy5tYXAoU3RyaW5nKS5qb2luKCcsJykgKyAnKScgOiAnJztcbiAgICByZXR1cm4gW3RoaXMucmF3U3BhY2VCZWZvcmUsIHRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJ2YWx1ZVwiKSwgcGFyYW1zLCB0aGlzLnJhd1NwYWNlQWZ0ZXJdLmpvaW4oJycpO1xuICB9O1xuXG4gIHJldHVybiBQc2V1ZG87XG59KF9jb250YWluZXJbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQc2V1ZG87XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NvbnRhaW5lciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udGFpbmVyXCIpKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFJvb3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUm9vdCwgX0NvbnRhaW5lcik7XG5cbiAgZnVuY3Rpb24gUm9vdChvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29udGFpbmVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gX3R5cGVzLlJPT1Q7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJvb3QucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSB0aGlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgc2VsZWN0b3IpIHtcbiAgICAgIG1lbW8ucHVzaChTdHJpbmcoc2VsZWN0b3IpKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIFtdKS5qb2luKCcsJyk7XG4gICAgcmV0dXJuIHRoaXMudHJhaWxpbmdDb21tYSA/IHN0ciArICcsJyA6IHN0cjtcbiAgfTtcblxuICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2Vycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhSb290LCBbe1xuICAgIGtleTogXCJlcnJvckdlbmVyYXRvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2Vycm9yID0gaGFuZGxlcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUm9vdDtcbn0oX2NvbnRhaW5lcltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJvb3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NvbnRhaW5lciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udGFpbmVyXCIpKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBTZWxlY3RvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbnRhaW5lcikge1xuICBfaW5oZXJpdHNMb29zZShTZWxlY3RvciwgX0NvbnRhaW5lcik7XG5cbiAgZnVuY3Rpb24gU2VsZWN0b3Iob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NvbnRhaW5lci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IF90eXBlcy5TRUxFQ1RPUjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU2VsZWN0b3I7XG59KF9jb250YWluZXJbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTZWxlY3Rvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbm9kZVwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgU3RyaW5nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHNMb29zZShTdHJpbmcsIF9Ob2RlKTtcblxuICBmdW5jdGlvbiBTdHJpbmcob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX05vZGUuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuU1RSSU5HO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBTdHJpbmc7XG59KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU3RyaW5nO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9uYW1lc3BhY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTmFtZXNwYWNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRhZywgX05hbWVzcGFjZSk7XG5cbiAgZnVuY3Rpb24gVGFnKG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9OYW1lc3BhY2UuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuVEFHO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBUYWc7XG59KF9uYW1lc3BhY2VbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBUYWc7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuVU5JVkVSU0FMID0gZXhwb3J0cy5BVFRSSUJVVEUgPSBleHBvcnRzLkNMQVNTID0gZXhwb3J0cy5DT01CSU5BVE9SID0gZXhwb3J0cy5DT01NRU5UID0gZXhwb3J0cy5JRCA9IGV4cG9ydHMuTkVTVElORyA9IGV4cG9ydHMuUFNFVURPID0gZXhwb3J0cy5ST09UID0gZXhwb3J0cy5TRUxFQ1RPUiA9IGV4cG9ydHMuU1RSSU5HID0gZXhwb3J0cy5UQUcgPSB2b2lkIDA7XG52YXIgVEFHID0gJ3RhZyc7XG5leHBvcnRzLlRBRyA9IFRBRztcbnZhciBTVFJJTkcgPSAnc3RyaW5nJztcbmV4cG9ydHMuU1RSSU5HID0gU1RSSU5HO1xudmFyIFNFTEVDVE9SID0gJ3NlbGVjdG9yJztcbmV4cG9ydHMuU0VMRUNUT1IgPSBTRUxFQ1RPUjtcbnZhciBST09UID0gJ3Jvb3QnO1xuZXhwb3J0cy5ST09UID0gUk9PVDtcbnZhciBQU0VVRE8gPSAncHNldWRvJztcbmV4cG9ydHMuUFNFVURPID0gUFNFVURPO1xudmFyIE5FU1RJTkcgPSAnbmVzdGluZyc7XG5leHBvcnRzLk5FU1RJTkcgPSBORVNUSU5HO1xudmFyIElEID0gJ2lkJztcbmV4cG9ydHMuSUQgPSBJRDtcbnZhciBDT01NRU5UID0gJ2NvbW1lbnQnO1xuZXhwb3J0cy5DT01NRU5UID0gQ09NTUVOVDtcbnZhciBDT01CSU5BVE9SID0gJ2NvbWJpbmF0b3InO1xuZXhwb3J0cy5DT01CSU5BVE9SID0gQ09NQklOQVRPUjtcbnZhciBDTEFTUyA9ICdjbGFzcyc7XG5leHBvcnRzLkNMQVNTID0gQ0xBU1M7XG52YXIgQVRUUklCVVRFID0gJ2F0dHJpYnV0ZSc7XG5leHBvcnRzLkFUVFJJQlVURSA9IEFUVFJJQlVURTtcbnZhciBVTklWRVJTQUwgPSAndW5pdmVyc2FsJztcbmV4cG9ydHMuVU5JVkVSU0FMID0gVU5JVkVSU0FMOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfbmFtZXNwYWNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9uYW1lc3BhY2VcIikpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFVuaXZlcnNhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05hbWVzcGFjZSkge1xuICBfaW5oZXJpdHNMb29zZShVbml2ZXJzYWwsIF9OYW1lc3BhY2UpO1xuXG4gIGZ1bmN0aW9uIFVuaXZlcnNhbChvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfTmFtZXNwYWNlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gX3R5cGVzLlVOSVZFUlNBTDtcbiAgICBfdGhpcy52YWx1ZSA9ICcqJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gVW5pdmVyc2FsO1xufShfbmFtZXNwYWNlW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVW5pdmVyc2FsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNvcnRBc2NlbmRpbmc7XG5cbmZ1bmN0aW9uIHNvcnRBc2NlbmRpbmcobGlzdCkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTtcbn1cblxuO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbWJpbmF0b3IgPSBleHBvcnRzLndvcmQgPSBleHBvcnRzLmNvbW1lbnQgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMudGFiID0gZXhwb3J0cy5uZXdsaW5lID0gZXhwb3J0cy5mZWVkID0gZXhwb3J0cy5jciA9IGV4cG9ydHMuYmFja3NsYXNoID0gZXhwb3J0cy5iYW5nID0gZXhwb3J0cy5zbGFzaCA9IGV4cG9ydHMuZG91YmxlUXVvdGUgPSBleHBvcnRzLnNpbmdsZVF1b3RlID0gZXhwb3J0cy5zcGFjZSA9IGV4cG9ydHMuZ3JlYXRlclRoYW4gPSBleHBvcnRzLnBpcGUgPSBleHBvcnRzLmVxdWFscyA9IGV4cG9ydHMucGx1cyA9IGV4cG9ydHMuY2FyZXQgPSBleHBvcnRzLnRpbGRlID0gZXhwb3J0cy5kb2xsYXIgPSBleHBvcnRzLmNsb3NlU3F1YXJlID0gZXhwb3J0cy5vcGVuU3F1YXJlID0gZXhwb3J0cy5jbG9zZVBhcmVudGhlc2lzID0gZXhwb3J0cy5vcGVuUGFyZW50aGVzaXMgPSBleHBvcnRzLnNlbWljb2xvbiA9IGV4cG9ydHMuY29sb24gPSBleHBvcnRzLmNvbW1hID0gZXhwb3J0cy5hdCA9IGV4cG9ydHMuYXN0ZXJpc2sgPSBleHBvcnRzLmFtcGVyc2FuZCA9IHZvaWQgMDtcbnZhciBhbXBlcnNhbmQgPSAzODsgLy8gYCZgLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuYW1wZXJzYW5kID0gYW1wZXJzYW5kO1xudmFyIGFzdGVyaXNrID0gNDI7IC8vIGAqYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLmFzdGVyaXNrID0gYXN0ZXJpc2s7XG52YXIgYXQgPSA2NDsgLy8gYEBgLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuYXQgPSBhdDtcbnZhciBjb21tYSA9IDQ0OyAvLyBgLGAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5jb21tYSA9IGNvbW1hO1xudmFyIGNvbG9uID0gNTg7IC8vIGA6YC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLmNvbG9uID0gY29sb247XG52YXIgc2VtaWNvbG9uID0gNTk7IC8vIGA7YC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLnNlbWljb2xvbiA9IHNlbWljb2xvbjtcbnZhciBvcGVuUGFyZW50aGVzaXMgPSA0MDsgLy8gYChgLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMub3BlblBhcmVudGhlc2lzID0gb3BlblBhcmVudGhlc2lzO1xudmFyIGNsb3NlUGFyZW50aGVzaXMgPSA0MTsgLy8gYClgLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuY2xvc2VQYXJlbnRoZXNpcyA9IGNsb3NlUGFyZW50aGVzaXM7XG52YXIgb3BlblNxdWFyZSA9IDkxOyAvLyBgW2AuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5vcGVuU3F1YXJlID0gb3BlblNxdWFyZTtcbnZhciBjbG9zZVNxdWFyZSA9IDkzOyAvLyBgXWAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5jbG9zZVNxdWFyZSA9IGNsb3NlU3F1YXJlO1xudmFyIGRvbGxhciA9IDM2OyAvLyBgJGAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5kb2xsYXIgPSBkb2xsYXI7XG52YXIgdGlsZGUgPSAxMjY7IC8vIGB+YC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLnRpbGRlID0gdGlsZGU7XG52YXIgY2FyZXQgPSA5NDsgLy8gYF5gLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuY2FyZXQgPSBjYXJldDtcbnZhciBwbHVzID0gNDM7IC8vIGArYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLnBsdXMgPSBwbHVzO1xudmFyIGVxdWFscyA9IDYxOyAvLyBgPWAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG52YXIgcGlwZSA9IDEyNDsgLy8gYHxgLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMucGlwZSA9IHBpcGU7XG52YXIgZ3JlYXRlclRoYW4gPSA2MjsgLy8gYD5gLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuZ3JlYXRlclRoYW4gPSBncmVhdGVyVGhhbjtcbnZhciBzcGFjZSA9IDMyOyAvLyBgIGAuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5zcGFjZSA9IHNwYWNlO1xudmFyIHNpbmdsZVF1b3RlID0gMzk7IC8vIGAnYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLnNpbmdsZVF1b3RlID0gc2luZ2xlUXVvdGU7XG52YXIgZG91YmxlUXVvdGUgPSAzNDsgLy8gYFwiYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLmRvdWJsZVF1b3RlID0gZG91YmxlUXVvdGU7XG52YXIgc2xhc2ggPSA0NzsgLy8gYC9gLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMuc2xhc2ggPSBzbGFzaDtcbnZhciBiYW5nID0gMzM7IC8vIGAhYC5jaGFyQ29kZUF0KDApO1xuXG5leHBvcnRzLmJhbmcgPSBiYW5nO1xudmFyIGJhY2tzbGFzaCA9IDkyOyAvLyAnXFxcXCcuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5iYWNrc2xhc2ggPSBiYWNrc2xhc2g7XG52YXIgY3IgPSAxMzsgLy8gJ1xccicuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5jciA9IGNyO1xudmFyIGZlZWQgPSAxMjsgLy8gJ1xcZicuY2hhckNvZGVBdCgwKTtcblxuZXhwb3J0cy5mZWVkID0gZmVlZDtcbnZhciBuZXdsaW5lID0gMTA7IC8vICdcXG4nLmNoYXJDb2RlQXQoMCk7XG5cbmV4cG9ydHMubmV3bGluZSA9IG5ld2xpbmU7XG52YXIgdGFiID0gOTsgLy8gJ1xcdCcuY2hhckNvZGVBdCgwKTtcbi8vIEV4cG9zZSBhbGlhc2VzIHByaW1hcmlseSBmb3IgcmVhZGFiaWxpdHkuXG5cbmV4cG9ydHMudGFiID0gdGFiO1xudmFyIHN0ciA9IHNpbmdsZVF1b3RlOyAvLyBObyBnb29kIHNpbmdsZSBjaGFyYWN0ZXIgcmVwcmVzZW50YXRpb24hXG5cbmV4cG9ydHMuc3RyID0gc3RyO1xudmFyIGNvbW1lbnQgPSAtMTtcbmV4cG9ydHMuY29tbWVudCA9IGNvbW1lbnQ7XG52YXIgd29yZCA9IC0yO1xuZXhwb3J0cy53b3JkID0gd29yZDtcbnZhciBjb21iaW5hdG9yID0gLTM7XG5leHBvcnRzLmNvbWJpbmF0b3IgPSBjb21iaW5hdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB0b2tlbml6ZTtcbmV4cG9ydHMuRklFTERTID0gdm9pZCAwO1xuXG52YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3Rva2VuVHlwZXNcIikpO1xuXG52YXIgX3VuZXNjYXBhYmxlLCBfd29yZERlbGltaXRlcnM7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG52YXIgdW5lc2NhcGFibGUgPSAoX3VuZXNjYXBhYmxlID0ge30sIF91bmVzY2FwYWJsZVt0LnRhYl0gPSB0cnVlLCBfdW5lc2NhcGFibGVbdC5uZXdsaW5lXSA9IHRydWUsIF91bmVzY2FwYWJsZVt0LmNyXSA9IHRydWUsIF91bmVzY2FwYWJsZVt0LmZlZWRdID0gdHJ1ZSwgX3VuZXNjYXBhYmxlKTtcbnZhciB3b3JkRGVsaW1pdGVycyA9IChfd29yZERlbGltaXRlcnMgPSB7fSwgX3dvcmREZWxpbWl0ZXJzW3Quc3BhY2VdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QudGFiXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0Lm5ld2xpbmVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY3JdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuZmVlZF0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5hbXBlcnNhbmRdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuYXN0ZXJpc2tdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuYmFuZ10gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jb21tYV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jb2xvbl0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5zZW1pY29sb25dID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Qub3BlblBhcmVudGhlc2lzXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmNsb3NlUGFyZW50aGVzaXNdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Qub3BlblNxdWFyZV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jbG9zZVNxdWFyZV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5zaW5nbGVRdW90ZV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5kb3VibGVRdW90ZV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5wbHVzXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LnBpcGVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QudGlsZGVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuZ3JlYXRlclRoYW5dID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuZXF1YWxzXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmRvbGxhcl0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jYXJldF0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5zbGFzaF0gPSB0cnVlLCBfd29yZERlbGltaXRlcnMpO1xudmFyIGhleCA9IHt9O1xudmFyIGhleENoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmQUJDREVGXCI7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgaGV4Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgaGV4W2hleENoYXJzLmNoYXJDb2RlQXQoaSldID0gdHJ1ZTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGxhc3QgaW5kZXggb2YgdGhlIGJhciBjc3Mgd29yZFxuICogQHBhcmFtIHtzdHJpbmd9IGNzcyBUaGUgc3RyaW5nIGluIHdoaWNoIHRoZSB3b3JkIGJlZ2luc1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCBpbnRvIHRoZSBzdHJpbmcgd2hlcmUgd29yZCdzIGZpcnN0IGxldHRlciBvY2N1cnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbnN1bWVXb3JkKGNzcywgc3RhcnQpIHtcbiAgdmFyIG5leHQgPSBzdGFydDtcbiAgdmFyIGNvZGU7XG5cbiAgZG8ge1xuICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KTtcblxuICAgIGlmICh3b3JkRGVsaW1pdGVyc1tjb2RlXSkge1xuICAgICAgcmV0dXJuIG5leHQgLSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gdC5iYWNrc2xhc2gpIHtcbiAgICAgIG5leHQgPSBjb25zdW1lRXNjYXBlKGNzcywgbmV4dCkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBbGwgb3RoZXIgY2hhcmFjdGVycyBhcmUgcGFydCBvZiB0aGUgd29yZFxuICAgICAgbmV4dCsrO1xuICAgIH1cbiAgfSB3aGlsZSAobmV4dCA8IGNzcy5sZW5ndGgpO1xuXG4gIHJldHVybiBuZXh0IC0gMTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGxhc3QgaW5kZXggb2YgdGhlIGVzY2FwZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGNzcyBUaGUgc3RyaW5nIGluIHdoaWNoIHRoZSBzZXF1ZW5jZSBiZWdpbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggaW50byB0aGUgc3RyaW5nIHdoZXJlIGVzY2FwZSBjaGFyYWN0ZXIgKGBcXGApIG9jY3Vycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbnN1bWVFc2NhcGUoY3NzLCBzdGFydCkge1xuICB2YXIgbmV4dCA9IHN0YXJ0O1xuICB2YXIgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcblxuICBpZiAodW5lc2NhcGFibGVbY29kZV0pIHsvLyBqdXN0IGNvbnN1bWUgdGhlIGVzY2FwZSBjaGFyXG4gIH0gZWxzZSBpZiAoaGV4W2NvZGVdKSB7XG4gICAgdmFyIGhleERpZ2l0cyA9IDA7IC8vIGNvbnN1bWUgdXAgdG8gNiBoZXggY2hhcnNcblxuICAgIGRvIHtcbiAgICAgIG5leHQrKztcbiAgICAgIGhleERpZ2l0cysrO1xuICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcbiAgICB9IHdoaWxlIChoZXhbY29kZV0gJiYgaGV4RGlnaXRzIDwgNik7IC8vIGlmIGZld2VyIHRoYW4gNiBoZXggY2hhcnMsIGEgdHJhaWxpbmcgc3BhY2UgZW5kcyB0aGUgZXNjYXBlXG5cblxuICAgIGlmIChoZXhEaWdpdHMgPCA2ICYmIGNvZGUgPT09IHQuc3BhY2UpIHtcbiAgICAgIG5leHQrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIG5leHQgY2hhciBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHdvcmRcbiAgICBuZXh0Kys7XG4gIH1cblxuICByZXR1cm4gbmV4dDtcbn1cblxudmFyIEZJRUxEUyA9IHtcbiAgVFlQRTogMCxcbiAgU1RBUlRfTElORTogMSxcbiAgU1RBUlRfQ09MOiAyLFxuICBFTkRfTElORTogMyxcbiAgRU5EX0NPTDogNCxcbiAgU1RBUlRfUE9TOiA1LFxuICBFTkRfUE9TOiA2XG59O1xuZXhwb3J0cy5GSUVMRFMgPSBGSUVMRFM7XG5cbmZ1bmN0aW9uIHRva2VuaXplKGlucHV0KSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGNzcyA9IGlucHV0LmNzcy52YWx1ZU9mKCk7XG4gIHZhciBfY3NzID0gY3NzLFxuICAgICAgbGVuZ3RoID0gX2Nzcy5sZW5ndGg7XG4gIHZhciBvZmZzZXQgPSAtMTtcbiAgdmFyIGxpbmUgPSAxO1xuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gMDtcbiAgdmFyIGNvZGUsIGNvbnRlbnQsIGVuZENvbHVtbiwgZW5kTGluZSwgZXNjYXBlZCwgZXNjYXBlUG9zLCBsYXN0LCBsaW5lcywgbmV4dCwgbmV4dExpbmUsIG5leHRPZmZzZXQsIHF1b3RlLCB0b2tlblR5cGU7XG5cbiAgZnVuY3Rpb24gdW5jbG9zZWQod2hhdCwgZml4KSB7XG4gICAgaWYgKGlucHV0LnNhZmUpIHtcbiAgICAgIC8vIGZ5aTogdGhpcyBpcyBuZXZlciBzZXQgdG8gdHJ1ZS5cbiAgICAgIGNzcyArPSBmaXg7XG4gICAgICBuZXh0ID0gY3NzLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGlucHV0LmVycm9yKCdVbmNsb3NlZCAnICsgd2hhdCwgbGluZSwgc3RhcnQgLSBvZmZzZXQsIHN0YXJ0KTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoc3RhcnQgPCBsZW5ndGgpIHtcbiAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gICAgaWYgKGNvZGUgPT09IHQubmV3bGluZSkge1xuICAgICAgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICBsaW5lICs9IDE7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIHQuc3BhY2U6XG4gICAgICBjYXNlIHQudGFiOlxuICAgICAgY2FzZSB0Lm5ld2xpbmU6XG4gICAgICBjYXNlIHQuY3I6XG4gICAgICBjYXNlIHQuZmVlZDpcbiAgICAgICAgbmV4dCA9IHN0YXJ0O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQpO1xuXG4gICAgICAgICAgaWYgKGNvZGUgPT09IHQubmV3bGluZSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbmV4dDtcbiAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGNvZGUgPT09IHQuc3BhY2UgfHwgY29kZSA9PT0gdC5uZXdsaW5lIHx8IGNvZGUgPT09IHQudGFiIHx8IGNvZGUgPT09IHQuY3IgfHwgY29kZSA9PT0gdC5mZWVkKTtcblxuICAgICAgICB0b2tlblR5cGUgPSB0LnNwYWNlO1xuICAgICAgICBlbmRMaW5lID0gbGluZTtcbiAgICAgICAgZW5kQ29sdW1uID0gbmV4dCAtIG9mZnNldCAtIDE7XG4gICAgICAgIGVuZCA9IG5leHQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHQucGx1czpcbiAgICAgIGNhc2UgdC5ncmVhdGVyVGhhbjpcbiAgICAgIGNhc2UgdC50aWxkZTpcbiAgICAgIGNhc2UgdC5waXBlOlxuICAgICAgICBuZXh0ID0gc3RhcnQ7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgIH0gd2hpbGUgKGNvZGUgPT09IHQucGx1cyB8fCBjb2RlID09PSB0LmdyZWF0ZXJUaGFuIHx8IGNvZGUgPT09IHQudGlsZGUgfHwgY29kZSA9PT0gdC5waXBlKTtcblxuICAgICAgICB0b2tlblR5cGUgPSB0LmNvbWJpbmF0b3I7XG4gICAgICAgIGVuZExpbmUgPSBsaW5lO1xuICAgICAgICBlbmRDb2x1bW4gPSBzdGFydCAtIG9mZnNldDtcbiAgICAgICAgZW5kID0gbmV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBDb25zdW1lIHRoZXNlIGNoYXJhY3RlcnMgYXMgc2luZ2xlIHRva2Vucy5cblxuICAgICAgY2FzZSB0LmFzdGVyaXNrOlxuICAgICAgY2FzZSB0LmFtcGVyc2FuZDpcbiAgICAgIGNhc2UgdC5iYW5nOlxuICAgICAgY2FzZSB0LmNvbW1hOlxuICAgICAgY2FzZSB0LmVxdWFsczpcbiAgICAgIGNhc2UgdC5kb2xsYXI6XG4gICAgICBjYXNlIHQuY2FyZXQ6XG4gICAgICBjYXNlIHQub3BlblNxdWFyZTpcbiAgICAgIGNhc2UgdC5jbG9zZVNxdWFyZTpcbiAgICAgIGNhc2UgdC5jb2xvbjpcbiAgICAgIGNhc2UgdC5zZW1pY29sb246XG4gICAgICBjYXNlIHQub3BlblBhcmVudGhlc2lzOlxuICAgICAgY2FzZSB0LmNsb3NlUGFyZW50aGVzaXM6XG4gICAgICAgIG5leHQgPSBzdGFydDtcbiAgICAgICAgdG9rZW5UeXBlID0gY29kZTtcbiAgICAgICAgZW5kTGluZSA9IGxpbmU7XG4gICAgICAgIGVuZENvbHVtbiA9IHN0YXJ0IC0gb2Zmc2V0O1xuICAgICAgICBlbmQgPSBuZXh0ICsgMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdC5zaW5nbGVRdW90ZTpcbiAgICAgIGNhc2UgdC5kb3VibGVRdW90ZTpcbiAgICAgICAgcXVvdGUgPSBjb2RlID09PSB0LnNpbmdsZVF1b3RlID8gXCInXCIgOiAnXCInO1xuICAgICAgICBuZXh0ID0gc3RhcnQ7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcblxuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgdW5jbG9zZWQoJ3F1b3RlJywgcXVvdGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHQ7XG5cbiAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IHQuYmFja3NsYXNoKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGVzY2FwZWQpO1xuXG4gICAgICAgIHRva2VuVHlwZSA9IHQuc3RyO1xuICAgICAgICBlbmRMaW5lID0gbGluZTtcbiAgICAgICAgZW5kQ29sdW1uID0gc3RhcnQgLSBvZmZzZXQ7XG4gICAgICAgIGVuZCA9IG5leHQgKyAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNvZGUgPT09IHQuc2xhc2ggJiYgY3NzLmNoYXJDb2RlQXQoc3RhcnQgKyAxKSA9PT0gdC5hc3Rlcmlzaykge1xuICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZignKi8nLCBzdGFydCArIDIpICsgMTtcblxuICAgICAgICAgIGlmIChuZXh0ID09PSAwKSB7XG4gICAgICAgICAgICB1bmNsb3NlZCgnY29tbWVudCcsICcqLycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRlbnQgPSBjc3Muc2xpY2Uoc3RhcnQsIG5leHQgKyAxKTtcbiAgICAgICAgICBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGxhc3QgPSBsaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgaWYgKGxhc3QgPiAwKSB7XG4gICAgICAgICAgICBuZXh0TGluZSA9IGxpbmUgKyBsYXN0O1xuICAgICAgICAgICAgbmV4dE9mZnNldCA9IG5leHQgLSBsaW5lc1tsYXN0XS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRMaW5lID0gbGluZTtcbiAgICAgICAgICAgIG5leHRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5UeXBlID0gdC5jb21tZW50O1xuICAgICAgICAgIGxpbmUgPSBuZXh0TGluZTtcbiAgICAgICAgICBlbmRMaW5lID0gbmV4dExpbmU7XG4gICAgICAgICAgZW5kQ29sdW1uID0gbmV4dCAtIG5leHRPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gdC5zbGFzaCkge1xuICAgICAgICAgIG5leHQgPSBzdGFydDtcbiAgICAgICAgICB0b2tlblR5cGUgPSBjb2RlO1xuICAgICAgICAgIGVuZExpbmUgPSBsaW5lO1xuICAgICAgICAgIGVuZENvbHVtbiA9IHN0YXJ0IC0gb2Zmc2V0O1xuICAgICAgICAgIGVuZCA9IG5leHQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBjb25zdW1lV29yZChjc3MsIHN0YXJ0KTtcbiAgICAgICAgICB0b2tlblR5cGUgPSB0LndvcmQ7XG4gICAgICAgICAgZW5kTGluZSA9IGxpbmU7XG4gICAgICAgICAgZW5kQ29sdW1uID0gbmV4dCAtIG9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZCA9IG5leHQgKyAxO1xuICAgICAgICBicmVhaztcbiAgICB9IC8vIEVuc3VyZSB0aGF0IHRoZSB0b2tlbiBzdHJ1Y3R1cmUgcmVtYWlucyBjb25zaXN0ZW50XG5cblxuICAgIHRva2Vucy5wdXNoKFt0b2tlblR5cGUsIC8vIFswXSBUb2tlbiB0eXBlXG4gICAgbGluZSwgLy8gWzFdIFN0YXJ0aW5nIGxpbmVcbiAgICBzdGFydCAtIG9mZnNldCwgLy8gWzJdIFN0YXJ0aW5nIGNvbHVtblxuICAgIGVuZExpbmUsIC8vIFszXSBFbmRpbmcgbGluZVxuICAgIGVuZENvbHVtbiwgLy8gWzRdIEVuZGluZyBjb2x1bW5cbiAgICBzdGFydCwgLy8gWzVdIFN0YXJ0IHBvc2l0aW9uIC8gU291cmNlIGluZGV4XG4gICAgZW5kIC8vIFs2XSBFbmQgcG9zaXRpb25cbiAgICBdKTsgLy8gUmVzZXQgb2Zmc2V0IGZvciB0aGUgbmV4dCB0b2tlblxuXG4gICAgaWYgKG5leHRPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG5leHRPZmZzZXQ7XG4gICAgICBuZXh0T2Zmc2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBzdGFydCA9IGVuZDtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGVuc3VyZU9iamVjdDtcblxuZnVuY3Rpb24gZW5zdXJlT2JqZWN0KG9iaikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvcHMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHByb3BzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHdoaWxlIChwcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wcy5zaGlmdCgpO1xuXG4gICAgaWYgKCFvYmpbcHJvcF0pIHtcbiAgICAgIG9ialtwcm9wXSA9IHt9O1xuICAgIH1cblxuICAgIG9iaiA9IG9ialtwcm9wXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZ2V0UHJvcDtcblxuZnVuY3Rpb24gZ2V0UHJvcChvYmopIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwcm9wc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB3aGlsZSAocHJvcHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBwcm9wID0gcHJvcHMuc2hpZnQoKTtcblxuICAgIGlmICghb2JqW3Byb3BdKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG9iaiA9IG9ialtwcm9wXTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5zdHJpcENvbW1lbnRzID0gZXhwb3J0cy5lbnN1cmVPYmplY3QgPSBleHBvcnRzLmdldFByb3AgPSBleHBvcnRzLnVuZXNjID0gdm9pZCAwO1xuXG52YXIgX3VuZXNjID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91bmVzY1wiKSk7XG5cbmV4cG9ydHMudW5lc2MgPSBfdW5lc2NbXCJkZWZhdWx0XCJdO1xuXG52YXIgX2dldFByb3AgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2dldFByb3BcIikpO1xuXG5leHBvcnRzLmdldFByb3AgPSBfZ2V0UHJvcFtcImRlZmF1bHRcIl07XG5cbnZhciBfZW5zdXJlT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9lbnN1cmVPYmplY3RcIikpO1xuXG5leHBvcnRzLmVuc3VyZU9iamVjdCA9IF9lbnN1cmVPYmplY3RbXCJkZWZhdWx0XCJdO1xuXG52YXIgX3N0cmlwQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmlwQ29tbWVudHNcIikpO1xuXG5leHBvcnRzLnN0cmlwQ29tbWVudHMgPSBfc3RyaXBDb21tZW50c1tcImRlZmF1bHRcIl07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBzdHJpcENvbW1lbnRzO1xuXG5mdW5jdGlvbiBzdHJpcENvbW1lbnRzKHN0cikge1xuICB2YXIgcyA9IFwiXCI7XG4gIHZhciBjb21tZW50U3RhcnQgPSBzdHIuaW5kZXhPZihcIi8qXCIpO1xuICB2YXIgbGFzdEVuZCA9IDA7XG5cbiAgd2hpbGUgKGNvbW1lbnRTdGFydCA+PSAwKSB7XG4gICAgcyA9IHMgKyBzdHIuc2xpY2UobGFzdEVuZCwgY29tbWVudFN0YXJ0KTtcbiAgICB2YXIgY29tbWVudEVuZCA9IHN0ci5pbmRleE9mKFwiKi9cIiwgY29tbWVudFN0YXJ0ICsgMik7XG5cbiAgICBpZiAoY29tbWVudEVuZCA8IDApIHtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIGxhc3RFbmQgPSBjb21tZW50RW5kICsgMjtcbiAgICBjb21tZW50U3RhcnQgPSBzdHIuaW5kZXhPZihcIi8qXCIsIGxhc3RFbmQpO1xuICB9XG5cbiAgcyA9IHMgKyBzdHIuc2xpY2UobGFzdEVuZCk7XG4gIHJldHVybiBzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdW5lc2M7XG5cbi8vIE1hbnkgdGhhbmtzIGZvciB0aGlzIHBvc3Qgd2hpY2ggbWFkZSB0aGlzIG1pZ3JhdGlvbiBtdWNoIGVhc2llci5cbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9jc3MtZXNjYXBlc1xuXG4vKipcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBcbiAqIEByZXR1cm5zIHtbc3RyaW5nLCBudW1iZXJdfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ29iYmxlSGV4KHN0cikge1xuICB2YXIgbG93ZXIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhleCA9ICcnO1xuICB2YXIgc3BhY2VUZXJtaW5hdGVkID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2ICYmIGxvd2VyW2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgIHZhciBjb2RlID0gbG93ZXIuY2hhckNvZGVBdChpKTsgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYSB2YWxpZCBoZXggY2hhciBbYS1mfDAtOV1cblxuICAgIHZhciB2YWxpZCA9IGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMDIgfHwgY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3OyAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXN5bnRheC8jY29uc3VtZS1lc2NhcGVkLWNvZGUtcG9pbnRcblxuICAgIHNwYWNlVGVybWluYXRlZCA9IGNvZGUgPT09IDMyO1xuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGV4ICs9IGxvd2VyW2ldO1xuICB9XG5cbiAgaWYgKGhleC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGNvZGVQb2ludCA9IHBhcnNlSW50KGhleCwgMTYpO1xuICB2YXIgaXNTdXJyb2dhdGUgPSBjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkY7IC8vIEFkZCBzcGVjaWFsIGNhc2UgZm9yXG4gIC8vIFwiSWYgdGhpcyBudW1iZXIgaXMgemVybywgb3IgaXMgZm9yIGEgc3Vycm9nYXRlLCBvciBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBjb2RlIHBvaW50XCJcbiAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1zeW50YXgvI21heGltdW0tYWxsb3dlZC1jb2RlLXBvaW50XG5cbiAgaWYgKGlzU3Vycm9nYXRlIHx8IGNvZGVQb2ludCA9PT0gMHgwMDAwIHx8IGNvZGVQb2ludCA+IDB4MTBGRkZGKSB7XG4gICAgcmV0dXJuIFtcIlxcdUZGRkRcIiwgaGV4Lmxlbmd0aCArIChzcGFjZVRlcm1pbmF0ZWQgPyAxIDogMCldO1xuICB9XG5cbiAgcmV0dXJuIFtTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpLCBoZXgubGVuZ3RoICsgKHNwYWNlVGVybWluYXRlZCA/IDEgOiAwKV07XG59XG5cbnZhciBDT05UQUlOU19FU0NBUEUgPSAvXFxcXC87XG5cbmZ1bmN0aW9uIHVuZXNjKHN0cikge1xuICB2YXIgbmVlZFRvUHJvY2VzcyA9IENPTlRBSU5TX0VTQ0FQRS50ZXN0KHN0cik7XG5cbiAgaWYgKCFuZWVkVG9Qcm9jZXNzKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciByZXQgPSBcIlwiO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIHZhciBnb2JibGVkID0gZ29iYmxlSGV4KHN0ci5zbGljZShpICsgMSwgaSArIDcpKTtcblxuICAgICAgaWYgKGdvYmJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQgKz0gZ29iYmxlZFswXTtcbiAgICAgICAgaSArPSBnb2JibGVkWzFdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gUmV0YWluIGEgcGFpciBvZiBcXFxcIGlmIGRvdWJsZSBlc2NhcGVkIGBcXFxcXFxcXGBcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0Y3NzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2NvbW1pdC8yNjhjOWE3NjU2ZmI1M2Y1NDNkYzYyMGFhNWI3M2EzMGVjM2ZmMjBlXG5cblxuICAgICAgaWYgKHN0cltpICsgMV0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgIHJldCArPSBcIlxcXFxcIjtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gaWYgXFxcXCBpcyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgcmV0YWluIGl0XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9zdGNzcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9jb21taXQvMDFhNmIzNDZlMzYxMmNlMWFiMjAyMTlhY2MyNmFiZGMyNTljY2VmYlxuXG5cbiAgICAgIGlmIChzdHIubGVuZ3RoID09PSBpICsgMSkge1xuICAgICAgICByZXQgKz0gc3RyW2ldO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXQgKz0gc3RyW2ldO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcblxuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG5cbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cblxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG5cbiAgY3NzICs9IG9iai5jc3M7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIlxubGV0IGNvbnRhY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmNvbnRhY3QudGV4dENvbnRlbnQgPSBcIkNvbnRhY3RcIjtcbmNvbnRhY3QuY2xhc3NMaXN0LmFkZCgnaGVhZGVyLWJ1dHRvbicpO1xuXG5sZXQgc2NyZWVuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21pZGRsZS13aW5kb3cnKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRhY3Q7IiwiXG5sZXQgc2NyZWVuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21pZGRsZS13aW5kb3cnKTtcblxubGV0IGhvbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmhvbWUudGV4dENvbnRlbnQgPSAnSG9tZSc7XG5ob21lLmNsYXNzTGlzdC5hZGQoJ2hlYWRlci1idXR0b24nKTtcblxuZXhwb3J0IGRlZmF1bHQgaG9tZTtcbiIsImltcG9ydCBob21lIGZyb20gJy4vaG9tZS5qcydcbmltcG9ydCBtZW51IGZyb20gJy4vbWVudS5qcydcbmltcG9ydCBjb250YWN0IGZyb20gJy4vY29udGFjdC5qcydcblxuaW1wb3J0ICcuL3N0eWxlLmNzcydcbmltcG9ydCB7IGlzQ29udGFpbmVyIH0gZnJvbSAncG9zdGNzcy1zZWxlY3Rvci1wYXJzZXInO1xuXG5sZXQgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuY29udGVudC5zZXRBdHRyaWJ1dGUoJ2lkJywnY29udGVudCcpO1xuXG5sZXQgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbnRpdGxlLnNldEF0dHJpYnV0ZSgnaWQnLCd0aXRsZScpO1xudGl0bGUudGV4dENvbnRlbnQgPSBcIlR3aXN0ZWQgQ29uZXNcIjtcbmNvbnRlbnQuYXBwZW5kQ2hpbGQodGl0bGUpO1xuXG5sZXQgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5oZWFkZXIuc2V0QXR0cmlidXRlKCdpZCcsJ2hlYWRlcicpO1xuaGVhZGVyLmFwcGVuZENoaWxkKGhvbWUpO1xuaGVhZGVyLmFwcGVuZENoaWxkKG1lbnUpO1xuaGVhZGVyLmFwcGVuZENoaWxkKGNvbnRhY3QpO1xuXG5jb250ZW50LmFwcGVuZENoaWxkKGhlYWRlcik7XG5cbmxldCBtaWRkbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbm1pZGRsZS5zZXRBdHRyaWJ1dGUoJ2lkJywnbWlkZGxlJyk7XG5sZXQgc2NyZWVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG53cml0ZV9ob21lKCk7XG5zY3JlZW4uc2V0QXR0cmlidXRlKCdpZCcsJ21pZGRsZS13aW5kb3cnKTtcbm1pZGRsZS5hcHBlbmRDaGlsZChzY3JlZW4pO1xuY29udGVudC5hcHBlbmRDaGlsZChtaWRkbGUpO1xuXG5ob21lLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyx3cml0ZV9ob21lKTtcblxuZnVuY3Rpb24gd3JpdGVfaG9tZSgpe1xuICAgIHNjcmVlbi5pbm5lckhUTUwgPSAnJztcbiAgICBzY3JlZW4uc3R5bGUuY3NzVGV4dCA9IFwiZGlzcGF5OmZsZXg7IGZsZXgtZGlyZWN0aW9uOmNvbHVtbjsgYm94LXNpemluZzpib3JkZXItYm94OyBwYWRkaW5nOjUwcHg7IFwiO1xuICAgIGxldCB0ZXh0MSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gxJyk7XG4gICAgdGV4dDEuc2V0QXR0cmlidXRlKCdpZCcsICd0ZXh0MScpO1xuICAgIHRleHQxLnRleHRDb250ZW50ID0gXCJUaGUgYmVzdCBJY2UgQ3JlYW0gY2hhaW4gYXJvdW5kLlwiO1xuXG4gICAgbGV0IHRleHQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICB0ZXh0Mi5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3RleHQyJyk7XG4gICAgdGV4dDIudGV4dENvbnRlbnQgPSBcIkljZSBDcmVhbXMgYXJlIHBlcnNvbmFsLiBTbyBjcmVhdGUgeW91ciBvd24gZmxhdm91ciBhbmQgbWFrZSB5b3VyIGNvbmUgeW91ciBvd24uIFRoZSBwb3NzaWJpbGl0ZXMgYXJlIGxpbWl0bGVzcy5cIjtcblxuXG4gICAgc2NyZWVuLmFwcGVuZENoaWxkKHRleHQxKTtcbiAgICBzY3JlZW4uYXBwZW5kQ2hpbGQodGV4dDIpO1xuXG59XG5cbm1lbnUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB3cml0ZV9tZW51KVxuXG5mdW5jdGlvbiB3cml0ZV9tZW51KCl7XG4gICAgc2NyZWVuLmlubmVySFRNTCA9ICcnO1xuICAgIHNjcmVlbi5zdHlsZS5jc3NUZXh0ID0gXCJkaXNwbGF5OiBncmlkOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBncmlkLXRlbXBsYXRlOiAxZnIgMWZyLyAxZnIgMWZyOyBnYXA6MjBweDsgcGFkZGluZzo0MHB4O1wiO1xuXG4gICAgbGV0IGNhcmQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY2FyZDEuY2xhc3NMaXN0LmFkZCgnY2FyZCcpO1xuICAgIGNhcmQxLnRleHRDb250ZW50ID0gXCJDaG9jb2xhdGVcIjtcbiAgICBjYXJkMS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImJyb3duXCI7XG4gICAgY2FyZDEuc3R5bGUuY29sb3IgPSAnd2hpdGUnO1xuXG4gICAgbGV0IGNhcmQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY2FyZDIuY2xhc3NMaXN0LmFkZCgnY2FyZCcpO1xuICAgIGNhcmQyLnRleHRDb250ZW50ID0gXCJTdHJhd2JlcnJ5XCI7XG4gICAgY2FyZDIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJwaW5rXCI7XG4gICAgY2FyZDIuc3R5bGUuY29sb3IgPSAnYmxhY2snO1xuXG4gICAgbGV0IGNhcmQzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY2FyZDMuY2xhc3NMaXN0LmFkZCgnY2FyZCcpO1xuICAgIGNhcmQzLnRleHRDb250ZW50ID0gXCJQaXN0YVwiO1xuICAgIGNhcmQzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwibGlnaHRncmVlblwiO1xuICAgIGNhcmQzLnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcblxuICAgIGxldCBjYXJkNCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNhcmQ0LmNsYXNzTGlzdC5hZGQoJ2NhcmQnKTtcbiAgICBjYXJkNC50ZXh0Q29udGVudCA9IFwiQmxhY2sgQ3VycmFudFwiO1xuICAgIGNhcmQ0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiZ3JheVwiO1xuICAgIGNhcmQ0LnN0eWxlLmNvbG9yID0gJ3doaXRlJztcblxuICAgIHNjcmVlbi5hcHBlbmRDaGlsZChjYXJkMSk7XG4gICAgc2NyZWVuLmFwcGVuZENoaWxkKGNhcmQyKTtcbiAgICBzY3JlZW4uYXBwZW5kQ2hpbGQoY2FyZDMpO1xuICAgIHNjcmVlbi5hcHBlbmRDaGlsZChjYXJkNCk7XG5cbn1cblxuY29udGFjdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHdyaXRlX2NvbnRhY3QpXG5cbmZ1bmN0aW9uIHdyaXRlX2NvbnRhY3QoKXtcbiAgICBzY3JlZW4uaW5uZXJIVE1MID0gJyc7XG4gICAgc2NyZWVuLnN0eWxlLmNzc1RleHQgPSBcIlwiO1xuXG4gICAgbGV0IGMxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGV0IHAxMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBwMTEudGV4dENvbnRlbnQgPSBcIlJvY2t5IEJoYWlcIlxuICAgIHAxMS5zdHlsZS5mb250U2l6ZSA9IFwiMzBweFwiO1xuXG4gICAgbGV0IHAxMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBwMTIudGV4dENvbnRlbnQgPSBcIkNFTyBvZiBJbmRpYVwiO1xuXG4gICAgbGV0IHAxMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBwMTMudGV4dENvbnRlbnQgPSBcInJvY2t5YXNoQG5hcmFjaGkuY28uaW5cIjtcbiAgICBjMS5hcHBlbmRDaGlsZChwMTEpO1xuICAgIGMxLmFwcGVuZENoaWxkKHAxMik7XG4gICAgYzEuYXBwZW5kQ2hpbGQocDEzKTtcblxuICAgIHNjcmVlbi5hcHBlbmRDaGlsZChjMSk7XG5cbiAgICBcbmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBcblxuXG59XG5cbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4iLCJsZXQgc2NyZWVuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21pZGRsZS13aW5kb3cnKTtcblxubGV0IG1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbm1lbnUudGV4dENvbnRlbnQgPSBcIk1lbnVcIjtcbm1lbnUuY2xhc3NMaXN0LmFkZCgnaGVhZGVyLWJ1dHRvbicpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgbWVudTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=